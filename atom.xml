<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miya&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-17T18:36:03.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miya Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS脚本异步加载</title>
    <link href="http://yoursite.com/2018/08/18/46-JS%E8%84%9A%E6%9C%AC%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/08/18/46-JS脚本异步加载/</id>
    <published>2018-08-17T18:25:56.000Z</published>
    <updated>2018-08-17T18:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>在梳理知识点的时候，发现作为浏览器渲染中的机制之一——异步加载机制，当用户访问站点，需要下载各种资源，例如JS脚本，CSS，图片，iframe等，它是实现现代网站进行加载页面时一种必不可少的手段。查资料加上老师拓展课程均对于异步加载机制还有很多方法可以说，故抽出来单独进行一个知识点的梳理。<br><a id="more"></a></p><blockquote><p>了解js脚本异步加载前，我们有必要先了解一下浏览器在页面样式和js的作用下出现的两种页面常见场景：白屏和fouc（无样式内容闪烁）。</p></blockquote><h1 id="一、白屏和FOUC"><a href="#一、白屏和FOUC" class="headerlink" title="一、白屏和FOUC"></a>一、白屏和FOUC</h1><h3 id="1、即指影响浏览器页面加载顺序的两种场景"><a href="#1、即指影响浏览器页面加载顺序的两种场景" class="headerlink" title="1、即指影响浏览器页面加载顺序的两种场景"></a>1、即指影响浏览器页面加载顺序的两种场景</h3><p>-白屏：特指一种场景，打开页面是一片白色，突然页面出现，样式正确。那么一片白色的时间，则称之为白屏。<br>-FOUC (Flash of UnstyledContent)：无样式内容闪烁，网速情况差，打开页面时仍有样式，之后样式时有时无，甚至一开始并无出现样式，突然样式恢复。（常出现在firefox浏览器）</p><p>此类现象，在不同浏览器进行的资源加载和页面渲染时，所采用的不同的处理方式，并不是bug。</p><h3 id="2、写一个server，验证白屏和fouc效果"><a href="#2、写一个server，验证白屏和fouc效果" class="headerlink" title="2、写一个server，验证白屏和fouc效果"></a>2、写一个server，验证白屏和fouc效果</h3><p>在样式文件index.html中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;fouc &amp; 白屏&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--在下面模拟一个延时装置--&gt;  </span><br><span class="line">     &lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt; //设置这个工具，当请求该文件时，服务器会延迟请求10s再去加载这个资源，以此可以模拟一个网速特别慢的情况</span><br><span class="line">     &lt;link rel=&quot;stylesheet&quot; href=&quot;a.css?t=3&quot;&gt; </span><br><span class="line">  </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;p&gt;饥人谷&lt;/p&gt;</span><br><span class="line">&lt;!--   &lt;script src=&quot;A.js?t=5&quot;&gt;&lt;/script&gt; </span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/15/1653c442f35af77c?w=211&amp;h=200&amp;f=png&amp;s=8004&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--   &lt;link rel=&quot;stylesheet&quot; href=&quot;c.css?t=6&quot;&gt;  --&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--   &lt;script src=&quot;http://a.jrg.com:8080/B.js?t=4&quot; &gt;&lt;/script&gt;  </span><br><span class="line">  &lt;script src=&quot;http://b.jrg.com:8080/A.js?t=8&quot; &gt;&lt;/script&gt;   --&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>（1）关于白屏，需要注意的是，浏览器对于样式和js的处理，即CSS 和 JS 放置顺序。推荐：将样式放在<code>&lt;head&gt;</code>里面,将JS放在<code>&lt;body&gt;</code>内部下方。</p><p>如上面代码所示，html页面里引入了两个css：<code>a.css</code>和<code>b.css</code>。<code>b.css</code>引用了<code>c.ss</code>（<code>@import&quot;./c.css?t=5&quot;;</code>）<code>b.css</code>中加入了一个10s的延时文件（<code>&lt;link rel=&quot;stylesheet&quot;href=&quot;b.css?t=10&quot;&gt;</code>），加载这个10s的css样式文件，浏览器是如何完成加载工作，有两种方式：</p><p><strong>第1种：</strong> html解析完成，此时10s延时的css文件先不管，先展示<code>&lt;body&gt;</code>里所展示的内容，等css文件全加载后再去计算样式，再去重新渲染一次</p><p><strong>第2种：</strong> 即使html的dom树已经解析、渲染都完成，对未加载完成的样式都必须等待，即css样式要全部加载、获取，img资源加载完成，此时底部JS立刻执行，才一次性展示出页面。例子中展示这种方法，即为白屏很久的原因。</p><p>（2）不同浏览器的不同处理机制所出现的场景不同</p><p>A、<strong>白屏场景（常出现在chrome）：</strong> 打开一个国外网站，使用国外服务器，嵌在css的字体使用的是谷歌字体，运行特别慢，等了好久突然出现页面样式效果。这是因为页面需要等待css样式加载所有完成，甚至出现404加载失败，最后才展示出页面。那么那段加载时间，等待了几秒左右的白色一片的页面，就是白屏</p><p>B、<strong>Fouc场景（常出现在Firefox）：</strong> 一开始的时候，先让你看见样式，如字的小号样式，样式加载完后看到所规定字号的大字。对用户来说，同样的样式，突然从小变大，则这个场景就是Fouc（无样式内容闪烁）。</p><p><strong>总结：</strong> 不管是css样式，还是js文件，只要加长延时，都会造成白屏</p><p>（3）CSS 和 JS 最佳放置顺序</p><ul><li>使用 link 标签将样式表放在顶部</li><li>将JS放在底部</li></ul><p>（3.1）场景：假设JS文件页面顶部：</p><ul><li>JS脚本会阻塞后面内容的呈现</li><li>JS脚本会阻塞其后组件（如图片）的下载</li><li>JS加载时间过长，css需等待，则会出现一段时间白屏</li></ul><p><strong>场景说明：</strong> 引入一个JS文件在顶部，设置一个延时时间。</p><p><strong>加载顺序：</strong> css—js—img—全部获取到展现页面效果</p><p>此时，img和css加载时会并发加载，即如一个域名下同时加载两个文件（并发是有限度的），加载在顶部的js时，会禁用并发img和css，并阻止其他内容下载和渲染。</p><p>js并不影响css加载，但是会影响css样式的一个计算。当js加载时，css已经获取到（不过此时页面还是一片空白），直到js获取立即执行后，图片立刻出现，页面才展示效果。所以js文件放入页面顶部<code>&lt;head&gt;</code>里，也会导致白屏现象出现</p><p>（3.2）JS加载特点总结</p><p>A、优先加载js文件，加载后js立刻去执行，展示页面（CSS样式则是全部加载完，然后一次性展示出页面）</p><p><strong>注：</strong> css放前面，优先加载；若放后面，其他资源则会阻碍css加载，那么时机就太晚。</p><p>B、由于渲染线程和js脚本线程是互斥的，白屏是渲染进程被阻塞的原因，当碰到script标签的时候，会先执行js脚本，然后再渲染。</p><ul><li>（放顶部时）JS加载时机过晚导致一系列问题，脚本会阻塞后面内容的呈现、脚本会阻塞其后组件的下载（主要指img资源下载）、白屏等。</li><li>（放底部）则可以先让其他先加载完成，JS立刻执行的特点可以“扫尾”最后的页面效果</li></ul><p>C、JS脚本操作页面上的html+css元素，（放顶部时）JS先执行，元素都未加载到（即不存在），未出现在文档流中【加载，这里指资源加载和资源是否出现在文档流中】，所以也不能操作相应JS功能，此时后台将会报错。</p><p>D、（放顶部时）其他JS若作为一种框架语言，则能提前形成一个初步的框架有效构成页面结构。</p><h1 id="二、JS脚本的异步加载"><a href="#二、JS脚本的异步加载" class="headerlink" title="二、JS脚本的异步加载"></a>二、JS脚本的异步加载</h1><h3 id="1、一个问题？"><a href="#1、一个问题？" class="headerlink" title="1、一个问题？"></a>1、一个问题？</h3><p>即一个放在<head>的js文件，如下：<br><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></head></p><p>原本放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载呢？</p><h3 id="2、解决方法：-async和defer"><a href="#2、解决方法：-async和defer" class="headerlink" title="2、解决方法： async和defer"></a>2、解决方法： <code>async</code>和<code>defer</code></h3><p>（1）作用：<br>没有 <code>defer</code> 或<code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该<code>&lt;script&gt;</code>标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。也就是说，使用<code>defer</code>或<code>async</code>后能够改变这种加载、执行的时机。</p><p>常应用在引用了广告和统计的页面中，不会影响、堵塞，更不会影响到到页面其他元素</p><p>（2）<code>async</code><br>HTML5里为<code>script</code>标签里新增了async属性，用于异步加载脚本：<br>不保证顺序（独立的个体）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">/*或*/</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>浏览器解析到HTML里的该行script标签，发现指定为<code>async</code>，会异步下载解析执行脚本（即加载后续文档元素的过程将和script.js的加载并行进行）。</p><p>页面的DOM结构里假设<code>&lt;script&gt;</code>在img之前，如果你的浏览器支持<code>async</code>的话，就会异步加载脚本。此时DOM里已经有img了，所以脚本里能顺利取到img的src并弹框。</p><p>（3）<code>defer</code><br><code>&lt;script&gt;</code>标签里可以设置<code>defer</code>，表示延迟加载脚本：脚本先不执行，延迟到文档解析和显示后执行，有顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">/*或*/</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>浏览器解析到HTML里该<code>行&lt;script&gt;</code>标签，发现指定为<code>defer</code>，会暂缓下载解析执行脚本，等到页面文档解析并加载执行完毕后，才会加载该脚本（更精确地说，是在DOM树构建完成后，在<code>DOMContentLoaded</code>事件触发前，加载<code>defer</code>的脚本）。</p><p>页面的DOM结构里假设script在img图片之前，如果你的浏览器支持defer的话，就会延迟到页面加载完后才下载脚本。此时DOM里已经有img元素了，所以脚本里能顺利取到img的src并弹框。</p><p><strong>总结：</strong> JS实质采用一种可以更自由地选择加载时机和任何位置，让处于顶部的js文件能够像在底部时，在页面必要元素加载完成时进行“异步”加载。</p><h1 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h1><ul><li>同步：等待结果</li><li>异步：不等待结果</li></ul><p>注意，异步常常伴随回调一起出现，但是异步不是回调，回调也不一定是异步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 同步的 sleep</span><br><span class="line">function sleep(seconds)&#123;</span><br><span class="line">    var start = new Date()</span><br><span class="line">    while(new Date() - start &lt; seconds * 1000)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">console.log(1)   </span><br><span class="line">sleep(3)        //3秒内要不断重复做一些无意义的工作才能保证js运行按顺序</span><br><span class="line">console.log(&apos;wake up&apos;)</span><br><span class="line">console.log(2)</span><br><span class="line"></span><br><span class="line">//执行结果的顺序是：打印1——停3s——醒来——打印2，但事实上js环境内，停3s不可能不做事情</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546e619b068b82?w=600&amp;h=176&amp;f=jpeg&amp;s=20633" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">同步的 sleep</span><br><span class="line">//异步的 sleep</span><br><span class="line">function sleep(seconds, fn)&#123;</span><br><span class="line">    setTimeout(fn, seconds * 1000)</span><br><span class="line">&#125;</span><br><span class="line">console.log(1)</span><br><span class="line">sleep(3, ()=&gt; console.log(&apos;wake up&apos;))</span><br><span class="line">console.log(2)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546e686286647e?w=600&amp;h=195&amp;f=jpeg&amp;s=20145" alt="异步的 sleep"></p><p><strong>画一张同步&amp;异步工作的示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546e7766d3fdcd?w=600&amp;h=359&amp;f=jpeg&amp;s=35062" alt=""><br>可以看出，用了异步之后，JS 的空闲时间多了许多。</p><p>但是注意，在 JS 空闲的这段时间，实际上是浏览器中的计时器在工作（很有可能是每过一段时间检查是否时间到了，具体要看 Chrome 代码）</p><h1 id="四、遇到异步实例"><a href="#四、遇到异步实例" class="headerlink" title="四、遇到异步实例"></a>四、遇到异步实例</h1><h3 id="1、前端经常遇到的异步：图片加载是需要时间的"><a href="#1、前端经常遇到的异步：图片加载是需要时间的" class="headerlink" title="1、前端经常遇到的异步：图片加载是需要时间的"></a>1、前端经常遇到的异步：图片加载是需要时间的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagNames(&apos;img&apos;)[0].width // 宽度为 0</span><br><span class="line">console.log(&apos;done&apos;)</span><br></pre></td></tr></table></figure><p>刚开始是直接获取宽度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/17/16546d713fd568f0?w=1200&amp;h=799&amp;f=jpeg&amp;s=121670&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">var w = document.getElementsByTagNames(&apos;img&apos;)[0].width</span><br><span class="line">console.log(w)</span><br></pre></td></tr></table></figure></p><p>先画一个示意图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546e840725a8e9?w=600&amp;h=455&amp;f=jpeg&amp;s=29155" alt=""><br>由此可知，js在img网络请求还没执行完的时候紧随执行，可知为异步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//先获取网络请求前img信息，为空对象</span><br><span class="line">var img = document.getElementsByTagName(&apos;img&apos;)[0]</span><br></pre></td></tr></table></figure></p><p>img等待网络请求完成后，获取完整图片信息后，便会触发一个onload事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//等待完成之后执行的内容：img如果加载成功，就会触发一个onload的事件，获取它的宽度并打印出宽度</span><br><span class="line">img.onload = function()&#123;</span><br><span class="line">     var w =img.width</span><br><span class="line">     console.log(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>✨完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var img = document.getElementsByTagName(&apos;img&apos;)[0]</span><br><span class="line"></span><br><span class="line">//异步不等继续执行，异步回调函数：等待到网络请求完成后触发onload事件</span><br><span class="line">img.onload = function()&#123;</span><br><span class="line">      var w =img.width</span><br><span class="line">      console.log(w)</span><br><span class="line">&#125;</span><br><span class="line">console.log(img.width)</span><br><span class="line">/*或*/</span><br><span class="line">document.getElementsByTagNames(&apos;img&apos;)[0].onload = function()&#123;</span><br><span class="line">    console.log(this.width) // 宽度不为 0</span><br><span class="line">    console.log(&apos;real done&apos;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;done&apos;)</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong> 异步想拿到一个结果，常采用监听一个事件，然后告知（这个事件的完成时间不确定，不可预测），那就可以挂一个函数在onload上，等你请求完成，调用一下onload事件，此为回调函数。</p><h3 id="2、面试题中的异步"><a href="#2、面试题中的异步" class="headerlink" title="2、面试题中的异步"></a>2、面试题中的异步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let liList = document.querySelectorAll(&apos;li&apos;)</span><br><span class="line">for(var i=0; i&lt;liList.length; i++)&#123;</span><br><span class="line">    liList[i].onclick = function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取dom结构的所有li元素，获取li的长度去遍历，每一个点击后都能打印出东西</span><br></pre></td></tr></table></figure><p>把 var i 改成 let 就可以破解：<a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28140450</a></p><p>先让我运行上面的js代码：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546e981be1c89a?w=600&amp;h=331&amp;f=gif&amp;s=93720" alt=""><br>这里，js代码运行，还要注意一个技巧：变量提升，即</p><p><code>var i = 0</code></p><p>【关键点】变量提升为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i</span><br><span class="line">i =0</span><br></pre></td></tr></table></figure></p><p>那么，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let liList = document.querySelectorAll(&apos;li&apos;)</span><br><span class="line">var i   //i是贯穿6次循环的一个变量（没有多个）</span><br><span class="line">for(i=0; i&lt;liList.length; i++)&#123;</span><br><span class="line">    liList[i].onclick = function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>画一个时序图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f0573aaf21f?w=600&amp;h=672&amp;f=jpeg&amp;s=45481" alt=""></p><p>可以看出，js执行代码时，当i=5，<code>i++</code>结果为6的时候，并不小于<code>liList.length</code>，那么就跳出该循环，最后输出结果：i=6。js代码执行完，用户开始操作他的鼠标，假设等待3ms后，执行<code>click li</code>，当你最先click的时候（i=0，<code>liList[0]</code>，此时js已经执行完代码，输出i = 6 ），而不是在绑定事件的时候打印出几，就是几。</p><p>在这里，我们有必要知道，异步函数以下绑定事件为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXXX.onclick function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>浏览器并未等该异步执行，直接进入for循环，直接将i=6输出，然后第一个<code>click</code>才出现，浏览器不会等click出现才去打印<code>i</code> 值<br>如何解决？——使用let</p><p><strong>假设你已经知道let（不懂看这篇文章）：</strong><br><a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">方应杭：我用了两个月的时间才理解let</a></p><p>将代码var i改为let：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let liList = document.querySelectorAll(&apos;li&apos;)</span><br><span class="line">for(let i=0; i&lt;liList.length; i++)&#123;</span><br><span class="line">    liList[i].onclick = function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行如下：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f289493be04?w=599&amp;h=282&amp;f=gif&amp;s=9616083" alt=""><br>为何let能一一打印出结果呢？即let不会被提升到外面，let作用域即处于for循环函数里，即每一次循环，liList[i]都有一个新的 i 值。let会在每一次进入循环时，产生一个分身i1-i6.</p><p>画一个运行图：【缺】</p><h3 id="3、AJAX-中的异步（必须）"><a href="#3、AJAX-中的异步（必须）" class="headerlink" title="3、AJAX 中的异步（必须）"></a>3、AJAX 中的异步（必须）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//同步的Ajax</span><br><span class="line">let request = $.ajax(&#123;</span><br><span class="line">  url: &apos;.&apos;,   //1、获取当前 url</span><br><span class="line">  async: false</span><br><span class="line">&#125;)//2、此时，该函数会等待请求完成才执行下一步</span><br><span class="line">console.log(request.responseText)//打印出这个请求的响应文本，即当前html页面</span><br><span class="line"></span><br><span class="line">//responseText:响应文本</span><br></pre></td></tr></table></figure><p>相当于同步，js在该函数中什么都没做，但就是停了几十ms，如同一个呆滞的人白白浪费了一段空闲时间。</p><p>而Ajax的异步如何做？——<code>async:true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;.&apos;,</span><br><span class="line">    async: true,</span><br><span class="line">    success: function(responseText)&#123;</span><br><span class="line">        console.log(responseText)</span><br><span class="line">    &#125;//表示：如果请求返回回来，麻烦调用以下success这个函数，然后把得出的结果打印出来</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;请求发送完毕&apos;)</span><br></pre></td></tr></table></figure></p><p>在控制台上，模拟一个网速很慢的操作：Network——slow 3G，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f4b926589c4?w=599&amp;h=346&amp;f=gif&amp;s=4951539" alt=""><br>首先ajax函数会发一个请求，继续执行第二句console.log，这就是ajax中的异步。在这里，先不管ajax里的请求成功或失败，直接执行第二句代码。不等，即为异步；而等则是一定要拿到结果才进行下一步。时间不到，异步绝对拿不到结果。</p><p>画一下图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f4e64453513?w=600&amp;h=579&amp;f=jpeg&amp;s=41502" alt=""><br>如果我们把它改为同步：<code>async:false</code>，并模拟一个很慢的网速：Network——add，参数设置如下：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f555087e792?w=600&amp;h=184&amp;f=jpeg&amp;s=28277" alt=""><br>同步之后，代码运行演示如下：<br><img src="https://user-gold-cdn.xitu.io/2018/8/17/16546f581579b9a4?w=599&amp;h=351&amp;f=gif&amp;s=9806536" alt=""></p><h1 id="五、异步的形式"><a href="#五、异步的形式" class="headerlink" title="五、异步的形式"></a>五、异步的形式</h1><p>从上面的例子中：可以通过绑定onload事件获取宽度大小，或者ajax中的success函数。一般，有两种方式拿到异步结果</p><h3 id="1、傻逼方法：轮询"><a href="#1、傻逼方法：轮询" class="headerlink" title="1、傻逼方法：轮询"></a>1、傻逼方法：轮询</h3><h3 id="2、正规方法：回调"><a href="#2、正规方法：回调" class="headerlink" title="2、正规方法：回调"></a>2、正规方法：回调</h3><p>回调的形式</p><ul><li>Node.js 的 error-first 形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./1.txt&apos;, (error, content)=&gt;&#123;</span><br><span class="line">    if(error)&#123;</span><br><span class="line">         // 失败</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         // 成功</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ul><p>-jQuery 的 success / error 形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     url:&apos;/xxx&apos;,</span><br><span class="line">     success:()=&gt;&#123;&#125;,</span><br><span class="line">     error: ()=&gt;&#123;&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p>-jQuery 的 done / fail / always 形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     url:&apos;/xxx&apos;,</span><br><span class="line"> &#125;).done( ()=&gt;&#123;&#125; ).fail( ()=&gt;&#123;&#125; ).always( ()=&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>Prosmise 的 then 形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     url:&apos;/xxx&apos;,</span><br><span class="line"> &#125;).then( ()=&gt;&#123;&#125;, ()=&gt;&#123;&#125; ).then( ()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="六、如何处理异常？"><a href="#六、如何处理异常？" class="headerlink" title="六、如何处理异常？"></a>六、如何处理异常？</h1><ul><li>如何使用多个 success 函数？</li><li>在有多个成功回调的情况下，如何处理异常？</li></ul><p><strong>自己返回 Promise</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function ajax()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        做事</span><br><span class="line">        如果成功就调用 resolve</span><br><span class="line">        如果失败就调用 reject</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var promise = ajax()</span><br><span class="line">promise.then(successFn, errorFn)</span><br></pre></td></tr></table></figure></p><ul><li>Promise 深入阅读：<br><a href="http://www.cnblogs.com/hustskyking/p/promise.html" target="_blank" rel="noopener"></a></li><li>Promise/A+ 规范：<br><a href="https://segmentfault.com/a/1190000002452115" target="_blank" rel="noopener"></a></li></ul><p><strong>async / await</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function buyFruit()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        做事</span><br><span class="line">        如果成功就调用 resolve</span><br><span class="line">        如果失败就调用 reject</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var promise = await ajax()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async functon fn()&#123;</span><br><span class="line">    var result = await buyFruit()</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">var r = await fn()</span><br><span class="line">console.log(r)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h4&gt;&lt;p&gt;在梳理知识点的时候，发现作为浏览器渲染中的机制之一——异步加载机制，当用户访问站点，需要下载各种资源，例如JS脚本，CSS，图片，iframe等，它是实现现代网站进行加载页面时一种必不可少的手段。查资料加上老师拓展课程均对于异步加载机制还有很多方法可以说，故抽出来单独进行一个知识点的梳理。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="异步加载" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="白屏和Fouc" scheme="http://yoursite.com/tags/%E7%99%BD%E5%B1%8F%E5%92%8CFouc/"/>
    
      <category term="defer和async" scheme="http://yoursite.com/tags/defer%E5%92%8Casync/"/>
    
      <category term="回调函数" scheme="http://yoursite.com/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端编码规范</title>
    <link href="http://yoursite.com/2018/08/18/45-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/08/18/45-前端编码规范/</id>
    <published>2018-08-17T18:25:43.000Z</published>
    <updated>2018-08-17T18:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、命名技巧"><a href="#一、命名技巧" class="headerlink" title="一、命名技巧"></a>一、命名技巧</h1><h3 id="1、语义化"><a href="#1、语义化" class="headerlink" title="1、语义化"></a>1、语义化</h3><p>即合适标签+合适命名<br>（1）语义化标签优先<br>（2）基于功能命名、内容命名、表现命名<br>（3）简略、明了、无后患<br>tips：可自己改名字、翻译成英文单词<br><a id="more"></a></p><h3 id="2、范例"><a href="#2、范例" class="headerlink" title="2、范例"></a>2、范例</h3><p>（1）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 不好  --&gt;</span><br><span class="line">&lt;div class=&quot;article&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;article_title&quot;&gt;编码规范&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;the_content&quot;&gt;今天讲的内容是编码规范，讲师</span><br><span class="line">     &lt;div class=&quot;darkbold&quot;&gt;若愚&lt;/div&gt; @饥人谷&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 好 --&gt;</span><br><span class="line">&lt;article&gt;</span><br><span class="line">  &lt;h1&gt;编码规范&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;今天讲的内容是编码规范，讲师</span><br><span class="line">     &lt;b&gt;若愚&lt;/b&gt; @饥人谷&lt;/p&gt;</span><br><span class="line">&lt;/article&gt;</span><br></pre></td></tr></table></figure></p><p>（2）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 不好  --&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;s&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;a class=&quot;link&quot; href=&quot;#&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 好 --&gt;</span><br><span class="line">&lt;div class=&quot;success&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;theme-color&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;a class=&quot;login&quot; href=&quot;#&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>（3）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 好 --&gt;</span><br><span class="line">&lt;article class=&quot;movies&quot;&gt;...&lt;/article&gt;</span><br><span class="line">&lt;article class=&quot;news&quot;&gt;...&lt;/article&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不好 --&gt;</span><br><span class="line">&lt;article class=&quot;blue&quot;&gt;...&lt;/article&gt;</span><br><span class="line">&lt;article class=&quot;redBg mt30 bigText&quot;&gt;...&lt;/article&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3、命名范例"><a href="#3、命名范例" class="headerlink" title="3、命名范例"></a>3、命名范例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）.所有命名都使用英文小写</span><br><span class="line">推荐：`&lt;div class=&quot;main&quot;&gt;&lt;/div&gt; `</span><br><span class="line">不推荐： `&lt;div class=&quot;Main&quot;&gt;&lt;/div&gt; `</span><br><span class="line">（2）.命名用引号包裹</span><br><span class="line">推荐：`&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; `</span><br><span class="line">不推荐： `&lt;div id=header&gt;&lt;/div&gt; `</span><br><span class="line">（3）.用中横线连接</span><br><span class="line">推荐：`&lt;div class=&quot;mod-modal&quot;&gt;&lt;/div&gt; `</span><br><span class="line">不推荐： `&lt;div class=&quot;modModal&quot;&gt;&lt;/div&gt; `</span><br><span class="line">（4）.命名体现功能，不涉及表现样式(颜色、字体、边框、背景等</span><br><span class="line">推荐：`&lt;div class=&quot;text-lesser&quot;&gt;&lt;/div&gt;`</span><br><span class="line">不推荐： `&lt;div class=&quot;light-grey&quot;&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>4、常见命名<br>第一种：</p><ul><li><code>.wrap</code>或<code>.wrapper</code>– 用于外侧包裹</li><li><code>.container</code>或 <code>.ct</code> – 包裹容器</li><li><code>.header</code> – 用于头部</li><li><code>.body</code> – 页面 body</li><li><code>.footer</code> – 页面尾部</li><li><code>aside</code>、<code>sidebar</code> – 用于侧边栏</li><li><code>.content</code> – 和<code>header footer</code>对应，用于主要内容</li><li><code>.navigation</code> – 导航元素</li><li><code>.pagination</code> – 分页<br>第二种：</li><li><code>.tabs</code> &gt;<code>.tab</code> – tab 切换</li><li><code>.breadcrumbs</code> – 导航列表、面包屑</li><li><code>.dropdown</code> – 下拉菜单</li><li><code>.article</code> – 文章</li><li><code>.main</code> – 用于主体</li><li><code>.thumbnail</code> – 头像，小图像</li><li><code>.media</code> – 媒体资源</li><li><code>.panel</code> – 面板</li><li><code>.tooltip</code> – 鼠标放置上去的提示</li><li><code>.popup</code> – 鼠标点击弹出的提示<br>第三种：</li><li><code>.button</code>、<code>.btn</code> – 按钮</li><li><code>.ad</code> – 广告</li><li><code>.subnav</code>– 二级导航</li><li><code>.menu</code> – 菜单</li><li><code>.tag</code> – 标签</li><li><code>.message</code>或者<code>.notice</code> – 提示消息</li><li><code>.summary</code> – 摘要</li><li><code>.logo</code> – logo</li><li><code>.search</code> – 搜索框</li><li><code>.login</code> – 登录<br>第四种：</li><li><code>.register</code> – 注册</li><li><code>.username</code> – 用户名</li><li><code>.password</code> – 密码</li><li><code>.banner</code> – 广告条</li><li>`.copyright – 版权</li><li><code>.modal</code>或者<code>.dialog</code>– 弹窗<br>第五种：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">var 名字 = &#123;</span><br><span class="line">  状态: [</span><br><span class="line">    &apos;inverse&apos;,</span><br><span class="line">    &apos;toggled&apos;,</span><br><span class="line">    &apos;switched&apos;,</span><br><span class="line">    &apos;original&apos;,</span><br><span class="line">    &apos;initial&apos;,</span><br><span class="line">    &apos;identified&apos;,</span><br><span class="line">    &apos;disabled&apos;,</span><br><span class="line">    &apos;loading&apos;,</span><br><span class="line">    &apos;pending&apos;,</span><br><span class="line">    &apos;syncing&apos;,</span><br><span class="line">    &apos;default&apos;</span><br><span class="line">  ],</span><br><span class="line">  修饰: [</span><br><span class="line">    &apos;dark&apos;,</span><br><span class="line">    &apos;light&apos;,</span><br><span class="line">    &apos;shaded&apos;,</span><br><span class="line">    &apos;flat&apos;,</span><br><span class="line">    &apos;ghost&apos;,</span><br><span class="line">    &apos;maroon&apos;,</span><br><span class="line">    &apos;pale&apos;,</span><br><span class="line">    &apos;intense&apos;,</span><br><span class="line">    &apos;twisted&apos;,</span><br><span class="line">    &apos;narrow&apos;,</span><br><span class="line">    &apos;wide&apos;,</span><br><span class="line">    &apos;smooth&apos;,</span><br><span class="line">    &apos;separate&apos;,</span><br><span class="line">    &apos;clean&apos;,</span><br><span class="line">    &apos;sharp&apos;,</span><br><span class="line">    &apos;aligned&apos;</span><br><span class="line">  ],</span><br><span class="line">  元素: [</span><br><span class="line">    &apos;pagination&apos;,</span><br><span class="line">    &apos;modal&apos;,</span><br><span class="line">    &apos;popup&apos;,</span><br><span class="line">    &apos;article&apos;,</span><br><span class="line">    &apos;story&apos;,</span><br><span class="line">    &apos;flash&apos;,</span><br><span class="line">    &apos;status&apos;,</span><br><span class="line">    &apos;state&apos;,</span><br><span class="line">    &apos;media&apos;,</span><br><span class="line">    &apos;block&apos;,</span><br><span class="line">    &apos;card&apos;,</span><br><span class="line">    &apos;teaser&apos;,</span><br><span class="line">    &apos;badge&apos;,</span><br><span class="line">    &apos;label&apos;,</span><br><span class="line">    &apos;sheet&apos;,</span><br><span class="line">    &apos;poster&apos;,</span><br><span class="line">    &apos;notice&apos;,</span><br><span class="line">    &apos;record&apos;,</span><br><span class="line">    &apos;entry&apos;,</span><br><span class="line">    &apos;item&apos;,</span><br><span class="line">    &apos;figure&apos;,</span><br><span class="line">    &apos;square&apos;,</span><br><span class="line">    &apos;module&apos;,</span><br><span class="line">    &apos;bar&apos;,</span><br><span class="line">    &apos;button&apos;,</span><br><span class="line">    &apos;action&apos;,</span><br><span class="line">    &apos;knob&apos;</span><br><span class="line">  ],</span><br><span class="line">  布局: [</span><br><span class="line">    &apos;navigation&apos;,</span><br><span class="line">    &apos;wrapper&apos;,</span><br><span class="line">    &apos;inner&apos;,</span><br><span class="line">    &apos;header&apos;,</span><br><span class="line">    &apos;footer&apos;,</span><br><span class="line">    &apos;aside&apos;,</span><br><span class="line">    &apos;section&apos;,</span><br><span class="line">    &apos;divider&apos;,</span><br><span class="line">    &apos;content&apos;,</span><br><span class="line">    &apos;container&apos;,</span><br><span class="line">    &apos;panel&apos;,</span><br><span class="line">    &apos;pane&apos;,</span><br><span class="line">    &apos;construct&apos;,</span><br><span class="line">    &apos;composition&apos;,</span><br><span class="line">    &apos;spacing&apos;,</span><br><span class="line">    &apos;frame&apos;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、CSS编码规范"><a href="#二、CSS编码规范" class="headerlink" title="二、CSS编码规范"></a>二、CSS编码规范</h1><h3 id="1、书写规范"><a href="#1、书写规范" class="headerlink" title="1、书写规范"></a>1、书写规范</h3><ul><li>tab 用两个空格表示</li><li>css的 :后加个空格，<code>{</code>前加个空格</li><li>每条声明后都加上分号</li><li>换行，而不是放到一行</li><li>颜色用小写，用缩写, <code>#fff</code></li><li>小数不用写前缀, <code>0.5s</code> -&gt; <code>.5s；</code>0不用加单位</li><li>尽量缩写，<code>margin: 5px 10px 5px 10px</code> -&gt;<code>margin: 5px 10px</code></li></ul><p>###　2、范例——google编码规范<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">.test &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 100px</span><br><span class="line">&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">.test &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Not recommended */</span><br><span class="line">h3 &#123;</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">h3 &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Not recommended: missing space */</span><br><span class="line">#video&#123;</span><br><span class="line">  margin-top: 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Not recommended: unnecessary line break */</span><br><span class="line">#video</span><br><span class="line">&#123;</span><br><span class="line">  margin-top: 1em;</span><br><span class="line">&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">#video &#123;</span><br><span class="line">  margin-top: 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Not recommended */</span><br><span class="line">a:focus, a:active &#123;</span><br><span class="line">  position: relative; top: 1px;</span><br><span class="line">&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  line-height: 1.2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Always put a blank line (two line breaks) between rules. */</span><br><span class="line">html &#123;</span><br><span class="line">  background: #fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  margin: auto;</span><br><span class="line">  width: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Not recommended */</span><br><span class="line">@import url(&quot;//www.google.com/css/maia.css&quot;);</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">  font-family: &quot;open sans&quot;, arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">@import url(//www.google.com/css/maia.css);</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">  font-family: &apos;open sans&apos;, arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三、参考</p><ul><li>google html css编码规范</li></ul><p><a href="https://google.github.io/styleguide/htmlcssguide.html" target="_blank" rel="noopener">google html css编码规范</a></p><ul><li>bootstrap编码规范</li></ul><p><a href="https://codeguide.bootcss.com" target="_blank" rel="noopener">bootstrap编码规范</a></p><p>其中，对新手前端写代码较重要的因素：<strong>声明顺序</strong>。相关的属性声明应当归为一组，并按照下面的顺序排列：</p><blockquote><p>Positioning（定位）</p></blockquote><blockquote><p>Box model（盒模型）</p></blockquote><blockquote><p>Typographic（与文字相关，字体大小宽高居中）</p></blockquote><blockquote><p>Visual（颜色相关）</p></blockquote><p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。</p><p>其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。</p><ul><li>命名这货真难</li></ul><p><a href="https://seesparkbox.com/foundry/naming_css_stuff_is_really_hard" target="_blank" rel="noopener">命名这货真难</a></p><p><strong>总结：链接里的文章强烈建议通看一遍</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、命名技巧&quot;&gt;&lt;a href=&quot;#一、命名技巧&quot; class=&quot;headerlink&quot; title=&quot;一、命名技巧&quot;&gt;&lt;/a&gt;一、命名技巧&lt;/h1&gt;&lt;h3 id=&quot;1、语义化&quot;&gt;&lt;a href=&quot;#1、语义化&quot; class=&quot;headerlink&quot; title=&quot;1、语义化&quot;&gt;&lt;/a&gt;1、语义化&lt;/h3&gt;&lt;p&gt;即合适标签+合适命名&lt;br&gt;（1）语义化标签优先&lt;br&gt;（2）基于功能命名、内容命名、表现命名&lt;br&gt;（3）简略、明了、无后患&lt;br&gt;tips：可自己改名字、翻译成英文单词&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端基本认识" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
    
    
      <category term="编码规范" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="元素命名" scheme="http://yoursite.com/tags/%E5%85%83%E7%B4%A0%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容</title>
    <link href="http://yoursite.com/2018/08/18/44-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/08/18/44-浏览器兼容/</id>
    <published>2018-08-17T18:25:31.000Z</published>
    <updated>2018-08-17T18:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于这一节的内容，看了一些编译原理才能略懂一二，据说还要去看一些C语言。。。所以计算机基础理论知识在往后的日子里还会相应补充。新手们还是多专注于多看书和多实践，很怕误导你们😅。老司机们如果有空闲看到这请轻拍~😂<br><a id="more"></a></p><h1 id="一、什么是浏览器兼容问题"><a href="#一、什么是浏览器兼容问题" class="headerlink" title="一、什么是浏览器兼容问题"></a>一、什么是浏览器兼容问题</h1><p>同一份代码在各浏览器上显示效果正常，有些不正常</p><ul><li>不正常的原因是什么？(不支持的属性? bug？)</li><li>如何让它展示正常?(条件注释？ 单独Hack？)</li></ul><h1 id="二、为什么会有浏览器兼容问题"><a href="#二、为什么会有浏览器兼容问题" class="headerlink" title="二、为什么会有浏览器兼容问题"></a>二、为什么会有浏览器兼容问题</h1><ul><li>同一产品，版本越老， bug 越多</li><li>同一产品，版本越新，功能越多</li><li>不同产品，不同标准，不同实现方式</li></ul><h1 id="三、处理兼容的时候要考虑"><a href="#三、处理兼容的时候要考虑" class="headerlink" title="三、处理兼容的时候要考虑"></a>三、处理兼容的时候要考虑</h1><ul><li>浏览器市场份额</li><li>常查CSS属性是否兼容</li><li>时常查 Hack 的写法</li></ul><h1 id="四、处理兼容问题的思路"><a href="#四、处理兼容问题的思路" class="headerlink" title="四、处理兼容问题的思路"></a>四、处理兼容问题的思路</h1><h3 id="1、要不要做"><a href="#1、要不要做" class="headerlink" title="1、要不要做"></a>1、要不要做</h3><p>产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）成本的角度 (有无必要做某件事)</p><h3 id="2、做到什么程度"><a href="#2、做到什么程度" class="headerlink" title="2、做到什么程度"></a>2、做到什么程度</h3><p>让哪些浏览器支持哪些效果</p><h3 id="3、如何做"><a href="#3、如何做" class="headerlink" title="3、如何做"></a>3、如何做</h3><p>(1)根据兼容需求选择技术框架/库(jquery的版本)</p><p>(2)根据兼容需求选择兼容工具（htmlshiv.js、respond.js、css reset、normalize.css、modernizr）</p><p>(3)postcss<br>贴一个方方老师对postcss的经典回答：<br><a href="https://www.zhihu.com/question/46312839/answer/190587449" target="_blank" rel="noopener">各位前端大神能不能通俗的说一下PostCSS到底能做什么？对于手写css的优势在哪？</a></p><p>(4)条件注释、CSS Hack、js 能力检测做一些修补</p><h3 id="4、渐进增强和优雅降级"><a href="#4、渐进增强和优雅降级" class="headerlink" title="4、渐进增强和优雅降级"></a>4、渐进增强和优雅降级</h3><p>(1)渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验</p><p>(2)优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><h1 id="五、处理兼容问题的手段"><a href="#五、处理兼容问题的手段" class="headerlink" title="五、处理兼容问题的手段"></a>五、处理兼容问题的手段</h1><h3 id="1、合适的框架"><a href="#1、合适的框架" class="headerlink" title="1、合适的框架"></a>1、合适的框架</h3><p>Bootstrap (&gt;=ie8)；jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9)；Vue (&gt;= ie9)…</p><h3 id="2、条件注释"><a href="#2、条件注释" class="headerlink" title="2、条件注释"></a>2、条件注释</h3><p>即IE条件注释是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!--[if IE 6]&gt;</span><br><span class="line">    &lt;p&gt;You are using Internet Explorer 6.&lt;/p&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--[if !IE]&gt;&lt;!--&gt;</span><br><span class="line">    &lt;script&gt;alert(1);&lt;/script&gt;</span><br><span class="line">    &lt;!--&lt;![endif]--&gt;</span><br><span class="line">    </span><br><span class="line">/* if（如果是）非IE浏览器，else（那么）我的页面上该 &lt;script&gt;alert(1);&lt;/script&gt;标签会生效，</span><br><span class="line">弹出一个1；如果在IE浏览器上，这段本身是有效的，即能控制该效果，所以在其他浏览器这段则会被注释掉。*/</span><br><span class="line">    &lt;!--[if IE 8]&gt;</span><br><span class="line">    &lt;link href=&quot;ie8only.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3、CSS-hack"><a href="#3、CSS-hack" class="headerlink" title="3、CSS hack"></a>3、CSS hack</h3><p>（1）定义<br>由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。</p><p>这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能在不同的浏览器中也能得到我们想要的页面效果。</p><p>（2）常见hack写法<br>利用该方法去检测浏览器兼容问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  color: red;</span><br><span class="line">  _color: blue; /*针对后期检查将ie6和其他浏览器区别开来的标准*/</span><br><span class="line">  *color: pink; /*同上，ie6、7*/</span><br><span class="line">  color: yellow\9;  /*ie/edge 6-8*/</span><br><span class="line">&#125;</span><br><span class="line">以上属性均是采用样式覆盖形式，去相应地在所在浏览器属性生效</span><br><span class="line"></span><br><span class="line">&lt;!–-[if IE 7]&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;ie7.css&quot; type=&quot;text/css&quot; /&gt;</span><br><span class="line">&lt;![endif]–-&gt;</span><br></pre></td></tr></table></figure></p><p>（3）常见兼容处理范例<br>例子A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.target&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  *display: inline;/*在IE6、7中会生效，产生类似bfc的效果，可添加宽高，</span><br><span class="line">与其他浏览器所使用的display: inline-block;有相同效果*/</span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  display: block;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">  *zoom: 1; /* 仅对ie67有效 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子C：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  display: block;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">  *zoom: 1; /* 仅对ie67有效 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子D：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">   &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><p>例子E：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--[if IEMobile 7 ]&gt; &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot;class=&quot;no-js iem7&quot;&gt; &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 7 ]&gt;       &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie7 oldie&quot;&gt; &lt;![endif]--&gt;]--&gt;</span><br><span class="line">&lt;!--[if IE 7 ]&gt;       &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie7 oldie&quot;&gt; &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 8 ]&gt;       &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie8 oldie&quot;&gt; &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if (gte IE 9)|(gt IEMobile 7)|!(IEMobile)|!(IE)]&gt;&lt;!--&gt;&lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js&quot;&gt;&lt;!--&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><p>（4）常见属性的兼容情况：多使用 caniuse.com</p><ul><li><code>inline-block:</code> &gt;=ie8</li><li><code>min-width/min-height:</code> &gt;=ie8</li><li><code>:before,:after:</code>&gt;=ie8</li><li><code>div:hover:</code>&gt;=ie7</li><li><code>inline-block:</code> &gt;=ie8</li><li><code>background-size:</code> &gt;=ie9</li><li>圆角: &gt;= ie9</li><li>阴影: &gt;= ie9</li><li>动画/渐变: &gt;= ie10</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于这一节的内容，看了一些编译原理才能略懂一二，据说还要去看一些C语言。。。所以计算机基础理论知识在往后的日子里还会相应补充。新手们还是多专注于多看书和多实践，很怕误导你们😅。老司机们如果有空闲看到这请轻拍~😂&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="计算机基本知识" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="浏览器兼容" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="渐进增强" scheme="http://yoursite.com/tags/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA/"/>
    
      <category term="优雅降级" scheme="http://yoursite.com/tags/%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7/"/>
    
      <category term="CSS hack" scheme="http://yoursite.com/tags/CSS-hack/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：14闭包（词法作用域）</title>
    <link href="http://yoursite.com/2018/08/17/43-14%E9%97%AD%E5%8C%85%EF%BC%88%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/17/43-14闭包（词法作用域）/</id>
    <published>2018-08-16T17:45:14.000Z</published>
    <updated>2018-08-16T18:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>看过一些相关文章，知道想理解闭包，词法作用域和作用域（链）是非常重要的前置知识，结合之前所学，可以继续学习词法作用域和闭包。<br>想告诉一些前端萌新们：记录的知识都是在我理解的基础上记录下来的，也希望大家是理解的情况下去学习哦~（注意看我加粗的语句）<br><a id="more"></a></p><blockquote><p>可以回顾一下之前的作用域和作用域链：</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/37262599" target="_blank" rel="noopener">#hello，JS：04作用域和作用域链</a></p><blockquote><p>简单说一下作用域（链）的变量（标识符）如何找？</p></blockquote><ul><li>函数在执行的过程中，先从自己内部找声明过的变量</li><li>如果找不到，再从创建当前函数所在的作用域(词法作用域)去找, 以此往上（注：如果找不到则为<code>undefined</code>或报错）</li><li>注意找的是变量的当前的状态</li></ul><p><strong>参考资料：</strong><br>lce_shou《深入理解闭包之前置知识→作用域与词法作用域》</p><hr><h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><h1 id="一、了解词法作用域前，补充作用域下标识符的查找规则"><a href="#一、了解词法作用域前，补充作用域下标识符的查找规则" class="headerlink" title="一、了解词法作用域前，补充作用域下标识符的查找规则"></a>一、了解词法作用域前，补充作用域下标识符的查找规则</h1><p>看完了作用域和作用域链知识，我们有必要了解一下JS编译过程：<br>JavaScript是有编译过程的。先从这段简单的代码开始：<code>var name = &#39;iceman&#39;</code>，它的编译过程其实有两个动作：</p><ul><li>编译器在当前作用域中声明一个变量name</li><li>运行时引擎在作用域中查找该变量，找到了name变量并为其赋值</li></ul><p>证明以上的说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(name); // 输出undefined</span><br><span class="line">var name = &apos;iceman&apos;;</span><br></pre></td></tr></table></figure></p><p>在<code>var name = &#39;iceman&#39;</code>的上一行输出name变量，并没有报错，输出<code>undefined</code>，说明输出的时候该变量已经存在了，只是没有赋值而已。</p><p>其实编译器是这样工作的，在代码执行之前从上到下的进行编译，当遇到某个用var声明的变量的时候，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量。</p><p><strong>上面的这段简单的代码包含两种查找类型：</strong></p><ul><li>输出变量的值时查找类型是：RHS，即变量出现在右侧时进行RHS查询。（作用域中查找变量都是RHS）。RHS就是取到它的源值。</li><li>找到变量为其赋值的查找类型是：LHS，即变量出现在赋值操作的左侧时进行`LHS查询。（所有的赋值操作中查找变量都是LHS）</li></ul><p><strong>注：</strong> “赋值操作的左侧和右侧”，并不意味着只是“=”，实际上赋值操作还有好几种形式。<br>作用域中查找变量都是RHS。查找规则是从当前作用域开始找，如果没找到再到父级作用域中找，一层层往外找，如果在全局作用域如果还没找到的话，就会报错了：<code>ReferenceError: 某变量 is not defined</code></p><p>所有的赋值操作中查找变量都是<code>LHS</code>。其中<code>a=4</code>这类赋值操作，也是会从当前作用域中查找，如果没有找到再到外层作用域中找，如果到全局变量啊这个变量，在非严格模式下会创建一个全局变量<code>a</code>。</p><p>注：非常不建议这么做，因为轻则污染全局变量，重则造成内存泄漏（比如：<code>a = 一个非常大的数组</code>，a在全局变量中，一直用有引用，程序不会自动将其销毁）。</p><h1 id="二、词法作用域是什么？"><a href="#二、词法作用域是什么？" class="headerlink" title="二、词法作用域是什么？"></a>二、词法作用域是什么？</h1><p>熟悉作用域后，通常我们将其定义为一套规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</p><p>我们在前面有抛出一个概念：<strong>“词法作用域是作用域的一种工作模型”</strong>，作用域有两种工作模型：一种主流的是，JavaScript的静态作用域——<strong>词法作用域</strong>，另一种则是<strong>动态作用域</strong>（比较少的语言在用）。先看一下这个代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(x) &#123;</span><br><span class="line"> var y = x + 4;</span><br><span class="line"> function fn2(z) &#123;</span><br><span class="line"> console.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line">fn2(y * 5);</span><br><span class="line">&#125;</span><br><span class="line">fn1(6); // 6 10 50</span><br></pre></td></tr></table></figure></p><p>例子中有三个嵌套的作用域：A、B、C，</p><ul><li>A 为全局作用域，有一个标识符：<code>fn1</code></li><li>B 为fn1所创建的作用域，有三个标识符：<code>x</code>、<code>y</code>、<code>fn2</code></li><li>C为fn2所创建的作用域，有一个标识符：<code>z</code></li></ul><p>如图：<img src="https://user-gold-cdn.xitu.io/2018/8/14/16537d570438347f?w=600&amp;h=215&amp;f=jpeg&amp;s=27836" alt=""><br><strong>作用域，</strong> 是由其代码写在哪里决定的，并且是从外向内逐级包含的。<br><strong>词法作用域，</strong> 即在你写代码时将变量和块作用域写在哪里来决定，编译阶段就能够知道全部标识符在哪里以及是如何声明的，词法作用域就是静态的作用域，能够预测在执行代码的过程中如何查找变量（标识符），它在你书写代码时就确定。</p><blockquote><p>一些疑问：<br>根据相关资料了解，这里面还会涉及：关于<code>eval()</code>和<code>with</code>的对其词法作用域有其特殊“欺骗”性，以此产生的性能问题，以及ES6中有了<code>let</code>、<code>const</code>所出现的块级作用域。我还没接触到很全面，所以我暂时不会记录这一方面的知识😂~</p></blockquote><h2 id="进入正题："><a href="#进入正题：" class="headerlink" title="进入正题："></a>进入正题：</h2><h1 id="三、闭包是什么？"><a href="#三、闭包是什么？" class="headerlink" title="三、闭包是什么？"></a>三、闭包是什么？</h1><h3 id="1、对闭包的各种解释"><a href="#1、对闭包的各种解释" class="headerlink" title="1、对闭包的各种解释"></a>1、对闭包的各种解释</h3><blockquote><p><strong>MDN的解释：</strong><br>A closure is the combination of a function and the lexical environment within which that function was declared.闭包，是一个变量所声明的函数+它的词法作用域的结合。</p></blockquote><blockquote><p><strong>JavaScriptKit的解释</strong><br>A closure is the local variables for a function - kept alive after the function has returned<br>闭包对于函数来说是个本地变量，这个变量是当这个函数返回的时候，变量还存在。闭包，能访问当前函数外的变量。</p></blockquote><blockquote><p><strong>还有《JavaScript高级程序设计》的解释：</strong><br>闭包是一个函数，指有权访问另一个函数作用域中的变量的函数。</p></blockquote><blockquote><p><strong>《JavaScript权威指南》的解释：</strong><br>从技术的角度讲，所有的JavaScript函数都是闭包。它们都是对象，它们都关联到作用域链。</p></blockquote><blockquote><p><strong>【较认可】《你不知道的JavaScript》的解释：</strong><br>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>闭包，是基于词法作用域书写代码时产生的一种现象。通过下面的实践你会知道，闭包在代码中随处可见，不用特意为其创建而创建，前端萌新们，我们可能不知道我们写代码的过程中其实已经产生了闭包。</p><h3 id="2、闭包的作用"><a href="#2、闭包的作用" class="headerlink" title="2、闭包的作用"></a>2、闭包的作用</h3><ul><li>封装数据</li><li>暂存数据</li></ul><h3 id="3、从实例浅析闭包"><a href="#3、从实例浅析闭包" class="headerlink" title="3、从实例浅析闭包"></a>3、从实例浅析闭包</h3><p><strong>实例1：</strong> 先看看下面这个代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">var name = &apos;iceman&apos;;</span><br><span class="line">function fn2() &#123;</span><br><span class="line">console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure></p><p>根据《JavaScript高级程序设计》中可知，这个函数出现了闭包。<strong>fn2访问到了fn1的变量</strong>，满足了书中对闭包的定义“有权访问另一个函数作用域中的变量的函数”，fn2本身是个函数，所以满足《JavaScript权威指南》所说的“所有的JavaScript函数都是闭包”<br>不过，看得出这是多个函数嵌套，特别是fn2本身是函数，也是一个返回值，也是fn1的赋值变量，对于基础不牢的小白来说还是很容易混淆的。</p><p><strong>实例2：</strong> 让我们看看下面这个代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function car()&#123;</span><br><span class="line">  var speed = 0</span><br><span class="line">  function fn()&#123;</span><br><span class="line">    speed++</span><br><span class="line">    console.log(speed)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var speedUp = car()</span><br><span class="line">speedUp()   //1</span><br><span class="line">speedUp()   //2</span><br></pre></td></tr></table></figure></p><p>分析如下：</p><ul><li>fn的词法作用域能访问car的作用域</li><li>根据条件执行fn函数内的代码，fn当做值返回</li><li>car执行后，将fn的引用赋值给speedUp，赋值过程即<code>speedUp=car=fn</code></li><li>执行speedUp，分别输出1，2</li></ul><p>通过引用的关系，speedUp就是fn函数本身（<code>speedUp=fn</code>）。执行speedUp能正常输出变量speed的值，这不就是“fn能记住并访问它所在的词法作用域”，而fn函数（被speedUp调用）的运行是在当前词法作用域之外。</p><p>通常，当car函数执行完毕之后，其作用域是会被销毁的，然后<strong>垃圾回收器会释放闭包那段内存空间</strong>，但是<strong>闭包就这样神奇地将car的作用域存活了下来，fn依然持有该作用域的引用</strong>，这块引用即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var speed = 0</span><br><span class="line"> function fn()&#123;</span><br><span class="line">   speed++</span><br><span class="line">   console.log(speed)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>以上引用就是闭包</strong></p><p><strong>总结：</strong> 某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。</p><h3 id="4、从经典实例深入学习闭包"><a href="#4、从经典实例深入学习闭包" class="headerlink" title="4、从经典实例深入学习闭包"></a>4、从经典实例深入学习闭包</h3><p><strong>实例3：</strong> 用for循环输出函数值的问题，先看下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fnArr = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  fnArr[i] =  function()&#123;</span><br><span class="line">    return i</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">console.log( fnArr[3]() ) // 10</span><br></pre></td></tr></table></figure></p><p>通过for循环，预期的结果我们是会输出<code>0-9</code>，但最后执行的结果，在控制台上显示则是全局作用域下的10个10。</p><p>这是因为当我们执行<code>fnArr[3]</code>时，先从它当前作用域中找<code>i</code>的变量，没找到<code>i</code>变量，从全局作用域下找。开始了从上到下的代码执行，要执行匿名函数function时，for循环已经结束（for循环结束的条件是当i大于或等于10时，就结束循环），然后执行函数function，此时当<code>i</code>等于<code>[0,1,2,3,4,5,6,7,8,9]</code>时，此时<code>i</code>再执行函数代码，输出值都是<code>i</code>循环结束时的最终值为：10，所以是输出10次10。</p><p>由此可知：<code>i</code> 是声明在全局作用域中，function匿名函数也是执行在全局作用域中，那当然是每次都输出10了。</p><p><strong>延伸：</strong>  那么，让 <code>i</code> 在每次迭代的时候都产生一个私有作用域，在这个私有的作用域中保存当前 <code>i</code>的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fnArr = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  fnArr[i] = (function()&#123;</span><br><span class="line">    var j = i</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return j</span><br><span class="line">     &#125;  </span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">console.log(fnArr[3]()) //3</span><br></pre></td></tr></table></figure></p><p>用一种更简洁、优雅的方式改造：<br><strong>将每次迭代的 i 作为实参传递给自执行函数，自执行函数用变量去接收输出值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fnArr = []</span><br><span class="line">for (var i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">  fnArr[i] =  (function(j)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return j</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log( fnArr[3]() ) // 3</span><br></pre></td></tr></table></figure></p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;看过一些相关文章，知道想理解闭包，词法作用域和作用域（链）是非常重要的前置知识，结合之前所学，可以继续学习词法作用域和闭包。&lt;br&gt;想告诉一些前端萌新们：记录的知识都是在我理解的基础上记录下来的，也希望大家是理解的情况下去学习哦~（注意看我加粗的语句）&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="词法作用域" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="作用域和作用域链" scheme="http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>hello,JS:12-03搭建服务器（下）</title>
    <link href="http://yoursite.com/2018/08/17/42-12.03%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/17/42-12.03搭建服务器（下）/</id>
    <published>2018-08-16T17:45:05.000Z</published>
    <updated>2018-08-17T17:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（一）实例一：写一个简单的服务器"><a href="#（一）实例一：写一个简单的服务器" class="headerlink" title="（一）实例一：写一个简单的服务器"></a>（一）实例一：写一个简单的服务器</h1><h2 id="一、nodejs写服务器"><a href="#一、nodejs写服务器" class="headerlink" title="一、nodejs写服务器"></a>一、nodejs写服务器</h2><h4 id="1、下载github代码"><a href="#1、下载github代码" class="headerlink" title="1、下载github代码"></a>1、下载github代码</h4><a id="more"></a><h4 id="2、开始操作："><a href="#2、开始操作：" class="headerlink" title="2、开始操作："></a>2、开始操作：</h4><p>（1）分析项目文件step0中的文件index.js，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)//是nodejs的内置模块——http(服务器）</span><br></pre></td></tr></table></figure></p><p>即nodejs通过<code>require</code>加载一个模块（一个对象，提供了一些方法能够实现所需要的功能），服务器的底层是由这个nodejs的http模块实现</p><p>（2）回到项目文件，用nodejs的内置模块创建一个server：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(function(req , res)&#123;</span><br><span class="line"></span><br><span class="line">&#125;)//内含一个回调函数</span><br></pre></td></tr></table></figure></p><p>以上函数实质上内部是一个异步过程，内部可以创建一个服务器，以这个函数作为对应的参数去处理请求。</p><blockquote><p>当浏览器去访问这个服务器的时候，该请求底层会被封装成一个对象。</p></blockquote><ul><li>一个对象：参数req（随意取名），即用户请求的信息都存在这个req对象中，通过获取req得到相关的信息数据（如用户IP、域名，以及一些浏览器的域名等等）</li><li>另一个对象：参数res，即需要返回给用户哪些东西</li></ul><p>（3）最终在项目文件中创建一个有着基本设置的服务器。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">    console.log(req)         //用户请求所附带的信息</span><br><span class="line">    res.write(&apos;hello world&apos;) //返回浏览器自带的一些信息</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(9000)  //用listen启动这个静态服务器</span><br></pre></td></tr></table></figure></p><p>（4）终端启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure></p><p>此时终端进入一个空白状态（输入无用），即服务器处于一个启动状态，等待用户输入</p><p>（5）浏览器输入服务器地址：<code>localhost:9000</code> （地址不一定一样，端口号自己弄）。出现如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165374e4ba8cf6d1?w=600&amp;h=242&amp;f=jpeg&amp;s=18287" alt=""></p><p>同时，终端相应出现req这个对象所附带的用户请求的信息（随意截图）<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165374e7c696a81c?w=600&amp;h=539&amp;f=jpeg&amp;s=135464" alt=""><br><strong>注：</strong> 事实上，<code>console.log</code>所执行的请求数据，除了可以是设定好的参数req，也可以是任意字符串，或者包含数据的json数据等等（不演示了）</p><h3 id="至此，写了一个简单的服务器"><a href="#至此，写了一个简单的服务器" class="headerlink" title="至此，写了一个简单的服务器"></a>至此，写了一个简单的服务器</h3><p><strong>延伸：解析一下响应体如何进入服务器——服务器处理请求——返回数据：</strong><br>拿 <code>res.write(&#39;hello  world&#39;)</code><br>举例：<code>res.write</code>（即一个响应体）是把数据（即<code>&#39;helloworld&#39;</code>）放到http的<code>response</code>响应体里（即响应内容里）<br>当我们代码请求后输入url发出网络请求，请求时浏览器自动添加响应头相关信息，请求发至服务器之后，则会开始执行以下代码：【这里就是开发者开发不同页面的个性创造所在】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">    console.log(req)         //用户请求所附带的信息</span><br><span class="line">    res.write(&apos;hello world&apos;) //返回浏览器带的信息（即响应体，页面展现的内容）</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>该服务器发了一个响应<code>res（response）</code>，此时服务器后台出现响应头（一些浏览器默认参数），如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165374fe25d4f888?w=600&amp;h=351&amp;f=jpeg&amp;s=63029" alt="响应头"></p><p>响应体对应代码中，则res所请求的内容，这里是<code>&#39;hello world&#39;</code>：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165375086d4a5fdb?w=600&amp;h=429&amp;f=jpeg&amp;s=59117" alt="响应体"></p><h3 id="总结，这是网站后台的一个基本逻辑"><a href="#总结，这是网站后台的一个基本逻辑" class="headerlink" title="总结，这是网站后台的一个基本逻辑"></a>总结，这是网站后台的一个基本逻辑</h3><h4 id="3、扩展：设置响应头"><a href="#3、扩展：设置响应头" class="headerlink" title="3、扩展：设置响应头"></a>3、扩展：设置响应头</h4><p>通过<code>res.setHeader()</code>设置响应头，如可添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</span><br><span class="line"></span><br><span class="line">//text/plain  表示返回内容用字符串（明文）去呈现或者当成html渲染，如text/html</span><br><span class="line">//charset=gbk  表示返回的内容用gbk解码，也可设置为charset=utf-8解码</span><br></pre></td></tr></table></figure></p><p>即项目文件代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">    console.log(&apos;jiengu&apos;)//服务器响应的内容</span><br><span class="line">    res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</span><br><span class="line">    res.write(&apos;你好世界&apos;)//响应体：页面展现的内容</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(9000)</span><br></pre></td></tr></table></figure></p><p>重启终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure></p><p>服务器后台响应头设置相应参数后，出现如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165375258500bec6?w=600&amp;h=455&amp;f=jpeg&amp;s=79911" alt=""><br><strong>注意：</strong>  如出现乱码文件，实质可以在服务器的响应头层面去设置编码方式。如果返回的是一个html则可以从<code>meta</code>里去设置</p><p><strong>延伸：ajax的请求头 VS nodejs的响应头</strong><br><a href="https://zhuanlan.zhihu.com/p/39769828" target="_blank" rel="noopener">miya Wang：#hello，JS：12-01技术方案：Ajax 使用和原理</a></p><ul><li>ajax请求头：即服务器发送、返回时带的一些资源数据，如将url包含的一些各类数据作为请求资源，做一些加载、拼接等，然后返回结果数据。</li><li>nodejs的响应头：服务器对所请求的东西后台参数的一些响应，如设置页面展示效果的展示</li></ul><h4 id="4、加一个定时器观察服务器的响应"><a href="#4、加一个定时器观察服务器的响应" class="headerlink" title="4、加一个定时器观察服务器的响应"></a>4、加一个定时器观察服务器的响应</h4><p>项目文件代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//项目文件：(新）index.js</span><br><span class="line"></span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">   </span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;,&apos;text/html; charset=utf-8&apos;)</span><br><span class="line">//响应头：论及权限高，charset=utf-8作为请求http(浏览器)级别的请求,去解码</span><br><span class="line">//发一个请求去响应：头、身体内容，根据头解释身体内容（一堆字符串）</span><br><span class="line"></span><br><span class="line">    response.writeHead(404, &apos;Not Found&apos;)</span><br><span class="line">    response.write(&apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;gbk&quot; /&gt;&lt;/head&gt;&apos;)</span><br><span class="line">    response.write(&apos;&lt;body&gt;&apos;)</span><br><span class="line">    response.write(&apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;)</span><br><span class="line">    response.write(&apos;&lt;/body&gt;&apos;)</span><br><span class="line">    response.write(&apos;&lt;/html&gt;&apos;)</span><br><span class="line">    </span><br><span class="line">    response.end()</span><br><span class="line">  &#125;,2000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;open http://localhost:8080&apos;)</span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></p><p>重新启动终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure></p><p><strong>检查——控制台</strong> ,<strong>延伸：针对http对应的状态码作用</strong>。先看到几个效果：</p><ul><li><strong>当Status Code:200时</strong>，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653755bcdd11bbf?w=600&amp;h=404&amp;f=jpeg&amp;s=69961" alt=""></li><li><strong>当Status Code:400时</strong>，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653755bcdd11bbf?w=600&amp;h=404&amp;f=jpeg&amp;s=69961" alt=""><br>页面打开了（页面出现：你好）请求是成功的,但是打开控制台显示请求为红色，且console出现报错：<code>404(Notfound)</code>。一旦浏览器收到状态码为<code>404</code>，它则认为文件请求失败，但实际上它也是收到请求并返回数据的。</li></ul><p><strong>总结：</strong>  所请求的状态码通过<code>response.writeHead()</code>写出，完全由你来决定其页面呈现的状态</p><h1 id="（二）实例二：实现一个静态服务器"><a href="#（二）实例二：实现一个静态服务器" class="headerlink" title="（二）实例二：实现一个静态服务器"></a>（二）实例二：实现一个静态服务器</h1><p>准备好打包好的项目文件夹（包含html(css样式/js交互/图片））——网站放置在远程服务器上——通过执行服务器的相关js文件（执行<code>node  server.js</code>）——运行服务器</p><p>那么，这个运行服务器的js文件到底是怎么实现访问页面？<br>分析项目文件step1中的文件关键js文件：server.js，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//server.js</span><br><span class="line"></span><br><span class="line">var http = require(&apos;http&apos;) //前面说了，创建http服务器的底层内置模块</span><br><span class="line">var path = require(&apos;path&apos;)  //该模块可以处理不同系统下的url（不同系统路径写法不一）</span><br><span class="line">var fs = require(&apos;fs&apos;)      //该模块读、写文件</span><br><span class="line">var url = require(&apos;url&apos;)    //该模块自动解析url，读取信息，如控制台求location</span><br><span class="line"></span><br><span class="line">function staticRoot(staticPath, req, res)&#123;</span><br><span class="line">  console.log(staticPath)</span><br><span class="line">  </span><br><span class="line">  var pathObj = url.parse(req.url, true)</span><br><span class="line">  console.log(pathObj)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  if(pathObj.pathname === &apos;/&apos;)&#123;</span><br><span class="line">    pathObj.pathname += &apos;index.html&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var filePath = path.join(staticPath, pathObj.pathname)</span><br><span class="line">  </span><br><span class="line">  // var fileContent = fs.readFileSync(filePath,&apos;binary&apos;)</span><br><span class="line">  // res.write(fileContent, &apos;binary&apos;)</span><br><span class="line">  // res.end()</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  fs.readFile(filePath, &apos;binary&apos;, function(err, fileContent)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      console.log(&apos;404&apos;)</span><br><span class="line">      res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">      res.end(&apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      console.log(&apos;ok&apos;)</span><br><span class="line">      res.writeHead(200, &apos;OK&apos;)</span><br><span class="line">      res.write(fileContent, &apos;binary&apos;)</span><br><span class="line">      res.end()      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(path.join(__dirname, &apos;static&apos;))</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">  staticRoot(path.join(__dirname, &apos;static&apos;), req, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br><span class="line">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure></p><p>当用户访问<code>localhost:8080/index.html</code>，如何让用户看到项目文件的内容呢？<br>实现的关键，分解来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;) </span><br><span class="line">var path = require(&apos;path&apos;) </span><br><span class="line">var fs = require(&apos;fs&apos;)      </span><br><span class="line">var url = require(&apos;url&apos;)    </span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">  staticRoot(path.join(__dirname, &apos;static&apos;), req, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br><span class="line">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure></p><p>通过<code>http.creatServer</code>创建一个server，<code>listen</code>去启动一个服务器，监听8080端口，请求到来之后，进入server这个函数里，处理这个请求。写一个函数<code>staticRoot()</code>作为静态文件路径，将路径名、req、res都传递进去，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staticRoot(path.join(__dirname, &apos;static&apos;), req, res)</span><br></pre></td></tr></table></figure></p><p><code>__dirname</code> 为nodejs的内置变量，代表当前的文件server.js 再加上【static】，那么，<code>path.join(__dirname, &#39;static&#39;)</code> 则会生成一个 <strong>绝对路径</strong>,然后通过下面代码运行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function staticRoot(staticPath, req, res)&#123;</span><br><span class="line">  console.log(staticPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台随即得到项目文件的相关文件信息，通过绝对路径能读取文件。获取路径之后进行操作，需要通过用户的url，给用户返回一些特定内容，发出请求得到返回的是<code>console.log(req.url)</code>，<code>req.url</code>所返回的均是项目文件中的相关文件，即请求的均是这些文件index.html、a.css、logo.png，并得到，得到之后进行解析，如何解析？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var pathObj = url.parse(req.url, true)</span><br><span class="line">console.log(pathObj)</span><br></pre></td></tr></table></figure></p><p>实现一个默认页面：设置一个默认路径：<code>localhost:8080/index.html</code> ，如何实现？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(pathObj.pathname === &apos;/&apos;)&#123;</span><br><span class="line">  pathObj.pathname += &apos;index.html&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现原来可以这样设置一个默认路径的页面，也是很兴奋哦~：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165375c6bd803254?w=599&amp;h=433&amp;f=gif&amp;s=8250417" alt=""><br>通过一个<code>parseName</code>去得到一个完整路径，即静态目录路径则进入打包项目文件夹里，那么加上<code>pathObj.pathname</code>就得到该项目文件所请求的绝对路径地址filePath，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var filePath = path.join(staticPath, pathObj.pathname)</span><br></pre></td></tr></table></figure></p><p>如何读取文件？代码如下<br><strong>第1种：直接法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fileContent = fs.readFileSync(filePath,&apos;binary&apos;)</span><br><span class="line">res.write(fileContent, &apos;binary&apos;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure></p><p><strong>第2种：异步（也可作为当做制作404的页面状态）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath, &apos;binary&apos;, function(err, fileContent)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      console.log(&apos;404&apos;)</span><br><span class="line">      res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">      res.end(&apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      console.log(&apos;ok&apos;)</span><br><span class="line">      res.writeHead(200, &apos;OK&apos;)</span><br><span class="line">      res.write(fileContent, &apos;binary&apos;)</span><br><span class="line">      res.end()      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>？处理关于乱码的事情</p><h1 id="（三）实例三：实现功能更复杂的静态服务器（使用nodejs服务器理由解析）"><a href="#（三）实例三：实现功能更复杂的静态服务器（使用nodejs服务器理由解析）" class="headerlink" title="（三）实例三：实现功能更复杂的静态服务器（使用nodejs服务器理由解析）"></a>（三）实例三：实现功能更复杂的静态服务器（使用nodejs服务器理由解析）</h1><p>如url可获取任何数据，mock数据与前端交互。分析项目文件step2中的文件server-simple.js，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line"></span><br><span class="line">  var pathObj = url.parse(req.url, true)</span><br><span class="line">  console.log(pathObj)</span><br><span class="line"></span><br><span class="line">  switch (pathObj.pathname) &#123;</span><br><span class="line">    case &apos;/getWeather&apos;: //请求对应天气</span><br><span class="line">      var ret</span><br><span class="line">      if(pathObj.query.city == &apos;beijing&apos;)&#123;</span><br><span class="line">        ret = &#123;</span><br><span class="line">          city: &apos;beijing&apos;,</span><br><span class="line">          weather: &apos;晴天&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        ret = &#123;</span><br><span class="line">          city: pathObj.query.city,</span><br><span class="line">          weather: &apos;不知道&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(JSON.stringify(ret))</span><br><span class="line">      break;</span><br><span class="line">    case &apos;/user/123&apos;:  //对应的路由</span><br><span class="line">      res.end( fs.readFileSync(__dirname + &apos;/static/user.tpl&apos; ))</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      res.end( fs.readFileSync(__dirname + &apos;/static&apos; + pathObj.pathname) )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure></p><p>先分解简单代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">//根据函数req.url进行语句操作，假设req.url是请求getWeather，</span><br><span class="line">//res.end()括号内则是请求后所要获取的结果。</span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    switch (req.url)&#123;</span><br><span class="line">    case &apos;/getWeather&apos;:</span><br><span class="line">      res.end(JSON.stringify(&#123;a:1,b:2&#125;))</span><br><span class="line">      break;</span><br><span class="line">    case &apos;/user/123&apos;:</span><br><span class="line">      res.end( fs.readFileSync(__dirname + &apos;/static/user&apos;))</span><br><span class="line">      break;</span><br><span class="line">     default:</span><br><span class="line">      res.end(  fs.readFileSync(__dirname + &apos;/static&apos;+req.url))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>总结：</strong>  创建模块：http+fs模块——创建一个server——该server函数返回一个操作对象——该操作对象调用并启动端口为8080的服务器。当任何请求到来，只要以<code>localhost:8080</code>为前缀的url就会到达该服务器</p></blockquote><p>终端启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server-simple.js</span><br></pre></td></tr></table></figure></p><p>刷新页面处理js文件中函数对象的请求，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    switch (req.url)&#123;</span><br><span class="line">    case &apos;/getWeather&apos;:</span><br><span class="line">      res.end(JSON.stringify(&#123;a:1,b:2&#125;))</span><br><span class="line">      break;</span><br><span class="line">    case &apos;/user/123&apos;:</span><br><span class="line">      res.end( fs.readFileSync(__dirname + &apos;/static/user&apos;))</span><br><span class="line">      break;</span><br><span class="line">     default:  //表示用户希望请求的是一个静态文件，直接从static文件夹中读取文件req.url</span><br><span class="line">      res.end(  fs.readFileSync(__dirname + &apos;/static&apos;+req.url))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure></p><p>当我们访问static下的html、css、图片或者直接调取请求模块，都能获取相应的内容</p><p>一个复杂网站，具有静态功能，提供静态文件；可以处理动态路由；可以mock数据，通过以下代码启示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    switch (req.url)&#123;</span><br><span class="line">    case &apos;/getWeather&apos;:</span><br><span class="line">      res.end(JSON.stringify(&#123;a:1,b:2&#125;))</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure></p><p>可以写一个ajax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//b.js</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/getWeather?city=hangzhou&apos;, true)</span><br><span class="line">xhr.send()</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">  console.log(JSON.parse(xhr.responseText))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p>看nodejs这一节最后的时候，不知道是有点困逻辑无法梳理，还有一点复杂服务器的实现暂时看得不是很懂😂。并且对于nodejs的一些理论基础知识也是相对空白，看了阿里出品的《七天学会NodeJS》才发现原来老师是将理论融进这短短的几节课，然后就理解了很多理论的知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;（一）实例一：写一个简单的服务器&quot;&gt;&lt;a href=&quot;#（一）实例一：写一个简单的服务器&quot; class=&quot;headerlink&quot; title=&quot;（一）实例一：写一个简单的服务器&quot;&gt;&lt;/a&gt;（一）实例一：写一个简单的服务器&lt;/h1&gt;&lt;h2 id=&quot;一、nodejs写服务器&quot;&gt;&lt;a href=&quot;#一、nodejs写服务器&quot; class=&quot;headerlink&quot; title=&quot;一、nodejs写服务器&quot;&gt;&lt;/a&gt;一、nodejs写服务器&lt;/h2&gt;&lt;h4 id=&quot;1、下载github代码&quot;&gt;&lt;a href=&quot;#1、下载github代码&quot; class=&quot;headerlink&quot; title=&quot;1、下载github代码&quot;&gt;&lt;/a&gt;1、下载github代码&lt;/h4&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="后台服务器" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="静态服务器" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：12-02搭建服务器(上)</title>
    <link href="http://yoursite.com/2018/08/17/41-12.02%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2018/08/17/41-12.02搭建服务器(上)/</id>
    <published>2018-08-16T17:30:58.000Z</published>
    <updated>2018-08-17T17:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、如何获取数据（涉及开发流程）"><a href="#一、如何获取数据（涉及开发流程）" class="headerlink" title="一、如何获取数据（涉及开发流程）"></a>一、如何获取数据（涉及开发流程）</h1><h3 id="1、获取数据"><a href="#1、获取数据" class="headerlink" title="1、获取数据"></a>1、获取数据</h3><p>前端部分写了一个ajax，请求需要发送到服务器的接口上，服务器如果是不存在，直接报错，且无法后续测试，对于数据的处理、渲染无从谈起。接口如何运作起来，有数据返回，接口：后端开发<br><a id="more"></a></p><h3 id="2、网站的开发流程"><a href="#2、网站的开发流程" class="headerlink" title="2、网站的开发流程"></a>2、网站的开发流程</h3><p>（1）需求（前端、后端）<br>（2）前后端工作</p><ul><li>前端：写页面（html、css样式，js交互）</li><li>后端：提供数据</li></ul><p>（3）如做一个天气预报的页面网站：对前端页面功能的分解，数据需要什么？（前端主导？两者主导？）</p><ul><li>与后端协商：天气预报的数据接口：根据城市获取当天的天气；根据城市、日期获取某天的天气（接口url、传递的参数（城市？经纬度、ip、中英文）、返回数据格式（结构？字段？））</li><li>前端：模拟假数据（与后端协商后）</li></ul><p>（4）前后端开发完成，进行真实数据的测试、优化</p><h3 id="3、搭建服务器"><a href="#3、搭建服务器" class="headerlink" title="3、搭建服务器"></a>3、搭建服务器</h3><p>终端，启用静态服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http-server</span><br></pre></td></tr></table></figure></p><p>打开相应地址：我的是，<code>http://127.0.0.1:8080</code> （你的端口号不一定和我一样，不要纠结）</p><p>点开文件，简单功能开发时，把对应功能的接口放在html对应目录下，新建一个文件（json数据文件，即对应功能的数据），上传至githubpages或其他静态页面服务器上，其功能存在，继续进行功能的交互，就能获取相应功能数据。</p><h1 id="二、mock数据方法"><a href="#二、mock数据方法" class="headerlink" title="二、mock数据方法"></a>二、mock数据方法</h1><h3 id="1、方法1、线上githubpagesmock数据"><a href="#1、方法1、线上githubpagesmock数据" class="headerlink" title="1、方法1、线上githubpagesmock数据"></a>1、方法1、线上githubpagesmock数据</h3><p>（1）github创建一个项目：wxq393/wangyiyunmusic<br>（2）分别创建文件<br>A、html文件——home.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//home.html</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .cate .item &#123;</span><br><span class="line">      border: 1px solid #ccc;</span><br><span class="line">      line-height: 20px;</span><br><span class="line">      padding: 0 10px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;header&gt;&lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;div class=&quot;cate&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/wangyiyunmusic/cate.json&apos;, true)</span><br><span class="line">xhr.send()</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">  render(JSON.parse(xhr.responseText))</span><br><span class="line">  console.log(JSON.parse(xhr.responseText))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function render(cateData)&#123;  </span><br><span class="line">  for(var i = 0; i &lt; cateData.length; i++)&#123;</span><br><span class="line">    var node = document.createElement(&apos;div&apos;)</span><br><span class="line">    node.classList.add(&apos;item&apos;)</span><br><span class="line">    node.innerText = cateData[i]</span><br><span class="line">    document.querySelector(&apos;.cate&apos;).appendChild(node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>如图：熟悉一下dom的语法<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165373db8e150494?w=600&amp;h=282&amp;f=jpeg&amp;s=57987" alt=""></p><p>B、json文件——cate.json（注意路径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//cate.json</span><br><span class="line">[&quot;90后&quot;, &quot;80后&quot;, &quot;清晨&quot;, &quot;工作&quot;]</span><br></pre></td></tr></table></figure></p><p>C、直接githubpage去mock数据，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165373e64fb03b77?w=600&amp;h=329&amp;f=gif&amp;s=78458" alt=""></p><h3 id="2、方法2-使用-easymock-mock数据"><a href="#2、方法2-使用-easymock-mock数据" class="headerlink" title="2、方法2　使用 easymock mock数据"></a>2、方法2　使用 easymock mock数据</h3><p>A、进入<code>http://easy-mock.com/</code><br>创建url域名——创建接口——编辑json数据——更新、预览：即能看到返回的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*json数据编写：*/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;success&quot;: true,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &quot;80后&quot;,</span><br><span class="line">    &quot;90后&quot;,</span><br><span class="line">    &quot;00后&quot;,</span><br><span class="line">    &quot;清晨喝咖啡&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回数据另一种方法：点击主页面生成的url，使用终端测试，也能返回相应数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl  url地址</span><br></pre></td></tr></table></figure><p>如图：<img src="https://user-gold-cdn.xitu.io/2018/8/14/1653742145507c9f?w=600&amp;h=357&amp;f=jpeg&amp;s=223532" alt=""></p><p><strong>B、（继续）尝试在本地测试</strong><br>使用项目文件，添加请求数据的文件（文件名：1.html），代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        //所请求的数据url地址</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;https://easy-mock.com/mock/5b51c4919ce5fe26a0a3043d/getType&apos;,true)</span><br><span class="line">        xhr.send() </span><br><span class="line">  </span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123;</span><br><span class="line">                var data = xhr.responseText</span><br><span class="line">            console.log(data)</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&apos;error&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">          xhr.onerror = function()&#123;</span><br><span class="line">          console.log(&apos;error&apos;)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>右键启动该项目的终端服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http-server</span><br></pre></td></tr></table></figure></p><p>相应打开对应项目文件的url地址——检查——显示数据格式文件（定义好数据），说明所请求的数据已返回：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653746183cb4e57?w=600&amp;h=375&amp;f=gif&amp;s=89544" alt=""></p><h3 id="3、方法3-使用-http-rapapi-org-org-index-do"><a href="#3、方法3-使用-http-rapapi-org-org-index-do" class="headerlink" title="3、方法3　使用 http://rapapi.org/org/index.do"></a>3、方法3　使用 <a href="http://rapapi.org/org/index.do" target="_blank" rel="noopener">http://rapapi.org/org/index.do</a></h3><h3 id="4、方法4-使用-server-mock"><a href="#4、方法4-使用-server-mock" class="headerlink" title="4、方法4　使用 server-mock"></a>4、方法4　使用 server-mock</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、如何获取数据（涉及开发流程）&quot;&gt;&lt;a href=&quot;#一、如何获取数据（涉及开发流程）&quot; class=&quot;headerlink&quot; title=&quot;一、如何获取数据（涉及开发流程）&quot;&gt;&lt;/a&gt;一、如何获取数据（涉及开发流程）&lt;/h1&gt;&lt;h3 id=&quot;1、获取数据&quot;&gt;&lt;a href=&quot;#1、获取数据&quot; class=&quot;headerlink&quot; title=&quot;1、获取数据&quot;&gt;&lt;/a&gt;1、获取数据&lt;/h3&gt;&lt;p&gt;前端部分写了一个ajax，请求需要发送到服务器的接口上，服务器如果是不存在，直接报错，且无法后续测试，对于数据的处理、渲染无从谈起。接口如何运作起来，有数据返回，接口：后端开发&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="获取数据" scheme="http://yoursite.com/tags/%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    
      <category term="mock数据" scheme="http://yoursite.com/tags/mock%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：12-01技术方案：Ajax使用和原理</title>
    <link href="http://yoursite.com/2018/08/17/40-12.01%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%EF%BC%9AAjax%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/17/40-12.01技术方案：Ajax使用和原理/</id>
    <published>2018-08-16T17:30:48.000Z</published>
    <updated>2018-08-16T17:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。"><a href="#前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。" class="headerlink" title="前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。"></a>前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。</h5><h1 id="一、页面如何和后端交互"><a href="#一、页面如何和后端交互" class="headerlink" title="一、页面如何和后端交互"></a>一、页面如何和后端交互</h1><p>几种方法：</p><h3 id="1、form表单提交："><a href="#1、form表单提交：" class="headerlink" title="1、form表单提交："></a>1、form表单提交：</h3><p><a href="http://js.jirengu.com/raro/1/edit?html,output" target="_blank" rel="noopener">form表单提交实例</a><br>如我们把method改为<code>get</code>，用get方法拼装成一个带有用户名和密码的新的url地址，向服务器去发送请求，相应关键信息（用户名和密码）都会传递给服务器，进行处理；<code>post</code>则是直接将这些关键信息直接发给服务器（而不是通过url传递），后台监听到数据直接处理。<br><a id="more"></a><br>这里涉及了get和post的处理。请回看：<a href="https://user-gold-cdn.xitu.io/2018/8/14/16536f398d5cb668" target="_blank" rel="noopener">miya Wang：浅谈HTML表单（一）：表单提交原理（涉及post和get）</a></p><p>这种表单提交的交互方式，提交时页面发生跳转即出现新的页面，体验感不好；再者，页面提交为单向提交，后台给什么反馈？反应？均不知道什么结果。</p><h3 id="2、websocket"><a href="#2、websocket" class="headerlink" title="2、websocket"></a>2、websocket</h3><h3 id="3、ajax"><a href="#3、ajax" class="headerlink" title="3、ajax"></a>3、ajax</h3><h1 id="二、Ajax"><a href="#二、Ajax" class="headerlink" title="二、Ajax"></a>二、Ajax</h1><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p>Ajax，即AsynchronousJavaScript+XML，是一种依赖前端元素获取数据的方法，它是一种技术方案（不是一种新技术），Ajax主要通过<code>XMLHttpRequest</code>这个浏览器的内置对象向服务器发出<strong>HTTP请求</strong>，并接收<strong>HTTP响应</strong>，实现在<strong>页面不刷新情况下</strong>和服务端进行数据交互。</p><h3 id="2、交互形式"><a href="#2、交互形式" class="headerlink" title="2、交互形式"></a>2、交互形式</h3><p>Ajax一般用xml格式数据进行数据交互，现今ajax与服务器交互则是倾向于JSON格式规范数据格式，后端可以发任何格式的数据格式。</p><p>伴随着浏览器（chrome）升级（IE6-10），从原本依赖现有的CSS/HTML/Javascript去向服务器发送请求到现在最核心依赖浏览器提供的<code>XMLHttpRequest</code>对象（使用JS操作这个对象获取相应的响应，得到数据），即</p><p>控制台操作<code>XMLHttpRequest</code>、<code>fetch</code>，可显示它们均是浏览器的内置对象<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536f799d8cc8fb?w=442&amp;h=138&amp;f=jpeg&amp;s=23866" alt=""></p><h1 id="三、如何实现Ajax"><a href="#三、如何实现Ajax" class="headerlink" title="三、如何实现Ajax"></a>三、如何实现Ajax</h1><ul><li><code>XMLHttpRequest</code></li><li><code>fetch</code>（注意兼容性使用can i use）</li></ul><p>实现基本方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)</span><br><span class="line">        xhr.send()</span><br><span class="line">        var data = xhr.responseText</span><br><span class="line">        console.log(data)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1、通过get方式去请求"><a href="#1、通过get方式去请求" class="headerlink" title="1、通过get方式去请求"></a>1、通过get方式去请求</h3><p><strong>（1）通过js去写<code>XMLHttpRequest</code>来设置ajax</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()// XMLHttpRequest()是一个函数，通过new的方式去生成一个对象</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)// 做一些设置：发请求，发给谁？/有post或者get方式/同步异步；设置ajax：请求的方法，请求的服务器（或资源），异步方式（true)</span><br><span class="line">        xhr.send()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>控制台显示一个报错：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536f9edcae0cc3?w=600&amp;h=462&amp;f=jpeg&amp;s=132576" alt=""></p><p>报错显示无法与当前服务器交互，只能通过跨域请求。请求必须以http或者https开头的json格式文件，即所请求的服务器为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;https//1.json&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>解决方法：通过http-server服务器去发请求，获取数据</p></blockquote><p>打开该文件的终端，通过终端打开http-server<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536faa9e0b8bf8?w=600&amp;h=203&amp;f=jpeg&amp;s=50110" alt=""></p><p>然后输入带有刚才文件名的服务器地址：<a href="http://127.0.0.1:8081/1.html" target="_blank" rel="noopener">http://127.0.0.1:8081/1.html</a>  随即出现以下报错，<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536faea420b2ff?w=600&amp;h=391&amp;f=jpeg&amp;s=83170" alt=""></p><p>由于还没设置后端数据文件，点开链接出现找不到该网页（404）：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536fbc10edfc25?w=600&amp;h=308&amp;f=jpeg&amp;s=38319" alt=""></p><blockquote><p>接下来如何解决：通过模拟数据，创建一个1.json的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;wangxiaoqin&quot;</span><br><span class="line">&quot;age&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>然后网页打开服务器的json格式地址：<a href="http://127.0.0.1:8081/1.json" target="_blank" rel="noopener">http://127.0.0.1:8081/1.json</a><br>即出现<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536fc7780ea838?w=600&amp;h=219&amp;f=jpeg&amp;s=24718" alt=""></p><p>打开html的服务器网页控制台，看到json数据通过ajax获取到<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536fcb13a6b19c?w=600&amp;h=293&amp;f=jpeg&amp;s=50301" alt=""></p><blockquote><p>此时，我们拿到数据，并没有在js中操作如何拿到数据，是同步？异步？</p></blockquote><p><strong>第1种：同步的时候，如何拿到数据？</strong><br>注：此方法为同步，造成网页一直在计算中，不能前进 ，可能造成页面卡死状态<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">                xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,false) //设置同步</span><br><span class="line">                xhr.send()</span><br><span class="line"></span><br><span class="line">                var data = xhr.responseText</span><br><span class="line">                console.log(data)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>此时控制台console响应，数据到来，并通知到如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536fe9264602ef?w=600&amp;h=358&amp;f=jpeg&amp;s=68004" alt=""></p><p><strong>总结：</strong></p><ul><li>如果是同步的方式执行代码，代码一行行执行，到<code>xhr.send()</code>的时候，代码执行就暂停，漫长地等待着数据的到来，数据到来之后通过<code>xhr.responseText</code>拿到数据。</li><li>设置一个ajax：创建对象——参数设置——发送——数据到来——拿到数据</li></ul><p><strong>第2种：异步的方式获取数据</strong><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">                xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)//异步方式</span><br><span class="line">                xhr.send()</span><br><span class="line">        </span><br><span class="line">                xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">            var data = xhr.responseText</span><br><span class="line">            console.log(data)</span><br><span class="line">               &#125;)</span><br><span class="line">      </span><br><span class="line">       // 或者 </span><br><span class="line">       // xhr.onload = function()&#123;</span><br><span class="line">       //     var data = xhr.responseText</span><br><span class="line">      //      console.log(data)</span><br><span class="line">     //     &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>此时控制台console响应，数据到来，并通知到，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536ff407f1f192?w=600&amp;h=388&amp;f=jpeg&amp;s=68228" alt=""></p><p><strong>（2）通过状态码/状态值获取数据</strong><br><strong>A、添加status（状态码）方式获取【与onload事件相对应】</strong></p><blockquote><p>当我修改代码中json数据文件名：</p></blockquote><p>js中添加一个<code>console.log(xhr.status)</code> (状态码)<br>范例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">                xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true)//修改json文件名</span><br><span class="line">                xhr.send()</span><br><span class="line">                xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">                //添加状态码：</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">        var data = xhr.responseText</span><br><span class="line">        console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">       // 或者 </span><br><span class="line">       // xhr.onload = function()&#123;</span><br><span class="line">       //     var data = xhr.responseText</span><br><span class="line">      //      console.log(data)</span><br><span class="line">       // &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：将json文件名修改，造成了控制台报错。即明知道出错，但却一无所知<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653700ab670e3ca?w=600&amp;h=340&amp;f=jpeg&amp;s=70855" alt=""></p><blockquote><p>不修改json文件名</p></blockquote><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.json</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)//不修改json文件名</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">var data = xhr.responseText</span><br><span class="line">console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16537012c0830d9f?w=600&amp;h=384&amp;f=jpeg&amp;s=68591" alt=""></p><p><strong>总结：控制台出现状态码的响应，返回后端设置的相应数据</strong></p><ul><li>状态码<code>200</code>，表示这个文件存在；</li><li>状态码<code>404</code>，表示这个文件不存在；</li><li>状态码<code>503</code>，服务器表示收到请求，但内部自己报错了，未返回合理的数据;</li><li>状态码<code>304</code>，表示服务器是进行了缓存状态</li></ul><p><strong>当1.json时，</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.json</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">       //当状态码为200时，获取这个数据</span><br><span class="line">        if(xhr.status ===200)&#123;</span><br><span class="line">                  var data = xhr.responseText</span><br><span class="line">          console.log(data)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(&apos;error&apos;)</span><br><span class="line">        &#125;        </span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>结果如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16537029403b1529?w=600&amp;h=370&amp;f=jpeg&amp;s=62740" alt=""></p><p><strong>当1a.json时，</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1a.json</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">       //当状态码为200时，获取这个数据</span><br><span class="line">        if(xhr.status ===200)&#123;</span><br><span class="line">                    var data = xhr.responseText</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&apos;error&apos;)</span><br><span class="line">        &#125;        </span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653702d2b89d866?w=600&amp;h=594&amp;f=jpeg&amp;s=124987" alt=""><br>比较完整地在设置多个状态码条件下，ajax该如何向后台要取数据，完整代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//1.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123;</span><br><span class="line">                var data = xhr.responseText</span><br><span class="line">        console.log(data)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&apos;error&apos;)</span><br><span class="line">        &#125;        </span><br><span class="line">        &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">//数据文件：1.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;wangxiaoqin&quot;</span><br><span class="line">&quot;age&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>B、使用<code>readyState</code>（状态值）方式获取数据【与onreadystatechange事件相对应】</strong><br>js中添加另一种状态：<code>readyState</code></p><blockquote><p>绑定事件获取方法：<br>（1）on+一个事件<br>（2）addEventListener绑定一个函数事件</p></blockquote><p>范例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//1.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)</span><br><span class="line">        xhr.send()</span><br><span class="line"></span><br><span class="line">       // 使用readyStatechange方法</span><br><span class="line">        console.log(&apos;readyState:&apos;,xhr.readyState)</span><br><span class="line">        xhr.addEventListener(&apos;readystatechange&apos;,function()&#123;</span><br><span class="line">        console.log(&apos;readyState:&apos;,xhr.readyState)</span><br><span class="line">        &#125;)</span><br><span class="line">       </span><br><span class="line">        // 或者xhr.onreadystatechange = function()&#123;</span><br><span class="line">        //    console.log(&apos;readyState:&apos;,xhr.readyState)</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123;</span><br><span class="line">                var data = xhr.responseText</span><br><span class="line">            console.log(data)</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&apos;error&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">       // // 或者 </span><br><span class="line">       // xhr.onload = function()&#123;</span><br><span class="line">       //    var data = xhr.responseText</span><br><span class="line">      //  console.log(data)</span><br><span class="line">       // &#125;</span><br><span class="line"></span><br><span class="line">          xhr.onerror = function()&#123;</span><br><span class="line">          console.log(&apos;error&apos;)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>控制台如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653703e8fd9305c?w=600&amp;h=464&amp;f=jpeg&amp;s=72819" alt=""></p><p>对象中有一个状态值：<code>readyState</code>，这个状态与后端交互时，该状态会发生几次改变，每次改变都会触发该状态的change事件，每次监听这个事件，则输出readyState。即第一次请求状态改变为1，当触发change事件的时候，则开始变化：<strong>readyState2，3，4</strong></p><p><strong>总结：AJAX实际运行中的几种状态值：</strong><br>AJAX实际运行当中，对于访问XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是：<br>0 - (未初始化)还没有调用<code>send()</code>方法<br>1 - (载入)已调用<code>send()</code>方法，正在发送请求<br>2 - (载入完成)<code>send()</code>方法执行完成，<br>3 - (交互)正在解析响应内容<br>4 - (完成)响应内容解析完成，可以在客户端调用了<br>对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。</p><h3 id="2、readyState-VS-status-区别"><a href="#2、readyState-VS-status-区别" class="headerlink" title="2、readyState  VS status  区别"></a>2、readyState  VS status  区别</h3><p>通过对readyState  和 status的一系列操作，可以知道：</p><ul><li>readyState：表明客户端与客户的交互状态过程</li><li>status：体现的是服务器对请求的反馈，数据是否正常</li><li>load: 当状态为4（等同于<code>readyState===4</code>），4为一种完成状态（响应内容解析完成状态），触发调用load事件</li></ul><p>为此，我专门查了关于<code>eadyState</code>和<code>status</code>两种ajax状态，找到这么一篇资料较为好理解，可以看看,原文戳：<br><a href="http://lylgxy0704wht.blog.163.com/blog/static/57048039201151693116644/" target="_blank" rel="noopener">AJAX 状态值(readyState)与状态码(status)详解</a></p><p><strong>（1）AJAX状态值(readyState)与状态码(status)区别</strong><br>A、<strong>AJAX状态值是指，</strong><br>运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成）<br>B、<strong>AJAX状态码是指，</strong> 无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）<br>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; </span><br><span class="line">     putData(ajax.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（2） AJAX运行步骤与状态值说明</strong><br>在AJAX实际运行当中，对于访问<code>XMLHttpRequest（XHR）</code>时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是：<br>0 - (未初始化)还没有调用<code>send()</code>方法<br>1 - (载入)已调用<code>send()</code>方法，正在发送请求<br>2 - (载入完成)<code>send()</code>方法执行完成，<br>3 - (交互)正在解析响应内容<br>4 - (完成)响应内容解析完成，可以在客户端调用了<br>对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。</p><p><strong>（3）AJAX状态码说明</strong><br>1<strong>：请求收到，继续处理<br>2</strong>：操作成功收到，分析、接受<br>3<strong>：完成此请求必须进一步处理<br>4</strong>：请求包含一个错误语法或不能完成<br>5**：服务器执行一个完全有效请求失败<br>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本<br>200——交易成功<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求<br>300——请求的资源可在多处得到<br>301——删除请求数据<br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除<br>400——错误请求，如语法错误<br>401——请求授权失败<br>402——保留有效ChargeTo头响应<br>403——请求不允许<br>404——没有发现文件、查询或URl<br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求<br>500——服务器产生内部错误<br>501——服务器不支持请求的函数<br>502——服务器暂时不可用，有时是为了防止发生系统过载<br>503——服务器过载或暂停维修<br>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长<br>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p><p><em>（4） AJAX运行步骤示义图</em><br><img src="https://user-gold-cdn.xitu.io/2018/8/14/165370a604a56407?w=558&amp;h=712&amp;f=jpeg&amp;s=63326" alt=""></p><h3 id="3、继续探究一下所请求的后端数据文件"><a href="#3、继续探究一下所请求的后端数据文件" class="headerlink" title="3、继续探究一下所请求的后端数据文件"></a>3、继续探究一下所请求的后端数据文件</h3><p>在<code>xhr.open()</code>中要求请求服务器，即请求一个资源，而url则是定位一个资源,将所请求的服务器定位成请求一些资源，如<code>&#39;/hello.json&#39;</code>。假如模拟后端的数据，比如请求一个登陆数据：<code>&#39;/login&#39;</code>，请求时带有一些参数，如将用户所输入的数据拼装成类似url形式：<br><code>&#39;/login?username=wangxiaoqin&amp;password=12345&#39;</code>作为资源请求</p><h3 id="4、通过post形式去请求数据"><a href="#4、通过post形式去请求数据" class="headerlink" title="4、通过post形式去请求数据"></a>4、通过post形式去请求数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;POST&apos;,&apos;/1.json&apos;,true)</span><br><span class="line">        xhr.send(&apos;username=wangxiaoqin&amp;password=12345&apos;)//直接发送数据</span><br><span class="line">        xhr.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line">        console.log(xhr.status)</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123;</span><br><span class="line">                var data = xhr.responseText</span><br><span class="line">            console.log(data)</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&apos;error&apos;)</span><br><span class="line">        &#125;        </span><br><span class="line">        &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>&#39;username=wangxiaoqin&amp;password=12345&#39;</code> 这段拼接的过程可以通过写一个函数展现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//传递一个参数：</span><br><span class="line">makeUrl(&#123;</span><br><span class="line">  username:&apos;wangxiaoqin&apos;,</span><br><span class="line">  password:12345</span><br><span class="line">&#125;)</span><br><span class="line">//拼接一个url,通过遍历这个对象，进行拼接</span><br><span class="line">function makeUrl(obj)&#123;</span><br><span class="line">   var arr = []</span><br><span class="line">   for(var key in obj)&#123;</span><br><span class="line">       arr.push(key + &apos;=&apos; + obj[key])</span><br><span class="line">     &#125;</span><br><span class="line">     return  arr.join(&apos;&amp;&apos;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>那么，<code>xhr.send()</code>便直接可以发送这个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(makeUrl(&#123;</span><br><span class="line">  username:&apos;wangxiaoqin&apos;,</span><br><span class="line">  password:12345</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><h1 id="四、ajax几种写法"><a href="#四、ajax几种写法" class="headerlink" title="四、ajax几种写法"></a>四、ajax几种写法</h1><p>1、<strong>第1种：</strong></p><blockquote><p>关键词：</p></blockquote><blockquote><p><code>readyState === 4</code><br><code>onreadystatechange</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;http://api.jirengu.com/weather.php&apos;, true)</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readyState === 4) &#123;</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">            //成功了</span><br><span class="line">            console.log(xhr.responseText)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;服务器异常&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.onerror = function()&#123;</span><br><span class="line">    console.log(&apos;服务器异常&apos;)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>2、<strong>第2种：</strong></p><blockquote><p>关键词：<br><code>onload</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;http://api.jirengu.com/weather.php&apos;, true)</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">        //成功了</span><br><span class="line">        console.log(xhr.responseText)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;服务器异常&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.onerror = function()&#123;</span><br><span class="line">    console.log(&apos;服务器异常&apos;)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></p></blockquote><p>3、<strong>第3种：封装1个ajax</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//封装，调用ajax对象，传递一些固定参数</span><br><span class="line">function ajax(opts)&#123;</span><br><span class="line">    var url = opts.url</span><br><span class="line">    var type = opts.type || &apos;GET&apos;// ||或：前者undefined，默认后者</span><br><span class="line">    var dataType = opts.dataType || &apos;json&apos;</span><br><span class="line">    var onsuccess = opts.onsuccess || function()&#123;&#125;</span><br><span class="line">    var onerror = opts.onerror || function()&#123;&#125;</span><br><span class="line">    var data = opts.data || &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //将上面用户请求的数据对象进行处理，拼接一个url</span><br><span class="line">    var dataStr = []</span><br><span class="line">    for(var key in data)&#123;</span><br><span class="line">        dataStr.push(key + &apos;=&apos; + data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr = dataStr.join(&apos;&amp;&apos;)</span><br><span class="line">    </span><br><span class="line">    if(type === &apos;GET&apos;)&#123;</span><br><span class="line">        url += &apos;?&apos; + dataStr</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   //做一个ajax</span><br><span class="line">    var xhr = new XMLHttpRequest()</span><br><span class="line">    xhr.open(type, url, true)</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">            //成功了</span><br><span class="line">            if(dataType === &apos;json&apos;)&#123;</span><br><span class="line">                onsuccess( JSON.parse(xhr.responseText))//返回的数据</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                onsuccess( xhr.responseText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onerror()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onerror = onerror</span><br><span class="line">    if(type === &apos;POST&apos;)&#123;</span><br><span class="line">        xhr.send(dataStr)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ajax设置一些参数对象</span><br><span class="line">ajax(&#123;</span><br><span class="line">    url: &apos;http://api.jirengu.com/weather.php&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        city: &apos;北京&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    onsuccess: function(ret)&#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;,</span><br><span class="line">    onerror: function()&#123;</span><br><span class="line">        console.log(&apos;服务器异常&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。&quot;&gt;&lt;a href=&quot;#前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。&quot; class=&quot;headerlink&quot; title=&quot;前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。&quot;&gt;&lt;/a&gt;前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。&lt;/h5&gt;&lt;h1 id=&quot;一、页面如何和后端交互&quot;&gt;&lt;a href=&quot;#一、页面如何和后端交互&quot; class=&quot;headerlink&quot; title=&quot;一、页面如何和后端交互&quot;&gt;&lt;/a&gt;一、页面如何和后端交互&lt;/h1&gt;&lt;p&gt;几种方法：&lt;/p&gt;
&lt;h3 id=&quot;1、form表单提交：&quot;&gt;&lt;a href=&quot;#1、form表单提交：&quot; class=&quot;headerlink&quot; title=&quot;1、form表单提交：&quot;&gt;&lt;/a&gt;1、form表单提交：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://js.jirengu.com/raro/1/edit?html,output&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;form表单提交实例&lt;/a&gt;&lt;br&gt;如我们把method改为&lt;code&gt;get&lt;/code&gt;，用get方法拼装成一个带有用户名和密码的新的url地址，向服务器去发送请求，相应关键信息（用户名和密码）都会传递给服务器，进行处理；&lt;code&gt;post&lt;/code&gt;则是直接将这些关键信息直接发给服务器（而不是通过url传递），后台监听到数据直接处理。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
      <category term="前后端交互" scheme="http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    
      <category term="状态码status" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81status/"/>
    
      <category term="封装Ajax" scheme="http://yoursite.com/tags/%E5%B0%81%E8%A3%85Ajax/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：11浏览器基础：BOM对象和浏览器储存</title>
    <link href="http://yoursite.com/2018/08/17/39-11%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%EF%BC%9ABOM%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%82%A8%E5%AD%98/"/>
    <id>http://yoursite.com/2018/08/17/39-11浏览器基础：BOM对象和浏览器储存/</id>
    <published>2018-08-16T17:30:39.000Z</published>
    <updated>2018-08-17T18:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（一）BOM对象"><a href="#（一）BOM对象" class="headerlink" title="（一）BOM对象"></a>（一）BOM对象</h1><h2 id="一、BOM是什么"><a href="#一、BOM是什么" class="headerlink" title="一、BOM是什么"></a>一、BOM是什么</h2><p>dom，指的是页面上的元素，而bom是针对浏览器的一种对象模型，用于描述这种对象与对象之间层次关系的模型。浏览器本身的特性（如当前位置、浏览器宽高、以及系统环境等），而这些与当前的web页面并无关系，而是与当前的window（整个浏览器的窗口，不只是页面，不要误解）相关。<br><a id="more"></a></p><h2 id="二、BOM包含什么？"><a href="#二、BOM包含什么？" class="headerlink" title="二、BOM包含什么？"></a>二、BOM包含什么？</h2><p>BOM的核心是window对象。表示浏览器的一个实例。在浏览器中，即是javascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象，这就意味着在网页中定义的任意变量、函数、对象都是以window作为Global对象。</p><p>注：所有在<strong>全局作用域中声明的变量、函数、对象</strong>都会作为<strong>window的属性和方法，如全局变量都是window对象的一个属性</strong>如在<strong>全局作用域下</strong>，在控制台下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">window.a </span><br><span class="line">--&gt;1</span><br><span class="line">/* 或 */</span><br><span class="line">window.document</span><br><span class="line">--&gt;#document</span><br><span class="line">/* 或声明一个函数如 */</span><br><span class="line">function printName()&#123;</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line">window.printName</span><br><span class="line">--&gt;ƒ printName()&#123;</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、常用的window对象"><a href="#三、常用的window对象" class="headerlink" title="三、常用的window对象"></a>三、常用的window对象</h2><h4 id="1、window-innerHeight和-window-innerWidth"><a href="#1、window-innerHeight和-window-innerWidth" class="headerlink" title="1、window.innerHeight和 window.innerWidth"></a>1、<code>window.innerHeight</code>和 <code>window.innerWidth</code></h4><p>返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。<br>即当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小</p><p>（1）<code>window.innerHeight</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//我随意调了浏览器的大小后的高度</span><br><span class="line">window.innerHeight</span><br><span class="line">--&gt;568</span><br></pre></td></tr></table></figure></p><p>（2）<code>window.innerWidth</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.innerWidth</span><br><span class="line">--&gt;320</span><br></pre></td></tr></table></figure></p><h4 id="2、window-scrollTo、window-scrollBy、window-scroll"><a href="#2、window-scrollTo、window-scrollBy、window-scroll" class="headerlink" title="2、window.scrollTo、window.scrollBy、window.scroll"></a>2、<code>window.scrollTo</code>、<code>window.scrollBy</code>、<code>window.scroll</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.scrollTo(0, 0)   //页面回到顶部</span><br><span class="line">window.scrollTo(0, 300) // 滚动条移动到300px处</span><br></pre></td></tr></table></figure><p>两个参数分别是水平、垂直方向偏移</p><p><code>scrollBy</code>可以相对当前位置移动滚动条，而不是移动到绝对位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollBy(0, 100); // 滚动条下移100px</span><br></pre></td></tr></table></figure></p><p><strong>移动端滚动：</strong><br><code>window.scrollTo(0,1);</code><br>即手机浏览器上的搜索栏则会本隐藏掉</p><h4 id="3、navigator"><a href="#3、navigator" class="headerlink" title="3、navigator"></a>3、<code>navigator</code></h4><p><code>navigator</code>是一个存储浏览器相关信息的对象。作为属性，它的值也是一个对象。打开控制台所示，有部分重要参数了解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//表示的是当前用户代理是什么，即使用什么设备用浏览器</span><br><span class="line">userAgent:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&quot;</span><br><span class="line">navigator.userAgent</span><br><span class="line">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&quot;</span><br></pre></td></tr></table></figure></p><h4 id="4、window-getComputedStyle"><a href="#4、window-getComputedStyle" class="headerlink" title="4、window.getComputedStyle"></a>4、<code>window.getComputedStyle</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;);</span><br></pre></td></tr></table></figure><p>获取当前元素所有最终使用的样式的属性</p><h4 id="5、scrollX和scrollY"><a href="#5、scrollX和scrollY" class="headerlink" title="5、scrollX和scrollY"></a>5、<code>scrollX</code>和<code>scrollY</code></h4><p>这两个值随着滚动位置变化而变化</p><ul><li>scrollX：滚动条横向偏移</li><li>scrollY：滚动条纵向偏移</li></ul><h4 id="6、window-frames"><a href="#6、window-frames" class="headerlink" title="6、window.frames"></a>6、<code>window.frames</code></h4><p><code>window.frames</code>返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。<br>如何在当前页面下定位到a.html里面的dom元素？如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531c22c1ffc1d8?w=600&amp;h=172&amp;f=jpeg&amp;s=34983" alt=""><br>此时可以使用<code>window.frames</code>去获取所有<code>iframe</code>，定位到含有a.html的这个对象，再从里面获取我们所需要的dom元素（注意同源策略问题出现）</p><p>需要注意的是，<code>window.frames</code>的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用<code>window.frames[0].document</code>。</p><h4 id="7、screen"><a href="#7、screen" class="headerlink" title="7、screen"></a>7、<code>screen</code></h4><p>并不是浏览器的屏幕，指的是当前设备的屏幕</p><h4 id="8、URL的编码-解码方法"><a href="#8、URL的编码-解码方法" class="headerlink" title="8、URL的编码/解码方法"></a>8、URL的编码/解码方法</h4><p>可以先看看若愚老师写的这篇文章，对于编码和乱码会有一个初步的认识：<a href="https://zhuanlan.zhihu.com/p/24465635" target="_blank" rel="noopener">若愚：聊一聊编码与乱码</a></p><p>JavaScript提供四个URL的编码/解码方法。</p><ul><li><code>decodeURI()</code></li><li><code>decodeURIComponent()</code></li><li><code>encodeURI()</code></li><li><code>encodeURIComponent()</code></li></ul><p>如当我们在某网页的控制台里输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.href</span><br><span class="line">--&gt;&quot;http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/bom.html&quot;</span><br></pre></td></tr></table></figure></p><p>url中包含的中文字符，自动转码，即<code>encodeURI()</code>转换成unidode码<br><strong>注：</strong> encodeURI方法<strong>不会</strong>对下列字符编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ASCII字母</span><br><span class="line">2. 数字</span><br><span class="line">3. ~!@#$&amp;*()=:/,;?+&apos;</span><br></pre></td></tr></table></figure></p><p><code>encodeURIComponent</code>方法不会对下列字符编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ASCII字母</span><br><span class="line">2. 数字</span><br><span class="line">3. ~!*()&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>如何用？</p></blockquote><p>实际例子来说，<code>encodeURIComponent</code>会把 <code>http://</code> 编码成 <code>http%3A%2F%2F</code>而encodeURI却不会。<br>如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURI(&quot;http://blog.jirengu.com/?cat=11&amp;a=饥人谷&quot;); //&quot;http://blog.jirengu.com/?cat=11&amp;a=%25E9%25A5%25A5%25E4%25BA%25BA%25E8%25B0%25B7&quot;;</span><br></pre></td></tr></table></figure></p><p>其中，汉字被编码。但是如果你用了<code>encodeURIComponent</code>，那么结果变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;http%3A%2F%2Fblog.jirengu.com%2F%3Fcat%3D11%26a%3D%25E9%25A5%25A5%25E4%25BA%25BA%25E8%25B0%25B7&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>escape</code>,<code>encodeURI</code>,<code>encodeURIComponent</code>有什么区别? </p></blockquote><p>了解一下：个人倾向于这个回答：<a href="https://www.zhihu.com/question/21861899/answer/91279362" target="_blank" rel="noopener">escape,encodeURI,encodeURIComponent有什么区别?</a></p><h4 id="9、alert-，prompt-，confirm"><a href="#9、alert-，prompt-，confirm" class="headerlink" title="9、alert()，prompt()，confirm()"></a>9、<code>alert()</code>，<code>prompt()</code>，<code>confirm()</code></h4><p>三者都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。</p><ul><li><code>alert()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(1)</span><br></pre></td></tr></table></figure></li></ul><p>如图：<img src="https://user-gold-cdn.xitu.io/2018/8/14/16536a488584d8cc?w=600&amp;h=242&amp;f=jpeg&amp;s=37822" alt=""></p><ul><li><code>prompt()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = prompt(&apos;enter something&apos;) //跳出弹出框</span><br><span class="line">//undefined</span><br><span class="line">a</span><br><span class="line">//&quot;100&quot;</span><br></pre></td></tr></table></figure></li></ul><p>如图：<img src="https://user-gold-cdn.xitu.io/2018/8/14/16536a530c053192?w=600&amp;h=253&amp;f=jpeg&amp;s=41715" alt=""></p><ul><li><code>confirm()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isOk = confirm(&apos;r u ok?&apos;)//弹出确定/取消键</span><br><span class="line">// undefined</span><br><span class="line">isOk</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></li></ul><p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，则返回true；如果用户点击“取消”，则返回false。<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536a593d784476?w=600&amp;h=247&amp;f=jpeg&amp;s=46343" alt=""></p><h1 id="（二）浏览器存储"><a href="#（二）浏览器存储" class="headerlink" title="（二）浏览器存储"></a>（二）浏览器存储</h1><p><code>cookie</code> &amp; <code>session</code> &amp; <code>localStorage</code></p><h2 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h2><h4 id="1、cookie-是什么："><a href="#1、cookie-是什么：" class="headerlink" title="1、cookie 是什么："></a>1、cookie 是什么：</h4><p>储存在用户本地终端上的数据，也叫浏览器缓存</p><h4 id="2、如何找到cookie："><a href="#2、如何找到cookie：" class="headerlink" title="2、如何找到cookie："></a>2、如何找到cookie：</h4><p>打开页面控制台——Application——Storeage——localstorge、cookie（对象）<br>cookie用于把一些记录信息存储在当前的页面下。存储在cookie当前域名下的一小段数据，存储空间很小，不超过4kb；对应参数Name、Value、Domain、Path、Expires（生效时间）、Size等，如图：</p><p><strong>设置cookie时的参数：</strong></p><ul><li><code>path</code>：表示 cookie影响到的路径，匹配该路径才发送这个cookie。expires 和 maxAge：告诉浏览器cookie时候过期，maxAge是cookie多久后过期的相对时间。不设置这两个选项时会产生<code>sessioncookie</code>，<code>sessioncookie</code>是<code>transient</code>的，当用户关闭浏览器时，就被清除。一般用来保存session 的 <code>session_id</code>。</li><li><code>secure</code>：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效</li><li><code>httpOnly</code>：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到cookie。</li></ul><h4 id="3、cookie-怎么产生："><a href="#3、cookie-怎么产生：" class="headerlink" title="3、cookie 怎么产生："></a>3、cookie 怎么产生：</h4><p>Cookie是由Web服务器保存在用户浏览器 (客户端 )上的小文本文件,它可 以包含有关用户的信息。由网络服务器发送出来存储在网络浏览器上，下次它回到该网络服务器时，还可以在该浏览器读此信息。</p><p><strong>注：</strong> 每次向服务端发送请求，Cookies都会被带到HTTP中，即网络请求 <code>Request headers</code>中都会带上cookie。如果cookie太多太大，造成负载太大，对传输效率会有影响。</p><h4 id="4、常用做法："><a href="#4、常用做法：" class="headerlink" title="4、常用做法："></a>4、常用做法：</h4><p>cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用HTTP协议规定的<code>set-cookie</code>来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的<code>Responseheaders</code>试试找一找<code>set-cookie</code>吧）。比如百度搜索，输入网址——向服务器发请求——服务器给出响应，打开控制台——Network——Headers，看见响应头、尾。响应头对应有<code>set-cookie</code>该请求，浏览器则把该字段种进cookie里面。</p><p><strong>查看cookie：</strong> cookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用<code>「document.cookie」</code>查看你当前正在浏览的网站的cookie。</p><h4 id="5、Cookies可以加失效日期，失效日期过了，就会自动删除Cookies，一般来说可以用Cookies记录用户名，不能记录密码，否则不安全。"><a href="#5、Cookies可以加失效日期，失效日期过了，就会自动删除Cookies，一般来说可以用Cookies记录用户名，不能记录密码，否则不安全。" class="headerlink" title="5、Cookies可以加失效日期，失效日期过了，就会自动删除Cookies，一般来说可以用Cookies记录用户名，不能记录密码，否则不安全。"></a>5、Cookies可以加失效日期，失效日期过了，就会自动删除Cookies，一般来说可以用Cookies记录用户名，不能记录密码，否则不安全。</h4><h4 id="6、可以在浏览器中存储东西，和LocalStorage作用类似；可以控制cookie的生命期，Cookie数量和长度受限制"><a href="#6、可以在浏览器中存储东西，和LocalStorage作用类似；可以控制cookie的生命期，Cookie数量和长度受限制" class="headerlink" title="6、可以在浏览器中存储东西，和LocalStorage作用类似；可以控制cookie的生命期，Cookie数量和长度受限制"></a>6、可以在浏览器中存储东西，和<code>LocalStorage</code>作用类似；可以控制cookie的生命期，Cookie数量和长度受限制</h4><h2 id="二、localstorge"><a href="#二、localstorge" class="headerlink" title="二、localstorge"></a>二、localstorge</h2><h4 id="1、localStorage-HTML5本地存储web-storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用-js手动清除。"><a href="#1、localStorage-HTML5本地存储web-storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用-js手动清除。" class="headerlink" title="1、localStorage HTML5本地存储web　storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。"></a>1、<code>localStorage HTML5</code>本地存储web　storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。</h4><h4 id="2、不参与网络传输。"><a href="#2、不参与网络传输。" class="headerlink" title="2、不参与网络传输。"></a>2、不参与网络传输。</h4><h4 id="3、一般用于性能优化，可以保存图片、js、css、html-模板、大量数据。"><a href="#3、一般用于性能优化，可以保存图片、js、css、html-模板、大量数据。" class="headerlink" title="3、一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。"></a>3、一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。</h4><p><code>localstorge</code>：对应参数key、value，存储量大</p><ul><li>如何存储数据，如控制台测试效果：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536aa0a6296a84?w=600&amp;h=445&amp;f=jpeg&amp;s=54320" alt=""></li><li>假设讲一个数组存储进<code>localstorge[&#39;name&#39;]</code>,它会自动将数组转换成字符串，出现的name的数据则为<code>[object object]</code>,即数据已经丢失,如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536aa4b2ef254a?w=600&amp;h=406&amp;f=jpeg&amp;s=59923" alt=""></li><li>想要把一个对象存储进<code>localstorge</code>，将对象转换成字符串（二者可用json互转）存储进去，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/14/16536ab70a4dea2e?w=600&amp;h=470&amp;f=jpeg&amp;s=67704" alt=""></li></ul><h4 id="4、SessionStorage-VS-LocalStorage"><a href="#4、SessionStorage-VS-LocalStorage" class="headerlink" title="4、SessionStorage VS LocalStorage"></a>4、<code>SessionStorage</code> VS <code>LocalStorage</code></h4><p><code>SessionStorage</code>和<code>LocalStorage</code>接口类似，但是<code>SessionStorage</code>仅在当前会话下有效，关闭页面或浏览器后被清除。</p><h2 id="三、session"><a href="#三、session" class="headerlink" title="三、session"></a>三、session</h2><h4 id="1、Session是一种特殊的Cookies，用于识别用户。"><a href="#1、Session是一种特殊的Cookies，用于识别用户。" class="headerlink" title="1、Session是一种特殊的Cookies，用于识别用户。"></a>1、Session是一种特殊的Cookies，用于识别用户。</h4><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在cookie中了，而且如果cookie中数据字段太多会影响传输效率。为了解决这些问题，就产生了session，session中的数据是保留在服务器端的。</p><p>当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。</p><p>用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session，用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。</p><h4 id="2、session-的运作通过一个session-id来进行。"><a href="#2、session-的运作通过一个session-id来进行。" class="headerlink" title="2、session 的运作通过一个session_id来进行。"></a>2、session 的运作通过一个<code>session_id</code>来进行。</h4><p><code>session_id</code>通常是存放在客户端的cookie中，比如在express中，默认<code>是connect.sid</code>这个字段，当请求到来时，服务端检查cookie中保存的<code>session_id</code>并通过这个<code>session_id</code>与服务器端的<code>sessiondata</code>关联起来，进行数据的保存和修改。</p><p>即当你浏览一个网页时，服务端随机产生一个1024比特长的字符串，然后存在你 cookie 中的<code>connect.sid</code>字段中。当你下次访问时，cookie会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。</p><ul><li>创建session后，会把关联的<code>session_id</code>通过<code>setCookie</code>添加到http响应头部中。</li><li>浏览器在加载页面时发现响应头部有<code>set-cookie</code>字段，就把这个cookie 种到浏览器指定域名下。</li><li>当下次刷新页面时，发送的请求会带上这条cookie，服务端在接收到后根据这个session_id来识别用户。</li><li>cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;（一）BOM对象&quot;&gt;&lt;a href=&quot;#（一）BOM对象&quot; class=&quot;headerlink&quot; title=&quot;（一）BOM对象&quot;&gt;&lt;/a&gt;（一）BOM对象&lt;/h1&gt;&lt;h2 id=&quot;一、BOM是什么&quot;&gt;&lt;a href=&quot;#一、BOM是什么&quot; class=&quot;headerlink&quot; title=&quot;一、BOM是什么&quot;&gt;&lt;/a&gt;一、BOM是什么&lt;/h2&gt;&lt;p&gt;dom，指的是页面上的元素，而bom是针对浏览器的一种对象模型，用于描述这种对象与对象之间层次关系的模型。浏览器本身的特性（如当前位置、浏览器宽高、以及系统环境等），而这些与当前的web页面并无关系，而是与当前的window（整个浏览器的窗口，不只是页面，不要误解）相关。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="BOM对象" scheme="http://yoursite.com/tags/BOM%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="浏览器储存" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%82%A8%E5%AD%98/"/>
    
      <category term="cookie &amp; session &amp; localStorage" scheme="http://yoursite.com/tags/cookie-session-localStorage/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：10-03常见和自定义事件使用</title>
    <link href="http://yoursite.com/2018/08/17/38-10.03%E5%B8%B8%E8%A7%81%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/17/38-10.03常见和自定义事件使用/</id>
    <published>2018-08-16T17:30:29.000Z</published>
    <updated>2018-08-17T18:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、click—点击事件"><a href="#一、click—点击事件" class="headerlink" title="一、click—点击事件"></a>一、<code>click</code>—点击事件</h1><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn&apos;).addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">   console.log(&apos;click&apos;)</span><br><span class="line">   console.log(this)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="二、dblclick—双击左键，监听左键"><a href="#二、dblclick—双击左键，监听左键" class="headerlink" title="二、dblclick—双击左键，监听左键"></a>二、<code>dblclick</code>—双击左键，监听左键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn1&apos;).addEventListener(&apos;dblclick&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;dblclick&apos;)</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、鼠标放上去触发事件"><a href="#三、鼠标放上去触发事件" class="headerlink" title="三、鼠标放上去触发事件"></a>三、鼠标放上去触发事件</h1><h3 id="1、mouse1"><a href="#1、mouse1" class="headerlink" title="1、mouse1"></a>1、mouse1</h3><ul><li><code>mouseover</code>—当鼠标放上去时，则触发事件</li><li><code>mouseoutr</code>—当鼠标跨到另一领域时，则与<code>mouseover</code>同时触发事件<br>代码如下 ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //当鼠标放上去时，则触发事件</span><br><span class="line">  $(&apos;.ct&apos;).addEventListener(&apos;mouseover&apos;, function()&#123;</span><br><span class="line">      console.log(&apos;mouseover&apos;)</span><br><span class="line">      console.log(this)</span><br><span class="line">      //this.style.borderColor = &apos;blue&apos;</span><br><span class="line">      this.classList.add(&apos;hover&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//鼠标移出的时（不管是移出孩子还是父亲），则会触发事件，且每次只触发一次：</span><br><span class="line">  $(&apos;.ct&apos;).addEventListener(&apos;mouseout&apos;, function()&#123;</span><br><span class="line">     console.log(&apos;mouseout...&apos;)</span><br><span class="line">     //this.style.borderColor = &apos;red&apos;</span><br><span class="line">     this.classList.remove(&apos;hover&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>移动的情况一：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165316701dfa1fd2?w=599&amp;h=251&amp;f=gif&amp;s=7878177" alt=""><br><strong>从外—老子内框——儿子框—退回老子框——外</strong>，控制台打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//外—老子内框</span><br><span class="line">mouseover</span><br><span class="line"> &lt;div class=&quot;ct hover&quot; style=&quot;font-size: 20px&quot;&gt;…&lt;/div&gt;</span><br><span class="line">//老子内框——儿子框</span><br><span class="line">mouseout...</span><br><span class="line">mouseover</span><br><span class="line">&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;</span><br><span class="line">//儿子框—退回老子框</span><br><span class="line">mouseout...</span><br><span class="line">mouseover</span><br><span class="line">&lt;div class=&quot;ct hover&quot; style=&quot;font-size: 20px&quot;&gt;…&lt;/div&gt;</span><br><span class="line">//退回老子框——外</span><br><span class="line">mouseout...</span><br></pre></td></tr></table></figure></p><p><strong>移动的情况二：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653167f4c84f9e1?w=599&amp;h=292&amp;f=gif&amp;s=6769807" alt=""><br><strong>从外—老子内框—儿子框—外</strong>，控制台打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//外—老子内框</span><br><span class="line">mouseover</span><br><span class="line">&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;</span><br><span class="line">//老子内框—儿子框</span><br><span class="line">mouseout...</span><br><span class="line">mouseover</span><br><span class="line">&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;</span><br><span class="line">//儿子框—外</span><br><span class="line">mouseout...</span><br></pre></td></tr></table></figure></p><p>在控制台测试之后，老子内框—儿子框，每次穿过子元素都会触发该事件，就会相对应地出现<code>mouseout...</code>和<code>mouseover</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mouseout...</span><br><span class="line">mouseover</span><br><span class="line">&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2、mouse2"><a href="#2、mouse2" class="headerlink" title="2、mouse2"></a>2、mouse2</h3><ul><li><code>mouseenter</code>—只要在该事件的范围内，则只触发一次</li><li><code>mouseleave</code>—只要离开这个事件，则触发该事件<br>代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//鼠标进去</span><br><span class="line">  $(&apos;.ct1&apos;).addEventListener(&apos;mouseenter&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;mouseenter...&apos;)</span><br><span class="line">    //this.style.borderColor = &apos;blue&apos;</span><br><span class="line">    this.classList.add(&apos;hover&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">//鼠标离开 </span><br><span class="line">  $(&apos;.ct1&apos;).addEventListener(&apos;mouseleave&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;mouseleave...&apos;)</span><br><span class="line">    //this.style.borderColor = &apos;blue&apos;</span><br><span class="line">    this.classList.remove(&apos;hover&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165316a2c4987dcb?w=600&amp;h=265&amp;f=gif&amp;s=79346" alt=""></p><h1 id="四、input输入表单"><a href="#四、input输入表单" class="headerlink" title="四、input输入表单"></a>四、input输入表单</h1><h3 id="1、焦点问题"><a href="#1、焦点问题" class="headerlink" title="1、焦点问题"></a>1、焦点问题</h3><ul><li><code>focus</code>—获取焦点状态</li><li><code>blur</code> —失去焦点状态<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> /*focus，获取焦点的一个状态：点击之后出现focus，focus为被激活状态，用户可以去输入内容*/</span><br><span class="line"> </span><br><span class="line">$(&apos;#input-name&apos;).addEventListener(&apos;focus&apos;, function()&#123;</span><br><span class="line">     console.log(&apos;focus...&apos;)</span><br><span class="line">     console.log(this.value)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line"> /*blur，失去焦点状态：当鼠标移出输入框再点击页面任意处，则输入框是无法输入任何东西*/   </span><br><span class="line">$(&apos;#input-name&apos;).addEventListener(&apos;blur&apos;, function()&#123;</span><br><span class="line">     console.log(&apos;blur...&apos;)</span><br><span class="line">     console.log(this.value)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ul><p>图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165316b07d92756c?w=599&amp;h=239&amp;f=gif&amp;s=3751678" alt=""><br><strong>用于校验：</strong> 当用户输入完对应内容后，当tab切换了下一个输入框（或做了其他的事情），就会失去焦点，也就<code>blur</code></p><h3 id="2、keyup-输入后按下确定键，再松开"><a href="#2、keyup-输入后按下确定键，再松开" class="headerlink" title="2、keyup 输入后按下确定键，再松开"></a>2、keyup 输入后按下确定键，再松开</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//keyup，输入内容按下，再松开</span><br><span class="line">$(&apos;#input-name&apos;).addEventListener(&apos;keyup&apos;, function(e)&#123;</span><br><span class="line">     console.log(&apos;keyup...&apos;)</span><br><span class="line">     console.log(this.value)</span><br><span class="line">     console.log(e)</span><br><span class="line">     this.value = this.value.toUpperCase()</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p><p>图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165316e16105f1fd?w=600&amp;h=223&amp;f=gif&amp;s=111973" alt=""></p><h3 id="3、change-当输入框里的值改变，并失去焦点，则会触发change事件"><a href="#3、change-当输入框里的值改变，并失去焦点，则会触发change事件" class="headerlink" title="3、change 当输入框里的值改变，并失去焦点，则会触发change事件"></a>3、change 当输入框里的值改变，并失去焦点，则会触发change事件</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#input-name&apos;).addEventListener(&apos;change&apos;, function(e)&#123;</span><br><span class="line">    console.log(&apos;change...&apos;)</span><br><span class="line">    console.log(this.value)</span><br><span class="line">    console.log(e)</span><br><span class="line">    this.value = this.value.toUpperCase()</span><br><span class="line"> //当监听到change事件时，则执行这一行，this.value则能获取当前表单设置的值，toUpperCase则变为大写，重新设置这个值</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/16531a9e555bd5c9?w=600&amp;h=248&amp;f=gif&amp;s=103930" alt=""></p><h1 id="五、submit-—表单按钮提交触发submit事件"><a href="#五、submit-—表单按钮提交触发submit事件" class="headerlink" title="五、submit —表单按钮提交触发submit事件"></a>五、<code>submit</code> —表单按钮提交触发submit事件</h1><p>即form表单事件。form表单，有一个按钮需要提交，此时用JS触发<code>submit</code>即直接使用<code>form.submit</code>，此时则会触发<code>submit</code>事件，此时form则会监听到<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#form&apos;).addEventListener(&apos;submit&apos;, function(e)&#123;</span><br><span class="line">   e.preventDefault();  //先阻止一些默认事件（即先不要提交）</span><br><span class="line">   if(/^\w&#123;6,12&#125;$/.test($(&apos;#username&apos;).value))&#123;  //再做一些检测</span><br><span class="line">     $(&apos;#form&apos;).submit();</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     $(&apos;#form .msg&apos;).innerText = &apos;出错了&apos;</span><br><span class="line">     $(&apos;#form .msg&apos;).style.display = &apos;block&apos;</span><br><span class="line">     console.log(&apos; no submit...&apos;);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><h1 id="六、window事件"><a href="#六、window事件" class="headerlink" title="六、window事件"></a>六、window事件</h1><h3 id="1、scroll-—滚动事件。当你滚动的时，会触发scroll事件（会触发多次）"><a href="#1、scroll-—滚动事件。当你滚动的时，会触发scroll事件（会触发多次）" class="headerlink" title="1、scroll —滚动事件。当你滚动的时，会触发scroll事件（会触发多次）"></a>1、<code>scroll</code> —滚动事件。当你滚动的时，会触发<code>scroll</code>事件（会触发多次）</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;scroll&apos;, function(e)&#123;</span><br><span class="line">   console.log(&apos;scroll..&apos;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="2、resize-—窗口变化事件。当窗口发生变化时，会触发resize事件（会触发多次）"><a href="#2、resize-—窗口变化事件。当窗口发生变化时，会触发resize事件（会触发多次）" class="headerlink" title="2、resize —窗口变化事件。当窗口发生变化时，会触发resize事件（会触发多次）"></a>2、<code>resize</code> —窗口变化事件。当窗口发生变化时，会触发<code>resize</code>事件（会触发多次）</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;resize&apos;, function(e)&#123;</span><br><span class="line">    console.log(&apos;resize..&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653172f01e69e3b?w=600&amp;h=258&amp;f=gif&amp;s=157897" alt=""></p><h1 id="七、load-onload事件"><a href="#七、load-onload事件" class="headerlink" title="七、load/onload事件"></a>七、<code>load</code>/<code>onload</code>事件</h1><h3 id="1、在window上"><a href="#1、在window上" class="headerlink" title="1、在window上"></a>1、在window上</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当页面所有资源加载完成，则触发(涉及到所有资源，所以触发时机较晚）</span><br><span class="line"> window.onload = function()&#123;</span><br><span class="line">   console.log(&apos;window loaded&apos;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、在document上"><a href="#2、在document上" class="headerlink" title="2、在document上"></a>2、在document上</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //DOM 结构解析完成（并不是页面上资源加载完成，而是dom结构渲染完成）</span><br><span class="line">document.addEventListener(&apos;DOMContentLoaded&apos;, function()&#123;</span><br><span class="line">   console.log(&apos;DOMContentLoaded &apos;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p>（浏览器渲染步骤其一）dom结构渲染完成，即并不是页面上资源加载完成，而是dom结构渲染完成。html被解析之后渲染成dom，用JS可以获取这个dom对象（不一定能看到效果，或者所引入的css或者图片等资源都不一定加载完成）</p><p>虽然可以用JS操作其元素，但在某些场景下dom元素仍不存在，这里涉及到浏览器的渲染加载机制（可回顾旧知识：），如：<br>图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/1653176c59fd26c2?w=600&amp;h=241&amp;f=jpeg&amp;s=55058" alt=""><br>得出的结果为<code>null</code>，是因为这里的js不是一个外链，会直接就去解析js并执行，后续的dom结构并没有渲染出来。</p><p>那么，如果我们把js放在body后面，则会输出一些结果：<img src="https://user-gold-cdn.xitu.io/2018/8/13/1653177206a42496?w=600&amp;h=451&amp;f=jpeg&amp;s=129582" alt=""><br>但如果还是需要将js放在<code>head</code>里，那么就需要：链接：<a href="http://js.jirengu.com/lajad/1/edit?html,output" target="_blank" rel="noopener"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">     document.addEventListener(&apos;DOMContentLoaded&apos;,function()&#123;</span><br><span class="line">     var btn = document.querySelector(&apos;#btn&apos;)</span><br><span class="line">    console.log(btn)     </span><br><span class="line">     &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>控制台打印输出：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165317775356dac4?w=600&amp;h=291&amp;f=gif&amp;s=88391" alt=""><br><strong>总结：</strong> 实践可知，可知为何使用document的<code>onload</code>事件，而不是用window上的<code>onload</code>事件。window上的<code>onload</code>必须要求所有页面资源加载完成，只是通过一个变量实现js操作，仍要按顺序去执行；而document则只需dom结构渲染完成，绑定<code>DOMContentLoaded</code>就可以执行<code>onload</code>事件，灵活方便。</p><p><strong>onload的图片加载实践</strong><br>用到<code>onload</code>的两类事件：<img src="https://user-gold-cdn.xitu.io/2018/8/13/1653177e39bb446b?w=600&amp;h=355&amp;f=jpeg&amp;s=119258" alt=""><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log($(&apos;img&apos;).width) //0</span><br><span class="line">  $(&apos;img&apos;).onload = function()&#123;  //211：通过这一步，输出图片宽度211</span><br><span class="line">      console.log(this.width)   //window.loaded网络请求到达，加载，图片到达，触发，此时才能获取图片的真实大小</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>0</code>：图片宽度为0，是因为js立刻执行，但执行过程中有网络请求（有时间限制），网络请求还没到（即资源图片等还没来），图片暂时获取的是img标签，那么此时图片宽度为0</p></blockquote><blockquote><p><code>DOMContentLoaded</code>：此时，通过<code>DOMContentLoaded</code>绑定事件，dom结构渲染完成，触发<code>DOMContentLoaded</code>事件，输出：<code>DOMContentLoaded</code></p></blockquote><h1 id="八、自定义事件"><a href="#八、自定义事件" class="headerlink" title="八、自定义事件"></a>八、自定义事件</h1><p>监听click事件，当用户监听的时候，就会有响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var EventCenter = &#123;</span><br><span class="line">  on: function(type, handler)&#123;</span><br><span class="line">    document.addEventListener(type, handler)</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: function(type, data)&#123;</span><br><span class="line">    return document.dispatchEvent(new CustomEvent(type, &#123;</span><br><span class="line">      detail: data</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//绑定的事件</span><br><span class="line">EventCenter.on(&apos;hello&apos;, function(e)&#123;</span><br><span class="line">  console.log(e.detail)</span><br><span class="line">&#125;)</span><br><span class="line">//用户所执行的交互行为</span><br><span class="line">EventCenter.fire(&apos;hello&apos;, &apos;你好&apos;)</span><br></pre></td></tr></table></figure></p><p><strong>实现对象分析：</strong><br>对象<code>EventCenter</code>中有两个函数，对应的有两个属性：<code>on</code>、<code>fire</code></p><p><strong>事件方法分析：</strong><br><code>EventCenter.on</code>，一个对象里有一个on方法，当<code>EventCenter</code>听到<code>&#39;hello&#39;</code>事件时，去执行<code>function(e)</code>这个事件监听函数，通过<code>e.detail</code>获取该事件的内容。此为绑定的事件概述</p><p>绑定好之后，在某些场景下，用户执行<code>EventCenter.fire(&#39;hello&#39;,&#39;你好&#39;)</code>，则会执行事件<code>&#39;hello&#39;</code>，后面加一些内容，如’你好’。与之对应的则是刚才的<code>e.detail</code>内容。</p><p><strong>实践：</strong> 如做轮播和对应内容，可把它们作为两个不同的个体，只需要通过绑定一个下一步事件，和具体内容，便可指定对应内容该做的“下一步”的工作何时加载、触发、执行</p><p><strong>例如：</strong> 链接：<a href="http://js.jirengu.com/vovig/1/edit?html,js,output" target="_blank" rel="noopener">http://js.jirengu.com/vovig/1/edit?html,js,output</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box box1&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">var EventCenter = &#123;</span><br><span class="line">  on: function(type, handler)&#123;</span><br><span class="line">    document.addEventListener(type, handler)</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: function(type, data)&#123;</span><br><span class="line">    return document.dispatchEvent(new CustomEvent(type, &#123;</span><br><span class="line">      detail: data</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*组件一中的一个功能点*/</span><br><span class="line">document.querySelector(&apos;.box input&apos;).oninput = function()&#123;</span><br><span class="line">  EventCenter.fire(&apos;box1input&apos;,this.value)</span><br><span class="line">&#125;//发送一个事件：&apos;box1input&apos;，用户输入的值：this.value</span><br><span class="line">//作用就是告诉别人我有这样一个绑定事件的消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*组件二的一个功能点*/</span><br><span class="line">EventCenter.on(&apos;box1input&apos;,function(e)&#123;</span><br><span class="line">  document.querySelector(&apos;.box2&apos;).innerText = e.detail</span><br><span class="line">&#125;)</span><br><span class="line">//函数表示：当EventCenter听到box1input这个事件的时候，则内部发生一些改变。</span><br><span class="line"></span><br><span class="line">//组件一中的消息是通过EventCenter作为媒介传递两个组件检的解绑</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、click—点击事件&quot;&gt;&lt;a href=&quot;#一、click—点击事件&quot; class=&quot;headerlink&quot; title=&quot;一、click—点击事件&quot;&gt;&lt;/a&gt;一、&lt;code&gt;click&lt;/code&gt;—点击事件&lt;/h1&gt;&lt;p&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;#btn&amp;apos;).addEventListener(&amp;apos;click&amp;apos;, function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&amp;apos;click&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(this)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="常见事件和使用" scheme="http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    
      <category term="自定义事件使用" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：10-02事件对象和事件代理</title>
    <link href="http://yoursite.com/2018/08/17/37-10.02%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/17/37-10.02事件对象和事件代理/</id>
    <published>2018-08-16T17:30:20.000Z</published>
    <updated>2018-08-17T18:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事件的IE兼容性"><a href="#一、事件的IE兼容性" class="headerlink" title="一、事件的IE兼容性"></a>一、事件的IE兼容性</h1><p>在老版的IE浏览器中，不支持：<code>addEventListener</code>和<code>removeEventListener</code>两种事件绑定的方法;支持（可实现）：<code>attachEvent</code>和<code>detachEvent</code> 两种方法，同时接收两个相同参数</p><ul><li>a、事件处理程序名称</li><li>b、事件处理程序方法<a id="more"></a></li></ul><p>由于IE支持事件冒泡，所以添加的程序会被添加到冒泡阶段，使用<code>attachEvent</code>可以添加事件处理程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btnClick&quot;  type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   var btnClick = document.getElementById(&apos;btnClick&apos;)</span><br><span class="line">   var handler = function()&#123;</span><br><span class="line">          alert(this.id)</span><br><span class="line">&#125;</span><br><span class="line">   btnClick.attachEvent(&apos;onclick&apos;,handler);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>attachEvent</code>只能在冒泡阶段监听事件，只有两个参数：(事件类型，事件处理函数)</li><li>ie中的<code>this</code>：它所得到的并不是当前元素，而是window对象，返回值则为<code>undefined</code></li></ul><h1 id="二、跨浏览器的事件处理程序"><a href="#二、跨浏览器的事件处理程序" class="headerlink" title="二、跨浏览器的事件处理程序"></a>二、跨浏览器的事件处理程序</h1><p>了解不同的浏览器下处理事件处理程序的区别在添加事件处理程序事<code>addEventListener</code>和<code>attachEvent</code>主要有几个区别：</p><p>1、参数个数不相同，这个最直观，<code>addEventListener</code>有三个参数，<code>attachEvent</code>只有两个，<code>attachEvent</code>添加的事件处理程序只能发生在冒泡阶段，<code>addEventListener</code>第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段）</p><p>2、第一个参数意义不同，<code>addEventListener</code>第一个参数是事件类型（比如<code>click</code>，<code>load</code>），而<code>attachEvent</code>第一个参数指明的是事件处理函数名称（<code>onclick</code>，<code>onload</code>）</p><p>3、事件处理程序的作用域不相同，<code>addEventListener</code>的作用域是元素本身，this是指的触发元素，而<code>attachEvent</code>事件处理程序会在全局变量内运行，this是window，所以刚才例子才会返回<code>undefined</code>，而不是元素id</p><p>4、为一个事件添加多个事件处理程序时，执行顺序不同，<code>addEventListener</code>添加会按照添加顺序执行，而<code>attachEvent</code>添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了)，所以添加多个的时候，不依赖执行顺序的还好，若是依赖于函数执行顺序，最好自己处理，不要指望浏览器</p><h1 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h1><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531513afb9140c?w=600&amp;h=354&amp;f=jpeg&amp;s=71547" alt=""></p><p>如刚才例子<a href="http://js.jirengu.com/hahid/1/edit?html,js" target="_blank" rel="noopener"></a>中在控制台上打印出事件，事件内都是一些对象（带有属性和值），可以从这堆属性中观察到一些重要的参考（只是部分例举），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">altKey:false  //表示在点击事件的时候，没有点alt键</span><br><span class="line">bubbles:true  //表示这个事件是冒泡</span><br><span class="line">clientX:39</span><br><span class="line">clientY:18   //表示它的一个位置</span><br><span class="line">toElement:button#btn   //说明当前传递的元素</span><br></pre></td></tr></table></figure></p><p>介绍几个常用属性：</p><ul><li><p><code>stopPropagation()</code><br>如图：<img src="https://pic2.zhimg.com/v2-b44a7d2d9052f900e58b3346ed0b541b_b.jpghttps://pic2.zhimg.com/v2-b44a7d2d9052f900e58b3346ed0b541b_b.jpg" alt="没加载"><br><strong>阻止冒泡继续？</strong><br>在dom事件流中，分别会在捕获和冒泡阶段都绑定事件，先捕获后冒泡进行输出。假设我们现在不管捕获，只管冒泡，并给body绑定一个监听事件，当它听到事件做了一件事：一点<code>stopPropagation()</code>就停止冒泡，即点击div之后，body监听到消息，后面的页面元素渲染就不再处理。即将事件冒泡停止，不会再上传消息。捕获也亦然。</p></li><li><p><code>preventDefault()</code><br><strong>浏览器的默认事件如何阻止？</strong><br>某些元素拥有默认事件，为浏览器的默认行为。如a链接点击时则会跳转、如form表单中<code>table</code>=<code>submit</code>，当点击该按钮时，浏览器会把它所在的form表单做一次提交。假设想阻止其默认行为，则可以通过绑定事件：<code>preventDefault()</code>阻止其行为。之后再做一些校验或判断，用JS做当前页面跳转。即在跳转这一层级可以做些事：假设制定一个域名的a链接才能跳转（而页面则是用户可自行写链接）先阻止其默认时间，再获取当前<code>herf</code>的值、<code>hostname</code>（域名）</p></li></ul><blockquote><p>假设表单提交，用户校验，校验成功之后，就手动去做一些跳转</p></blockquote><ul><li><code>e.stopPropagation()</code> 取消事件进一步捕获或冒泡<br><strong>事件冒泡和事件捕获的应用场景</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//选中元素</span><br><span class="line">var container = document.querySelector(&apos;.container&apos;)</span><br><span class="line"></span><br><span class="line">var box = document.querySelector(&apos;.box&apos;)</span><br><span class="line"></span><br><span class="line">var target = document.querySelector(&apos;.target&apos;)</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">container.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(&apos;container 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(&apos;box 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  console.log(&apos;target 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">container.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(&apos;container 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">  console.log(&apos;box 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  console.log(&apos;target 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br></pre></td></tr></table></figure></li></ul><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165315489bec5288?w=600&amp;h=277&amp;f=gif&amp;s=50938" alt=""><br>多个阻止函数来阻止冒泡事件<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653154ec62ec39a?w=599&amp;h=319&amp;f=gif&amp;s=6512397" alt=""></p><ul><li><code>e.preventDefault()</code>  阻止事件默认行为<br>链接：<a href="https://user-gold-cdn.xitu.io/2018/8/13/1653155c1e91f359" target="_blank" rel="noopener">阻止事件默认行为</a><br>刚开始是这样的：没有跳转，只有一直输出：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653155fedfafdd0?w=599&amp;h=155&amp;f=gif&amp;s=1590993" alt=""><br>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">       &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">      &lt;title&gt;阻止默认事件&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">       &lt;body&gt;</span><br><span class="line">          &lt;a href=&quot;http://baidu.com&quot;&gt;baidu&lt;/a&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">   &lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&apos;a&apos;).onclick = function(e)&#123;</span><br><span class="line">           e.preventDefault()</span><br><span class="line">           console.log(this.href)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>接着看图所示，添加一个if判断，再点击baidu链接，控制台只输出一次地址，页面则出现百度的网页：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165315801293d588?w=599&amp;h=193&amp;f=gif&amp;s=2637493" alt=""><br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//html同上</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.querySelector(&apos;a&apos;).onclick = function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(this.href)</span><br><span class="line">  if(/baidu.com/.test(this.href))&#123;</span><br><span class="line">    location.href = this.href</span><br><span class="line">  &#125;</span><br><span class="line">&#125;//函数表示：如果这个链接是baidu.com,那就跳转</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>假如html代码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://baidu.com&quot;&gt;baidu&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://baid.com&quot;&gt;baidu&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>最后页面和控制台都不会有任何反应。而这就是<code>e.preventDefault()</code> 阻止事件默认行为</p><h1 id="四、常用HTML事件及演示"><a href="#四、常用HTML事件及演示" class="headerlink" title="四、常用HTML事件及演示"></a>四、常用HTML事件及演示</h1><p>例子链接：<a href="">缺常见事件使用演示链接</a></p><h1 id="五、事件代理"><a href="#五、事件代理" class="headerlink" title="五、事件代理"></a>五、事件代理</h1><p>链接：<a href="http://js.jirengu.com/cujut/1/edit?html,js,console,output" target="_blank" rel="noopener">事件代理的一些尝试</a><br>首先，我们为两个box绑定两个事件，先绑定box1，如图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/1653159629d4a80b?w=600&amp;h=160&amp;f=gif&amp;s=54736" alt=""><br>通过选择参数<code>$(&#39;.box&#39;)</code>作为box1的当前元素，所以再去绑定事件之后，则只会出现第一个box1文本内容。</p><p>但是，我们尝试地使用函数<code>$$(selector)</code>绑定两个元素的事件，再点击box1和box2没有任何输出，如图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/1653159a7be68600?w=600&amp;h=174&amp;f=gif&amp;s=90403" alt=""></p><p>通过页面控制台检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$(&apos;.box&apos;)</span><br><span class="line"> --&gt;  NodeList(2) [div.box, div.box]//1、确实出现了所选的两个元素，但是要确认有没有onclick</span><br><span class="line">      0: div.box</span><br><span class="line">      1: div.box</span><br><span class="line">      length: 2</span><br><span class="line">      __proto__: NodeList   //3、我们所看到NodeList，是一个类数组对象，里面的属性值并没有onclick和addEventListener</span><br><span class="line">$$(&apos;.box&apos;).onclick   //2、于是测试之后undefined，即绑定事件只能针对单个去绑定事件</span><br><span class="line"> --&gt;  undefined</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165315ab5aef8e94?w=599&amp;h=293&amp;f=gif&amp;s=8773321" alt=""></p><p>那如何解决两个元素同时绑定事件呢？还是从控制台<code>nodelist</code>的对象中寻找可用的参数去解决，即有forEach遍历两个元素，实现两个都绑定了事件，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//html同上</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function $$(selector)&#123;</span><br><span class="line">  return document.querySelectorAll(selector)</span><br><span class="line">&#125;</span><br><span class="line">$$(&apos;.box&apos;).forEach(function(node)&#123;</span><br><span class="line">  node.onclick = function()&#123;</span><br><span class="line">     console.log(this.innerText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165315afe98acb72?w=599&amp;h=255&amp;f=gif&amp;s=5045511" alt=""><br>那么，我们有没有更简单的方法实现当前所有元素都绑定了事件？看html即可以知道，我们可以直接绑定父元素<code>container</code>，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;box&quot;&gt;box1&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;box&quot;&gt;box2&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;hello&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function $(selector)&#123;</span><br><span class="line">  return document.querySelector(selector)</span><br><span class="line">&#125;</span><br><span class="line">function $$(selector)&#123;</span><br><span class="line">  return document.querySelectorAll(selector)</span><br><span class="line">&#125;</span><br><span class="line">$(&apos;.container&apos;).onclick = function(e)&#123;</span><br><span class="line">  if(e.target.classList.contains(&apos;box&apos;))&#123;</span><br><span class="line">    console.log(e.target.innerText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;//表示：如果我点击了一个元素（e.target），它的classList包含了&apos;box&apos;，</span><br><span class="line">//那么它就输出这个元素的文本内容。具有语义化</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>再想到更多的场景，如有一个按钮，如何绑定这个按钮实现这样一个需求：当点击这个按钮的时候，则会在父元素下再添加一个box。这个如何实现？如图：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165315b6350d8ce8?w=599&amp;h=256&amp;f=gif&amp;s=8733083" alt=""><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;box&quot;&gt;box1&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;box&quot;&gt;box2&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;box&quot;&gt;box3&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;hello&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">  &lt;button id=&quot;add&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;!--需求：当点击这个按钮的时候，则会在父元素下再添加一个box--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function $(selector)&#123;</span><br><span class="line">  return document.querySelector(selector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function $$(selector)&#123;</span><br><span class="line">  return document.querySelectorAll(selector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(&apos;.container&apos;).onclick = function(e)&#123;</span><br><span class="line">  if(e.target.classList.contains(&apos;box&apos;))&#123;</span><br><span class="line">    console.log(e.target.innerText)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;//事件代理的核心所在</span><br><span class="line"></span><br><span class="line">//表示：如果我点击了一个元素（e.target），它的classList包含了&apos;box&apos;，那么它就输出这个元素的文本内容。具有语义化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var i=4  //这是因为之前有box3了</span><br><span class="line">$(&apos;#add&apos;).onclick = function()&#123;</span><br><span class="line">  var box = document.createElement(&apos;div&apos;)//创建一个box元素</span><br><span class="line">  box.classList.add(&apos;box&apos;)//创建的当前元素去添加一个class叫做box</span><br><span class="line">  box.innerText =&apos;box&apos; + (i++)//表示每点击一次i就增加一个</span><br><span class="line">  $(&apos;.container&apos;).appendChild(box)//最后将box这个元素添加进.container里面</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、事件的IE兼容性&quot;&gt;&lt;a href=&quot;#一、事件的IE兼容性&quot; class=&quot;headerlink&quot; title=&quot;一、事件的IE兼容性&quot;&gt;&lt;/a&gt;一、事件的IE兼容性&lt;/h1&gt;&lt;p&gt;在老版的IE浏览器中，不支持：&lt;code&gt;addEventListener&lt;/code&gt;和&lt;code&gt;removeEventListener&lt;/code&gt;两种事件绑定的方法;支持（可实现）：&lt;code&gt;attachEvent&lt;/code&gt;和&lt;code&gt;detachEvent&lt;/code&gt; 两种方法，同时接收两个相同参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a、事件处理程序名称&lt;/li&gt;
&lt;li&gt;b、事件处理程序方法
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="事件对象" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="事件代理" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    
      <category term="事件的IE兼容性" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E7%9A%84IE%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
      <category term="跨浏览器的事件处理程序" scheme="http://yoursite.com/tags/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：10-01事件（流）和事件处理程序</title>
    <link href="http://yoursite.com/2018/08/17/36-10.01%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%B5%81%EF%BC%89%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/17/36-10.01事件（流）和事件处理程序/</id>
    <published>2018-08-16T17:01:32.000Z</published>
    <updated>2018-08-17T18:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>最近，很多事情的时间交叉点汇集到一起，时间明显越来越少了。因为要学做项目了，写博客的记录已经赶不上课程的学习进度，记录知识在博客真的是一个耗费时间和精力的事情啊，这其中还要查资料、弄懂知识点，而且也到了再一次梳理知识集中问老师的时候。赶着时间学习，会有一种赶着你跑的冲劲，加油吧。<br><a id="more"></a></p><h1 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h1><p>dom操作，可以用JS在页面上操作元素。不过dom操作需要一个时机，即跟用户交互时，什么时候才能改变这个dom结构，那么此时就用到了事件。</p><p>用户在浏览器上的任何操作，都可能触发一个事件，如鼠标移动。滚动页面、点击、甚至鼠标放在页面上的某处等任何的页面操作都会触发一个事件。</p><h1 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h1><p>事件是如何产生和如何传播<br>假设事件不传播，无任何事件传播机制，点到什么是什么。那么，当我们点击整个页面的dom，事件却不传播，那页面中的某层结构怎么知道点击了该事件，那又如何去触发事件？</p><h3 id="1、事件冒泡模型"><a href="#1、事件冒泡模型" class="headerlink" title="1、事件冒泡模型"></a>1、事件冒泡模型</h3><p>元素先监听到这个事件，往外传播<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531443185c9bb1?w=244&amp;h=192&amp;f=jpeg&amp;s=10929" alt=""></p><h3 id="2、事件捕获模型"><a href="#2、事件捕获模型" class="headerlink" title="2、事件捕获模型"></a>2、事件捕获模型</h3><p>document最先监听到这个事件<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165314465f324bc4?w=244&amp;h=184&amp;f=jpeg&amp;s=10327" alt=""></p><h3 id="3、DOM事件流"><a href="#3、DOM事件流" class="headerlink" title="3、DOM事件流"></a>3、DOM事件流</h3><p>先捕获，再冒泡<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653144862a00369?w=244&amp;h=178&amp;f=jpeg&amp;s=11635" alt=""><br>允许在某些地方监听事件，假设在某个元素两阶段都绑定一个事件监听器，看你是决定在左边捕获阶段监听，还是右边冒泡阶段监听，哪一边有响应，哪一边事件就被触发。即可以在任一阶段、任意时机监听事件</p><h1 id="三、事件的使用方式"><a href="#三、事件的使用方式" class="headerlink" title="三、事件的使用方式"></a>三、事件的使用方式</h1><h3 id="1、事件处理程序"><a href="#1、事件处理程序" class="headerlink" title="1、事件处理程序"></a>1、事件处理程序</h3><p>也叫事件侦听器。当用户点击（或当某个事件触发的时候），我们所要做的事情。</p><h3 id="2、如何绑定事件处理程序？"><a href="#2、如何绑定事件处理程序？" class="headerlink" title="2、如何绑定事件处理程序？"></a>2、如何绑定事件处理程序？</h3><blockquote><p>JavaScript指定事件处理程序</p></blockquote><p>（1）对一个元素绑定一个事件函数：<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btnClick&quot; type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btnClick = document.getElementById(&apos;btnClick&apos;);//声明一个变量，选择这个元素给它做个赋值，选择这个dom元素</span><br><span class="line">    btnClick.onclick = function showMessage() &#123;   //元素.事件(),元素绑定一个事件，即onclick，该事件名可以改，如oniput、onfocus等（本身没有执行，只有当事件触触发，即用户交互时，才会被执行）</span><br><span class="line">        alert(this.id);//this相当于btnClick这个元素，作为一个占位符存在</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>函数什么时候执行？看此例子：<a href="http://js.jirengu.com/ponaz/2/edit" target="_blank" rel="noopener"></a><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653145cfd05d4c4?w=600&amp;h=253&amp;f=gif&amp;s=47518" alt=""><br>当用户点击触发事件时，就会将该事件的对应执行放进任务队列里，此时这个事件函数才会去被执行。由此可以明白两件事：</p><ul><li>绑定这个函数事件则是同步</li><li>点击、执行函数事件的操作是异步</li></ul><p>（2）对一个元素绑定多个事件函数<br>看下面这个例子：<a href="https://user-gold-cdn.xitu.io/2018/8/13/165314721529faef" target="_blank" rel="noopener"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var btn = document.querySelector(&apos;#btn&apos;)</span><br><span class="line">//#事件01</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">console.log(this)</span><br><span class="line">console.log(this.innerText)</span><br><span class="line">&#125;</span><br><span class="line">//#事件02</span><br><span class="line"> btn.onclick = function()&#123;</span><br><span class="line">  console.log(&apos;hello world&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653147b40254a9f?w=600&amp;h=217&amp;f=gif&amp;s=31307" alt=""><br><strong>总结：</strong> 这个时候，添加了<code>#02</code>事件函数，并点击按钮<code>click me</code>,发事件函数，输出<code>&#39;hello world&#39;</code>，直接覆盖#01事件函数的值。</p><blockquote><p>DOM2事件处理程序（实现对一个元素绑定多个事件）</p></blockquote><p>（1）dom作为事件处理的一个基本标准，dom2级事件为dom事件的升级。<br>（2）DOM2级事件定义用于处理指定和删除事件处理程序的操作：</p><ul><li><code>addEventListener</code></li><li><code>removeEventListener</code></li></ul><p>（3）所有的DOM节点都包含这两个方法，并且它们都接受三个参数：</p><ul><li>A、事件类型</li><li>B、事件处理方法</li><li>C、布尔参数，</li></ul><p><strong>如果是<code>true</code>表示在捕获阶段调用事件处理程序，如果是<code>false</code>，则是在事件冒泡阶段处理</strong></p><p>（4）绑定事件方法实例演示：<br><code>addEventListener</code>   绑定事件（直接执行一个函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btnClick&quot; type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btnClick = document.getElementById(&apos;btnClick&apos;);</span><br><span class="line">    btnClick.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">        alert(this.id);  //函数里的this代表当前的元素btnClick，所以我们可以通过this.id获取当前元素的id</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>例子：<a href="http://js.jirengu.com/lajoy/1/edit?js,console,output" target="_blank" rel="noopener"></a><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531494e89aa540?w=600&amp;h=302&amp;f=gif&amp;s=38104" alt=""></p><p><strong>总结：</strong> 这里并不是给变量添加一个值，而是通过执行<code>addEventListener</code> 这样一个函数，函数可以执行多次，对同样事件可以做多个绑定做不同的事情，也不会产生覆盖。</p><blockquote><p><strong>区别:</strong></p></blockquote><p>1、JavaScript指定事件：<code>btnClick.onclick</code> =<code>functionshowMessage(){alert(this.id);}</code> 为属性添加一个值；DOM2事件处理程序:<code>addEventListener</code> 执行一个函数<br>2、JavaScript指定事件的事件是：<code>onclick</code>，DOM2事件处理程序的事件是<code>：click</code><br>3、DOM2事件处理程序的dom节点最后还可以添加布尔值，表示处于冒泡阶段（false）还是捕获阶段（true）。默认情况下（无传进参数），为冒泡阶段（false）<br>4、<code>this：alert(this.id)</code><br>函数里的this代表当前的元素<code>btnClick</code>，所以我们可以通过<code>this.id</code>获取当前元素的id</p><blockquote><p><strong>思考：</strong><br>事件到底是什么？此时我们可以通过下面例子来说明事件的一些问题：</p></blockquote><p>例子链接： <a href="http://js.jirengu.com/hahid/1/edit?html,js" target="_blank" rel="noopener">http://js.jirengu.com/hahid/1/edit?html,js</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//简单的绑定事件,可通过此方法进行绑定</span><br><span class="line">var btn = document.querySelector(&apos;#btn&apos;)</span><br><span class="line">btn.onclick = function (e)&#123;</span><br><span class="line">   console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">//通过这个函数可以用来查看这个事件。可以在里面传一个参数e</span><br><span class="line">//或者采用另一种绑定事件的方法：</span><br><span class="line">btn.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//注：e，只是一个自定义的参数，可以随意改变参数名</span><br></pre></td></tr></table></figure></p><p>点击<code>click</code>时，在控制台上打印出事件，事件内都是一些对象（带有属性和值），可以从这堆属性中观察到一些重要的参考（只是部分例举），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">altKey:false  //表示在点击事件的时候，没有点alt键</span><br><span class="line">bubbles:true  //表示这个事件是冒泡</span><br><span class="line">clientX:39</span><br><span class="line">clientY:18   //表示它的一个位置</span><br><span class="line">toElement:button#btn   //说明当前传递的元素</span><br></pre></td></tr></table></figure></p><p>这里可以通过（<code>e.target</code>）看一看到底点击了哪个元素，并不是我们通常意义下看到的例子中的当前元素btn，现在一般来说，绑定一个事件可以使用以下几个方法（续上面的例子）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var btn = document.querySelector(&apos;#btn&apos;)</span><br><span class="line">btn.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">//或</span><br><span class="line">   console.log(btn)</span><br><span class="line">//或</span><br><span class="line">  console.log(e.target)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>（5）如何解绑事件（一般情况下不做）<br><code>removeEventListener</code> 解绑事件。与<code>addEventListener</code>相对应，通过<code>removeEventListener</code>移除解绑事件，表现为点击时无反应</p><p>需要注意的是，<code>removeEventListener</code>解绑事件，不能使用匿名函数（无法获知要移除哪一个），正确如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btnClick = document.getElementById(&apos;btnClick&apos;);</span><br><span class="line">    var handler=function() &#123;</span><br><span class="line">        alert(this.id);</span><br><span class="line">    &#125;</span><br><span class="line">    btnClick.removeEventListener(&apos;click&apos;, handler, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>（6）事件整体实例展示<br>A、<strong>冒泡阶段·实例展示</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">     container</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        box</span><br><span class="line">      &lt;div class=&quot;target&quot;&gt;</span><br><span class="line">        hello</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//选中元素</span><br><span class="line">var container = document.querySelector(&apos;.container&apos;)</span><br><span class="line"></span><br><span class="line">var box = document.querySelector(&apos;.box&apos;)</span><br><span class="line"></span><br><span class="line">var target = document.querySelector(&apos;.target&apos;)</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">container.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;container click...&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;box click...&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">  console.log(&apos;target click...&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>默认情况下（无传进的参数），事件绑定是呈现冒泡阶段，执行结果展示：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165314b427151957?w=600&amp;h=263&amp;f=gif&amp;s=59336" alt=""></p><p>执行的过程事实上是，点击这个事件的时候，一开始便是从<code>container</code>——<code>box</code>——<code>hello</code>，返回时，为冒泡阶段，从<code>hello</code>——<code>box</code>——<code>container</code>，绑定了事件，分别有了响应控制台分别打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;target click...&quot;</span><br><span class="line">&quot;box click...&quot;</span><br><span class="line">&quot;container click...&quot;</span><br></pre></td></tr></table></figure></p><p>这一过程就像是从下到上的冒泡过程，冒泡过程中到哪个事件元素，触发，响应，则会执行对应事件函数</p><p>B、<strong>事件捕获阶段·实例展示</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//html同上</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//选中元素</span><br><span class="line">var container = document.querySelector(&apos;.container&apos;)</span><br><span class="line"></span><br><span class="line">var box = document.querySelector(&apos;.box&apos;)</span><br><span class="line"></span><br><span class="line">var target = document.querySelector(&apos;.target&apos;)</span><br><span class="line"></span><br><span class="line">//绑定事件,添加了参数true</span><br><span class="line">container.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;container click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;box click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">  console.log(&apos;target click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165314bc78bc10ae?w=599&amp;h=220&amp;f=gif&amp;s=4205913" alt=""></p><p>捕获阶段，点击事件<code>hello</code>，结果显示在刚进去的时候就绑定了事件，所以一开始事件元素就监听到，那么事件触发响应的过程就是<code>hello</code>——<code>box</code>——<code>container</code>，结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;container click...&quot;</span><br><span class="line">&quot;box click...&quot;</span><br><span class="line">&quot;target click...&quot;</span><br></pre></td></tr></table></figure></p><p>C、<strong>事件传播整体机制原理和实践·实例展示</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//html同上</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//选中元素</span><br><span class="line">var container = document.querySelector(&apos;.container&apos;)</span><br><span class="line">var box = document.querySelector(&apos;.box&apos;)</span><br><span class="line">var target = document.querySelector(&apos;.target&apos;)</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">//捕获事件绑定</span><br><span class="line">container.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;container 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;box 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">  console.log(&apos;target 捕获 click...&apos;)</span><br><span class="line">&#125;,true)</span><br><span class="line"></span><br><span class="line">//冒泡事件绑定</span><br><span class="line">container.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;container 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br><span class="line"></span><br><span class="line">box.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;box 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">  console.log(&apos;target 冒泡 click...&apos;)</span><br><span class="line">&#125;,false)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如图所示：结果输出，说明是先进行捕获事件触发、响应，再到冒泡事件触发、响应，先进后出：<img src="https://user-gold-cdn.xitu.io/2018/8/13/165314c909615f78?w=599&amp;h=252&amp;f=gif&amp;s=3438913" alt=""></p><blockquote><p>【不常用】HTML内联方式——<code>onclick</code> ，当用户点击的时候的事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Here&quot; onclick=&quot;alert(&apos;Clicked!&apos;);&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;最近，很多事情的时间交叉点汇集到一起，时间明显越来越少了。因为要学做项目了，写博客的记录已经赶不上课程的学习进度，记录知识在博客真的是一个耗费时间和精力的事情啊，这其中还要查资料、弄懂知识点，而且也到了再一次梳理知识集中问老师的时候。赶着时间学习，会有一种赶着你跑的冲劲，加油吧。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="事件（流）" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%B5%81%EF%BC%89/"/>
    
      <category term="事件处理程序" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：09 DOM元素</title>
    <link href="http://yoursite.com/2018/08/17/35-09%20DOM%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/08/17/35-09 DOM元素/</id>
    <published>2018-08-16T17:01:18.000Z</published>
    <updated>2018-08-16T17:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、DOM"><a href="#一、DOM" class="headerlink" title="一、DOM"></a>一、DOM</h1><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>DOM，即文档对象模型（Document Object Model ）<br><a id="more"></a></p><h3 id="2、现象"><a href="#2、现象" class="headerlink" title="2、现象"></a>2、现象</h3><p>通过在页面——打开：检查元素——看见：元素为可折叠。可选中页面对应元素，事实上即选择了对象（即也选择了对象对应的属性或方法），相当于把页面文档对象化。事实上，就是用js手段调用操作该文档（即一个对象）。<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165282eaf18f0f29?w=486&amp;h=266&amp;f=jpeg&amp;s=22604" alt=""></p><h1 id="二、Document对象，属性（或方法）"><a href="#二、Document对象，属性（或方法）" class="headerlink" title="二、Document对象，属性（或方法）"></a>二、Document对象，属性（或方法）</h1><p>在DOM中最常用的对象就是：document对象（页面——检查，即查看属性）、element对象</p><h3 id="1、常用属性"><a href="#1、常用属性" class="headerlink" title="1、常用属性"></a>1、常用属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.doctype</span><br><span class="line">document.title</span><br><span class="line">document.characterSet</span><br><span class="line">document.head</span><br><span class="line">document.body</span><br><span class="line">document.images</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/165282eeca183fa8?w=600&amp;h=427&amp;f=jpeg&amp;s=70597" alt=""></p><h3 id="2、document-readyState"><a href="#2、document-readyState" class="headerlink" title="2、document.readyState"></a>2、<code>document.readyState</code></h3><p><strong>readyState属性</strong>   返回当前文档的状态，共有三种可能的值:</p><ul><li>loading：加载HTML代码阶段，尚未完成解析</li><li>interactive：加载外部资源阶段</li><li>complete：全部加载完成</li></ul><p>图：可在代码中加上几张图片元素，再设置网络条件为慢3G，则出现：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165282fcb60472f1?w=600&amp;h=360&amp;f=jpeg&amp;s=76435" alt=""></p><h3 id="3、-document-compatMode"><a href="#3、-document-compatMode" class="headerlink" title="3、 document.compatMode"></a>3、 <code>document.compatMode</code></h3><p><strong>compatMode 属性</strong>  返回浏览器处理文档的模式，可能的值为</p><ul><li>BackCompat：向后兼容模式，也就是没有添加DOCTYPE</li><li>CSS1Compat：严格模式，添加了DOCTYPE</li></ul><h3 id="4、document-location"><a href="#4、document-location" class="headerlink" title="4、document.location"></a>4、<code>document.location</code></h3><p>用于获取一个url</p><p>可直接使用<code>location</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.location === location        //true</span><br><span class="line">document.location === window.location  //true</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong> <code>document.location === location ===  window.location</code><br><code>location</code>属性返回一个只读对象，提供了当前文档的URL信息，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 假定当前网址为http://user:passwd@www.example.com:4097/path/a.html?x=111#part1</span><br><span class="line"></span><br><span class="line">document.location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</span><br><span class="line">document.location.protocol // &quot;http:&quot;</span><br><span class="line">document.location.host // &quot;www.example.com:4097&quot;</span><br><span class="line">document.location.hostname // &quot;www.example.com&quot;</span><br><span class="line">document.location.port // &quot;4097&quot;</span><br><span class="line">document.location.pathname // &quot;/path/a.html&quot;</span><br><span class="line">document.location.search // &quot;?x=111&quot;</span><br><span class="line">document.location.hash // &quot;#part1&quot;</span><br><span class="line">document.location.user // &quot;user&quot;</span><br><span class="line">document.location.password // &quot;passed&quot;</span><br></pre></td></tr></table></figure></p><p>其他location属性调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 跳转到另一个网址</span><br><span class="line">document.location.assign(&apos;http://www.google.com&apos;)</span><br><span class="line"></span><br><span class="line">// 优先从服务器重新加载</span><br><span class="line">document.location.reload(true)</span><br><span class="line"></span><br><span class="line">// 优先从本地缓存重新加载（默认值）</span><br><span class="line">document.location.reload(false)</span><br><span class="line"></span><br><span class="line">// 跳转到另一个网址，但当前文档不保留在history对象中，</span><br><span class="line">// 即无法用后退按钮，回到当前文档</span><br><span class="line">document.location.assign(&apos;http://www.google.com&apos;)</span><br><span class="line"></span><br><span class="line">// 将location对象转为字符串，等价于document.location.href</span><br><span class="line">document.location.toString()</span><br></pre></td></tr></table></figure></p><h3 id="5、document-write"><a href="#5、document-write" class="headerlink" title="5、document.write()"></a>5、<code>document.write()</code></h3><p>用<code>document.write()</code>方法时，即向当前文档写入内容，只要当前文档还没有用close方法关闭，它所写入的内容就会追加在已有内容的后面。<br>1<a href="https://pic2.zhimg.com/v2-7987a184f7dee394a535ac3c1920977c_b.jpg" target="_blank" rel="noopener"></a></p><ul><li>如果页面已经渲染完成再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。</li><li>如果在页面渲染过程中调用write方法，并不会调用open方法。<br>-需要注意的是，虽然调用close方法之后，无法再用write方法写入内容，但这时当前页面的其他DOM节点还是会继续加载。<br>-做测试时，无须使用document.write()方法</li></ul><h1 id="三、Element对象，属性（或方法）"><a href="#三、Element对象，属性（或方法）" class="headerlink" title="三、Element对象，属性（或方法）"></a>三、Element对象，属性（或方法）</h1><p>document对应的具体元素应如何选取（或操作）？<br>element对象表示页面上的元素。使用JS选择页面上的元素（element），然后对其做操作。</p><p>那么，对页面元素的操作有哪些？</p><p>A、选择它：通过一些方法找到其具体元素（如用css的id，class名，选择器、邻居、赋值等）</p><p>B、处理它：对拥有类型为元素节点、文本节点、注释节点的子节点进行删除、增加、查找、修改等操作</p><h3 id="1、几个常用属性"><a href="#1、几个常用属性" class="headerlink" title="1、几个常用属性"></a>1、几个常用属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nodeName：元素标签名，还有个类似的tagName</span><br><span class="line">nodeType：元素类型</span><br><span class="line">className：类名</span><br><span class="line">id：元素id</span><br><span class="line">children：子元素列表（HTMLCollection）</span><br><span class="line">childNodes：子元素列表（NodeList）</span><br><span class="line">firstChild：第一个子元素</span><br><span class="line">lastChild：最后一个子元素</span><br><span class="line">nextSibling：下一个兄弟元素</span><br><span class="line">previousSibling：上一个兄弟元素</span><br><span class="line">parentNode、parentElement：父元素</span><br></pre></td></tr></table></figure><h3 id="2、查询元素（如何选中一个元素？）"><a href="#2、查询元素（如何选中一个元素？）" class="headerlink" title="2、查询元素（如何选中一个元素？）"></a>2、查询元素（如何选中一个元素？）</h3><p>（1）<code>getElementById()</code><br>结合页面元素使用 <code>+</code><br><code>document.getElementByid()</code></p><p>如图：利用此方法选中该id的页面位置<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1e39352fe?w=600&amp;h=583&amp;f=jpeg&amp;s=98240" alt=""></p><p>（2）<code>getElementsByClassName()</code>     <strong>注：有s</strong><br><code>document.getElementByClassName()</code></p><p>页面元素中不止独一无二的id名，还有类选择器，当我们在页面控制台上通过<code>getElementByClassName()</code>时，可获取（或查询）到一个或多个类选择器，会出现如图现象：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1ecdb18dc?w=600&amp;h=392&amp;f=jpeg&amp;s=105639" alt=""><br>这看上去有点像数组，呈现形式相似、也可以用下标去进行访问。但通过<code>list.</code>去查看，并没有有关排序<code>push</code>、<code>pop</code>等的调用数组的方法，而是一种类数组的形式。</p><p>通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.constructor</span><br><span class="line">--&gt; ƒ HTMLCollection()&#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以获知，<code>document.getElementsByClassName()</code> 所调用的是html里类的集合，其类型为<code>HTMLCollection()</code>，是一种页面元素的集合。</p><p>（3）<code>getElementsByName()</code><br><code>document.getElementsByName()</code><br>通过此方法可以获取页面元素中带有name属性的html元素。比如<code>form</code>、<code>img</code>、<code>frame</code>、<code>embed</code>和<code>object</code>，返回一个<code>NodeList</code>格式的对象，不会实时反映元素的变化。如：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1ed0291a7?w=600&amp;h=185&amp;f=jpeg&amp;s=45781" alt=""></p><p>（4）假设,类选择器有嵌套的话，我们如何获取嵌套于内的元素？如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/16/16541c20e8dc95ed?w=720&amp;h=255&amp;f=jpeg&amp;s=32211" alt=""><br>A、<strong>（较为繁琐的）</strong> ES3写法：<code>getElementsByName().getElementsByName()</code></p><p>语法：<br><code>document.getElementsByName().getElementsByName()</code></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName(&apos;box&apos;)[0].getElementsByClassName(&apos;child&apos;)</span><br><span class="line">--&gt; HTMLCollection [div.child]</span><br></pre></td></tr></table></figure></p><p>事实上，使用<strong>document.getElementsByName()</strong>做一个联集，即无论是document还是任何一个对象，都可以使用：<strong>对象.XXXX</strong>  去做一个联集对象去获取相对应的准确元素。</p><p>B、<strong>（较为简便的）</strong><br>ES5写法：<code>querySelector()</code></p><p><strong>注：</strong>可用于选择id元素使用</p><p>语法：<br><code>document.querySelector()</code></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.box .child&apos;)</span><br><span class="line">--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1ed1312ed?w=600&amp;h=239&amp;f=jpeg&amp;s=86594" alt=""><br>不过，它选择元素的时候，只能获取一个元素，如页面元素中有多个div，只会默认选择html元素中排在第一个的div元素。</p><p>如果需要在选择元素时，多种页面元素希望可以同时选中，则可以使用<br>这样的写法：<code>querySelectorAll()</code></p><p><strong>注：</strong> 可用于选择class元素时使用</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//比如：</span><br><span class="line">document.querySelectorAll(&apos;div&apos;)</span><br><span class="line">--&gt; NodeList(3) [div.box, div.child, div.box]</span><br><span class="line">document.querySelectorAll(&apos;.box&apos;)</span><br><span class="line">--&gt; NodeList(2) [div.box, div.box]</span><br><span class="line">document.querySelectorAll(&apos;#target&apos;)</span><br><span class="line">--&gt; NodeList [p#target]</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1ed326b7d?w=600&amp;h=182&amp;f=jpeg&amp;s=52390" alt=""></p><p>在控制台测试时，我们可以直接使用<code>$()</code>和<code>$$()</code>直接代<code>document.querySelector()</code>和<code>document.querySelectorAll()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#target&apos;)</span><br><span class="line">--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;</span><br><span class="line">$$(&apos;#target&apos;)</span><br><span class="line">--&gt; [p#target]</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee1ed3314c7?w=600&amp;h=145&amp;f=jpeg&amp;s=14664" alt=""><br>可以自己写个方法，让<code>$()</code>和<code>$$()</code>可以在代码编辑器中直接使用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//写个方法：</span><br><span class="line">function $(selector)&#123;</span><br><span class="line">   return document.querySelector(selector)</span><br><span class="line">&#125;</span><br><span class="line">--&gt; undefined</span><br><span class="line">//即下面就可以在编辑器大胆使用$() 和 $$()，举几个例子：</span><br><span class="line">$(&apos;#target&apos;)</span><br><span class="line">--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;</span><br><span class="line">$(&apos;.box&apos;)</span><br><span class="line">--&gt; &lt;div class=&quot;box&quot;&gt;…&lt;/div&gt;</span><br><span class="line">$(&apos;.box .child&apos;)</span><br><span class="line">--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（5）<code>getElementsByTagName()</code><br><code>document.getElementsByTagName()</code></p><p>此方法返回所有指定标签的元素（搜索范围包括本身），返回值是一个<code>HTMLCollection</code>对象，也就是说，搜索结果是一个动态集合，任何元素的变化都会实时反映在返回的集合中。如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee156afc964?w=600&amp;h=360&amp;f=jpeg&amp;s=50471" alt=""></p><h3 id="3、创建元素"><a href="#3、创建元素" class="headerlink" title="3、创建元素"></a>3、创建元素</h3><p>（1）<code>createElement()</code> 创建一个新的元素放到页面上</p><p>用此方法创建并传入html的元素标签，创建一个<strong>虚拟的dom</strong>。该dom的节点存在内存里，并没有放在页面上，用户看不见。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(&apos;div&apos;)</span><br><span class="line">--&gt; &lt;div&gt;&lt;/div&gt;</span><br><span class="line">//可赋值一个变量，之后可通过该变量轻松获取</span><br><span class="line">var div = document.createElement(&apos;div&apos;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">div</span><br><span class="line">--&gt; &lt;div&gt;&lt;/div&gt;</span><br><span class="line">var div = document.createElement(&apos;img&apos;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">div</span><br><span class="line">--&gt;  &lt;img&gt;</span><br></pre></td></tr></table></figure></p><p>（2）<code>createTextNode()</code><br>光出现元素标签还不够，我们可通过<code>createTextNode()</code>去创建（或生成）一个文本，将文本的内容放入元素中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = document.createTextNode(&apos;wangxiaoqin&apos;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">text</span><br><span class="line">--&gt; &quot;wangxiaoqin&quot;</span><br></pre></td></tr></table></figure></p><p>（3）<code>createDocumentFragment()</code><br>该方法用来生成一个存在于内存的dom片段，但不属于当前文档。即不会生成一个标签，虚拟生成，常用于生成复杂的dom结构，然后插入当前文档。</p><p>正因为它不属于当前文档，所以并不参与页面的渲染加载的过程，它的任何改动都不会引发网页的重新渲染。比直接修改当前文档的DOM有更好的性能表现。</p><h3 id="4、修改元素"><a href="#4、修改元素" class="headerlink" title="4、修改元素"></a>4、修改元素</h3><p>（1）<code>appendChild()</code><br>在元素末尾添加元素。把一个dom对象放入在另外一个对象的内部作为它的孩子</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var newDiv = document.createElement(&quot;div&quot;)</span><br><span class="line">var newContent = document.createTextNode(&quot;Hello&quot;)</span><br><span class="line">newDiv.appendChild(newContent)//括号内为新添加的“孩子”</span><br><span class="line">--&gt; &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><p>看一个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//选择该容器ul，获取指定元素</span><br><span class="line">var navbarNode = document.querySelector(&apos;.navbar&apos;)</span><br><span class="line"></span><br><span class="line">for(var i=0;i&lt;5;i++)&#123;//以下循环5此</span><br><span class="line">  //创建一个子元素li</span><br><span class="line">  var child = document.createElement(&apos;li&apos;)</span><br><span class="line">  //创建一个文本，参数为字符串</span><br><span class="line">  var text = document.createTextNode(&apos;hello&apos;+i)</span><br><span class="line">  //修改元素</span><br><span class="line">  child.appendChild(text)</span><br><span class="line">  //然后再把li放在我们的navbarNode里</span><br><span class="line">  navbarNode.append(child)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ee9556d0cf5?w=600&amp;h=186&amp;f=jpeg&amp;s=60588" alt=""></p><p><strong>另一种方法：</strong> 使用<code>appendChild()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//选择该容器ul，获取指定元素</span><br><span class="line">var navbarNode = document.querySelector(&apos;.navbar&apos;)</span><br><span class="line"></span><br><span class="line">//创建一个虚拟的片段，可看成是一个虚拟标签，到最后放在navbarNode，该虚拟标签消失</span><br><span class="line">var fragment =document.createDocumentFragment()</span><br><span class="line">for(var i=0;i&lt;5;i++)&#123;//以下循环5此</span><br><span class="line">  //创建一个子元素li</span><br><span class="line">  var child = document.createElement(&apos;li&apos;)</span><br><span class="line">  //创建一个文本，参数为字符串</span><br><span class="line">  var text = document.createTextNode(&apos;helloo&apos;+i)</span><br><span class="line">  //修改元素</span><br><span class="line">  child.appendChild(text)</span><br><span class="line">  //然后再把li放在我们的frgment这个虚拟片段里</span><br><span class="line">  fragment.appendChild(child)</span><br><span class="line">&#125;</span><br><span class="line">//再将这个片段放在navbarNode里</span><br><span class="line">navbarNode.appendChild(fragment)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ef4fe597938?w=600&amp;h=287&amp;f=jpeg&amp;s=84499" alt=""><br>在控制台我们可以看到：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ef86eb33743?w=600&amp;h=358&amp;f=jpeg&amp;s=50780" alt=""><br>再回看JS代码，则可以知道，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fragment =document.createDocumentFragment()</span><br></pre></td></tr></table></figure></p><p>这里创建的这个虚拟片段，我们可看成是一个<strong>虚拟标签</strong>，到最后放在<code>navbarNode</code>，该虚拟标签消失。并不影响实际页面元素的改动。</p><p>假设：我们在<code>createDocumentFragment()</code>里加上一个实际的块元素包裹li，那么则不符合页面的规则，如：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530efdfedda277?w=600&amp;h=246&amp;f=jpeg&amp;s=79846" alt=""><br>控制台则如：这显然不符合规则<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530f0156774416?w=600&amp;h=352&amp;f=jpeg&amp;s=51657" alt=""></p><p>（2）<code>insertBefore()</code><br>在某个元素之前插入元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var newDiv = document.createElement(&quot;div&quot;)</span><br><span class="line">var newContent = document.createTextNode(&quot;Hello&quot;)</span><br><span class="line">newDiv.insertBefore(newContent, newDiv.firstChild)</span><br></pre></td></tr></table></figure></p><p>（3）<code>replaceChild()</code><br><code>replaceChild()</code>接受两个参数：要插入的元素和要替换的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newDiv.replaceChild(newElement, oldElement)</span><br></pre></td></tr></table></figure><h3 id="5、删除元素"><a href="#5、删除元素" class="headerlink" title="5、删除元素"></a>5、删除元素</h3><p><code>removeChild()</code>  用于删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.removeChild(childNode)</span><br></pre></td></tr></table></figure></p><p>6、<code>clone</code>元素<br>克隆一个完成的dom节点。<br>方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.cloneNode(true)</span><br></pre></td></tr></table></figure></p><h1 id="四、属性的操作（即修改dom元素的属性的操作方法）"><a href="#四、属性的操作（即修改dom元素的属性的操作方法）" class="headerlink" title="四、属性的操作（即修改dom元素的属性的操作方法）"></a>四、属性的操作（即修改dom元素的属性的操作方法）</h1><h3 id="1、getAttribute"><a href="#1、getAttribute" class="headerlink" title="1、getAttribute()"></a>1、<code>getAttribute()</code></h3><p>（现有页面中有一个图片地址，所对应的是一个src的地址，如果更换图片，则需要修改src对应的值。（或获取一个img的src，或a链接的href））用于获取元素的属性值，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.getAttribute(&apos;id&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="2、createAttribute-【一般用不到，一般不创建】"><a href="#2、createAttribute-【一般用不到，一般不创建】" class="headerlink" title="2、createAttribute()     【一般用不到，一般不创建】"></a>2、<code>createAttribute()</code>     【一般用不到，一般不创建】</h3><p>用于创建（或获取）属性名，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attribute = document.createAttribute(name)//参数name，是属性的名称</span><br></pre></td></tr></table></figure></p><h3 id="3、setAttribute"><a href="#3、setAttribute" class="headerlink" title="3、setAttribute()"></a>3、<code>setAttribute()</code></h3><p>用于设置属性和值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var node = document.getElementById(&quot;div1&quot;);</span><br><span class="line">node.setAttribute(&quot;my_attrib&quot;, &quot;newVal&quot;);  //括号中为“属性名+值”</span><br></pre></td></tr></table></figure></p><h3 id="4、removeAttribute"><a href="#4、removeAttribute" class="headerlink" title="4、removeAttribute()"></a>4、<code>removeAttribute()</code></h3><p>用于删除对应属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.removeAttribute(&apos;id&apos;)</span><br></pre></td></tr></table></figure></p><p>页面范例展示涉及到的点：</p><p>（1）查找、修改、获取、删除a链接的属性（这里为id）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var link = document.querySelector(&apos;a&apos;)</span><br><span class="line">link</span><br><span class="line">   &lt;a href=&quot;#&quot;&gt;wanxgiaoqin&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//可以创建 a链接的id属性值</span><br><span class="line">link.setAttribute(&apos;id&apos;,&apos;login&apos;)</span><br><span class="line"></span><br><span class="line">//以此类推，可以修改它的id</span><br><span class="line">link.setAttribute(&apos;id&apos;,&apos;logout&apos;)</span><br><span class="line">//可以获取（或添加）它的id</span><br><span class="line">link.getAttribute(&apos;id&apos;)</span><br><span class="line">//可以删除它的id</span><br><span class="line">link.removeAttribute(&apos;id&apos;)</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530f737f704d9f?w=600&amp;h=329&amp;f=jpeg&amp;s=80648" alt=""></p><p>（2）创建一个样式放在页面上，如何操作？</p><p>如：使用js让我们的页面上引入一个新的js，如jquery。可先在<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">Bootstrap 中文网开源项目免费CDN加速服务</a>上找一个jquery的地址</p><p>分析：用js引用一个jQuery，那么需要有一个scirpt的标签，用src来指向jQuery地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//创建一个script标签</span><br><span class="line">var script = document.createElement(&apos;script&apos;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">script </span><br><span class="line">&lt;script&gt;&lt;/script &gt; </span><br><span class="line"></span><br><span class="line">//设置元素的属性和值</span><br><span class="line">script .setAttribute(&apos;src&apos;,&apos;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&apos;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">//验证一下</span><br><span class="line">script</span><br><span class="line">--&gt; &lt;script  src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; </span><br><span class="line"></span><br><span class="line">//通过.body.appendChild(script)将整个标签属性值放置到页面</span><br><span class="line">document.body.appendChild(script)</span><br><span class="line">--&gt; &lt;script  src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; </span><br><span class="line">//使用jquery</span><br><span class="line">$</span><br><span class="line">--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125;</span><br><span class="line">jQuery</span><br><span class="line">--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5、innerHTML-VS-innerText"><a href="#5、innerHTML-VS-innerText" class="headerlink" title="5、innerHTML VS innerText"></a>5、<code>innerHTML</code> VS <code>innerText</code></h3><p>（1）<code>innerHTML</code><br>假设获取了一个dom元素，想知道页面中的html元素是什么，或者放入很多东西（不通过创建dom节点的方式<code>appendChild</code>进去）页面的一些菜单栏设置，通过后台要数据，后台交还一个数组或json数据（包括菜单的所有信息），如何将菜单渲染到页面上？通过字符串操作遍历对象（或数组）去拼装html字符串，拼接后一次性将html放置在空的节点下，则页面看到了东西</p><p>几个操作：Ajax获取数据——数据到来之后拼接html字符串（遍历、相加）——通过<code>innerHtml</code>方法将包含菜单信息的html字符串放在页面上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//数组的值渲染做成一个菜单</span><br><span class="line">var navbarDate =[1,2,3]</span><br><span class="line">//写一个空字符串，去拼接字符串的html</span><br><span class="line">var html =&apos; &apos;</span><br><span class="line">//遍历这个数组</span><br><span class="line">navbarDate.forEach(function(item)&#123;</span><br><span class="line">     html +=&apos;&lt;li&gt;&apos;+item+&apos;&lt;/li&gt;&apos;   //将数组三个数拼在一起</span><br><span class="line">&#125;)</span><br><span class="line">--&gt; undefined</span><br><span class="line">html</span><br><span class="line">--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot;  //无需换行，只需要拼接处html字符串即可</span><br><span class="line"></span><br><span class="line">//可将生成的html字符串放在.navbar</span><br><span class="line">document.querySelector(&apos;.navbar&apos;).innnerHTML = html</span><br><span class="line">--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot; </span><br><span class="line">document.querySelector(&apos;.navbar&apos;)</span><br><span class="line">--&gt; &lt;div class=&quot;navbar&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530fd2d966f8f1?w=600&amp;h=738&amp;f=jpeg&amp;s=160674" alt=""></p><p>（2）<code>innerText</code><br>看看所设置的元素标签下文本是什么（或设置它的文本）</p><p><strong>注：</strong> 没有必要再创建什么元素标签，只需要设置一个空标签，然后设置它的<code>innerText</code></p><p>续上面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.navbar&apos;).innerText //作html去执行</span><br><span class="line">--&gt;&quot;1</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    &quot;</span><br></pre></td></tr></table></figure></p><p>假如代码是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.navbar&apos;).innerText = html   //呈现给用户</span><br></pre></td></tr></table></figure></p><p>则将展示文本设置在页面上，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530fe24523eb59?w=600&amp;h=320&amp;f=jpeg&amp;s=81669" alt=""></p><h1 id="五、常见的使用方式"><a href="#五、常见的使用方式" class="headerlink" title="五、常见的使用方式"></a>五、常见的使用方式</h1><h3 id="1、修改样式"><a href="#1、修改样式" class="headerlink" title="1、修改样式"></a>1、修改样式</h3><p>可修改元素的style属性，修改结果直接反映到页面元素（不过，由于CSS权重的关系，虽然控制台修改dom节点上的style属性与页面上的一一对应，但如果权重比不够，修改的结果也不一定生效）<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//dom元素的style属性上的 XXX与页面上一一对应</span><br><span class="line">document.querySelector(&apos;p&apos;).style.color = &apos;red&apos;  //选中对应元素，和修改对象+属性</span><br><span class="line">document.querySelector(&apos;.box&apos;).style.backgroundColor = &apos;#ccc&apos;</span><br></pre></td></tr></table></figure></p><h3 id="2、获取样式-getComputedStyle"><a href="#2、获取样式-getComputedStyle" class="headerlink" title="2、获取样式   getComputedStyle"></a>2、获取样式   getComputedStyle</h3><p>不是获取元素的style属性，而是元素计算后的样式（包括其他地方做的设置、浏览器默认样式、继承样式等综合后的结果）。即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var node = document.querySelector(&apos;p&apos;)</span><br><span class="line">var color = window.getComputedStyle(node).color  //可直接使用，它是处在win的一个全局变量属性</span><br><span class="line">console.log(color)</span><br></pre></td></tr></table></figure></p><p>如在控制台想要获取页面dom元素的字体大小,如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getComputedStyle(document.querySelector(&apos;#hello&apos;))  //获取的是相对应的对象，通过对象获取对应的style对应的属性</span><br><span class="line">getComputedStyle(document.querySelector(&apos;#hello&apos;))[&apos;font-size&apos;]//即获取字体大小</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">getComputedStyle(document.querySelector(&apos;#hello&apos;)).fontSize</span><br></pre></td></tr></table></figure></p><h3 id="3、class操作"><a href="#3、class操作" class="headerlink" title="3、class操作"></a>3、class操作</h3><p>当使用样式操作时，涉及到一些样式的切换，可以直接去修改它的style，但这样比较细，且复杂。假设当我们在页面点击一个按钮时，整体发生一个很大的变化（包括字体大小、出现的边框、背景色、背景图片，甚至动画效果），如果都是用style来操作，或导致代码冗长难修改，我们可以将这些样式放在一个css的class里面，如<code>active</code>。正常情况下是没有这些class，当我们点击某个元素的时候，即鼠标放上去时，给这个元素添加一个class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var nodeBox = document.querySelector(&apos;.box&apos;)</span><br><span class="line">console.log( nodeBox.classList ) //通过选择元素nodeBox去看看classList里拥有哪些class，</span><br><span class="line">     //即得到一个类数组对象.通过下标的方式获取class</span><br><span class="line">nodeBox.classList.add(&apos;active&apos;)      //新增 class</span><br><span class="line">nodeBox.classList.remove(&apos;active&apos;)   //删除 class</span><br><span class="line">nodeBox.classList.toggle(&apos;active&apos;)   //新增/删除切换</span><br><span class="line">node.classList.contains(&apos;active&apos;)    // 判断是否拥有 class</span><br></pre></td></tr></table></figure></p><p>如图：<a href="http://js.jirengu.com/ponaz/1/edit?html,css,js,output" target="_blank" rel="noopener"></a><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ff413b18abc?w=600&amp;h=313&amp;f=jpeg&amp;s=107778" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16530ff6b4059337?w=599&amp;h=161&amp;f=gif&amp;s=4846149" alt=""><br>class操作，不用担心class的数量有多少，无需担心同名、正则，只需要采用这种原生JS的API就能操作页面dom元素</p><h3 id="4、页面宽高的计算"><a href="#4、页面宽高的计算" class="headerlink" title="4、页面宽高的计算"></a>4、页面宽高的计算</h3><p>（1）<code>element.clientHeight</code> VS  <code>element.clientWidth</code><br>获取元素窗口的高度、宽度<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531007d14916f8?w=411&amp;h=247&amp;f=jpeg&amp;s=41419" alt=""></p><p>（2）<code>element.offsetHeight</code> VS  <code>element.offsetWidth</code><br>获取（包含边框+内边距+窗口整体）的高度、宽度<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653100f5f4f6d88?w=411&amp;h=247&amp;f=jpeg&amp;s=41377" alt=""><br>获取两种的宽高，得到的结果看具体情况，有些时候是相同，有些时候是不同，如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653101a47f12dee?w=600&amp;h=315&amp;f=jpeg&amp;s=113276" alt=""></p><p>（3）<code>element.scrollHeight</code><br>元素滚动内容的总长度，也分实际情况<br>假设页面上有一处包含内容的div块级，页面若为可滚动的，表示内容长度超出它容器的高度，而容器高度已为固定宽高，此时<code>scrollHeight</code>＞<code>clientHeight</code><br>若页面若无滚动条、父容器高度没有固定，则<code>scrollHeight</code>=<code>clientHeight</code>=<code>offsetHeight</code></p><p>（4）<code>element.scrollTop</code><br>获取元素滚动的高度，即滚动时滚动了一定的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.scrollTop</span><br></pre></td></tr></table></figure></p><p>（5）<code>window.innerHeight</code><br>窗口的高度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.innerHeigh</span><br></pre></td></tr></table></figure></p><p>实例操作：<a href="http://js.jirengu.com/fuser/1/edit?html,css" target="_blank" rel="noopener">http://js.jirengu.com/fuser/1/edit?html,css</a><br><img src="https://user-gold-cdn.xitu.io/2018/8/13/165311083544da93?w=600&amp;h=349&amp;f=jpeg&amp;s=80569" alt=""></p><p>以下问题跟之后的解决懒加载有密切联系</p><p>问题1：如何去判断一个元素是否出现在窗口的视野中</p><p>问题2：如何判断页面滚动到底部</p><p>元素到顶点的值=滚动的值</p><p>元素滚动的距离+窗口的高度=这个元素到顶点的距离</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、DOM&quot;&gt;&lt;a href=&quot;#一、DOM&quot; class=&quot;headerlink&quot; title=&quot;一、DOM&quot;&gt;&lt;/a&gt;一、DOM&lt;/h1&gt;&lt;h3 id=&quot;1、定义&quot;&gt;&lt;a href=&quot;#1、定义&quot; class=&quot;headerlink&quot; title=&quot;1、定义&quot;&gt;&lt;/a&gt;1、定义&lt;/h3&gt;&lt;p&gt;DOM，即文档对象模型（Document Object Model ）&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="DOM元素" scheme="http://yoursite.com/tags/DOM%E5%85%83%E7%B4%A0/"/>
    
      <category term="DOM操作" scheme="http://yoursite.com/tags/DOM%E6%93%8D%E4%BD%9C/"/>
    
      <category term="Element对象" scheme="http://yoursite.com/tags/Element%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：08 setTimeout和任务队列</title>
    <link href="http://yoursite.com/2018/08/17/34-08%20setTimeout%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/17/34-08 setTimeout和任务队列/</id>
    <published>2018-08-16T17:01:04.000Z</published>
    <updated>2018-08-16T17:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>之前写过一次被不小心删掉了，幸好思路和参考资料还在，所以赶快写下来。里面涉及了一点点dom事件的操作（但不影响学习）。</p><hr><h1 id="一、什么是定时器"><a href="#一、什么是定时器" class="headerlink" title="一、什么是定时器"></a>一、什么是定时器</h1><p>JS提供定时执行代码功能，叫做定时器（timer），主要由<code>etTimeout()</code>和<code>setInterval()</code>这两个函数来完成。<code>setTimeout()</code>和<code>setInterval()</code>是windows的两个全局属性。<br><a id="more"></a></p><h1 id="二、setTimeout"><a href="#二、setTimeout" class="headerlink" title="二、setTimeout()"></a>二、<code>setTimeout()</code></h1><p>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timerId = setTimeout(func|code, delay)//括号里代表（函数|代码字符串，延迟的时间毫秒数）</span><br></pre></td></tr></table></figure></p><p>先写一个函数，在通过setTimeout调用函数，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(f,1000) //表示在1s之后执行这个函数</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function ()&#123;console.log(2)&#125;,1000)//通过使用并调用执行该匿名函数</span><br></pre></td></tr></table></figure></p><p>如：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/16528044d6204e9e?w=600&amp;h=418&amp;f=jpeg&amp;s=81634" alt=""></p><p>使用setTimeout，连续几次之后，发现一个现象，返回了类似于有序的编号整数。这是由于setTimeout本身执行的时候，里面的函数返回值可认为返回的是一个定时器的id（或编号），当我们执行setTimeout，浏览器则会创建一个延时器（即一个对象），该延时器的返回则是一个编号。那么，这样的话，我们可以通过编号找到相对应的定时器<br>续上面例子，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var timer = setTimeout(function()&#123;</span><br><span class="line">   console.log(&apos;wangxiaoqin&apos;)</span><br><span class="line">&#125;,10000)</span><br><span class="line">--&gt; undefined</span><br><span class="line">timer</span><br><span class="line">--&gt; 419</span><br><span class="line">    wangxiaoqin //若不做任何操作，1s后返回这个字符串</span><br><span class="line"></span><br><span class="line">clearTimeout(timer) //表示还未执行，该定时器就被取消操作</span><br><span class="line">clearTimeout(422)  //表示提前取消编号为XXX的定时器</span><br></pre></td></tr></table></figure></p><h1 id="三、setInterval"><a href="#三、setInterval" class="headerlink" title="三、setInterval()"></a>三、<code>setInterval()</code></h1><p>用法与setTimeout一样，区别在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。即间隔执行任务。</p><p>1、如每隔1s执行一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">var timer = setInterval(function() &#123;</span><br><span class="line">  console.log(i++);</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652819cc9ef969e?w=600&amp;h=258&amp;f=gif&amp;s=104136" alt=""></p><p>2、可用来做一个时钟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">var timer = setInterval(function()&#123;</span><br><span class="line">   console.log(new Date());</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/165281a24eddc57f?w=599&amp;h=204&amp;f=gif&amp;s=4312401" alt=""></p><h1 id="四、clearTimeout-，clearInterval"><a href="#四、clearTimeout-，clearInterval" class="headerlink" title="四、clearTimeout()，clearInterval()"></a>四、<code>clearTimeout()</code>，<code>clearInterval()</code></h1><p>setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var id1 = setTimeout(f,1000);</span><br><span class="line">var id2 = setInterval(f,1000);</span><br><span class="line"></span><br><span class="line">clearTimeout(id1);</span><br><span class="line">clearInterval(id2);</span><br></pre></td></tr></table></figure></p><h1 id="五、从setTimeout-f-0-引发的关于JS运行环境的探究"><a href="#五、从setTimeout-f-0-引发的关于JS运行环境的探究" class="headerlink" title="五、从setTimeout(f,0)引发的关于JS运行环境的探究"></a>五、从<code>setTimeout(f,0)</code>引发的关于JS运行环境的探究</h1><p>我们先看这样一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">     console.log(1);</span><br><span class="line"> &#125;,0);</span><br><span class="line"> console.log(2)</span><br><span class="line">--&gt;2</span><br><span class="line">   1 //0s后，返回</span><br></pre></td></tr></table></figure></p><p>为什么会先返回2，再返回1呢？（先留着疑问）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var isOk = true   //第1：首先声明变量isOk，默认为true</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  isOk = false</span><br><span class="line">&#125;,1000)   //异步回调：需要1秒之后，才能将 isOk 设为 false（1s后才执行，所以暂不执行）</span><br><span class="line">  </span><br><span class="line"> while(isOk)&#123;</span><br><span class="line">   console.log(2)</span><br><span class="line"> &#125;      //第2：先进行while循环判断，isOk是否为true，如果是，那么就是返回console(2)的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第4：当过了1s后，代码执行，isOK = false，就会停止执行</span><br></pre></td></tr></table></figure></p><p>是不是稍微有点明白？<br>简单的例子里其实涉及到了JS运行中的很多方面，让我们详细看看</p><blockquote><p>关键词：JS运行环境、事件循环、异步回调</p></blockquote><h3 id="1、单线程模型"><a href="#1、单线程模型" class="headerlink" title="1、单线程模型"></a>1、单线程模型</h3><blockquote><p>这里截取阮一峰老师的JavaScript的教程中的单线程描述</p></blockquote><p>单线程模型指的是，JavaScript只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p><p>JavaScript 只在一个线程上运行，不代表JavaScript引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。为了避免复杂性，JavaScript一开始就是单线程，已成为这门语言的核心特征，将来也不会改变。</p><h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>涉及到单、多线程，这里截取李佳怡专栏文章中关于线程的描述</p><p>（1）定义<br>浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器通常由以下常驻线程组成：GUI渲染线程，javascript引擎线程，浏览器事件触发线程，定时触发器线程，异步 http 请求线程。</p><p>（2）常驻线程</p><ul><li><p>GUI 渲染线程：负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”。即 GUI 渲染线程与 JS 引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p></li><li><p>javascript 引擎线程：也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。</p></li><li><p>浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待 JS 引擎处理。</p></li><li><p>定时触发器线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 javaScript 引擎是单线程的,如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p></li><li><p>异步 http 请求线程：在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p></li></ul><h3 id="3、了解一下JS的V8运行环境"><a href="#3、了解一下JS的V8运行环境" class="headerlink" title="3、了解一下JS的V8运行环境"></a>3、了解一下JS的V8运行环境</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/165281fe05e42870?w=600&amp;h=546&amp;f=jpeg&amp;s=65131" alt=""><br>主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（<code>click</code>，<code>load</code>，<code>done</code>）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。<br><strong>注：假设这段话暂时看不明白，暂时放掉，先了解下面的其他知识，完毕之后再回看这段话，就能明白。</strong></p><blockquote><p>说说图中的几个关键名词</p></blockquote><p><strong>（1）堆（heap）</strong><br>对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。</p><p><strong>（2）栈（stack）</strong><br>函数调用形成了一个栈帧。</p><p>而通过使用js 调用栈（call stack）则能更清晰地了解单线程的执行过程。</p><p><strong>js 调用栈（call stack）：</strong><br>函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数，这种数据结构的关键在于【后进先出】，即 <code>LIFO（last-in，first-out）</code>。</p><p><strong>第一个例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function multiply(a,b)&#123;</span><br><span class="line">  return a*b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function square(n)&#123;</span><br><span class="line">  return multiply(n,n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printSquare(n)&#123;</span><br><span class="line">  var squared = square(n);</span><br><span class="line">  console.log(squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSquare(4)</span><br><span class="line"></span><br><span class="line">//一个将两个数字相乘的函数multiply，一个调用了前者的平方函数square,</span><br><span class="line">//一个打印函数printSquare，它调用了square，然后将结果用console.log打印出来</span><br><span class="line">//然后最后我们调用了printSquare</span><br><span class="line"></span><br><span class="line">//运行</span><br><span class="line">//调用栈（callback），基本上是一个记录当前程序所在位置的数据结构。如果当前进入了某个函数，</span><br><span class="line">//这个函数就会被放在栈里面。如果当前离开了某个函数，这个函数就会被弹出栈外，这是栈所做的事。</span><br><span class="line"></span><br><span class="line">//如果你运行这个文件，将会有一个类似main的函数，指代文件本身，首先，把它放进栈中。</span><br><span class="line">//接着，我们从上到下查看了声明的函数，看到了最后是printSquare，知道了它被调用了，</span><br><span class="line">//那么我们把它推进栈里；它调用了square，所以也把square推进栈里；square也调用了mulitiply，</span><br><span class="line">//同样把mulitiply推进栈中，最后，我们得到了mulitiply的返回值</span><br><span class="line"></span><br><span class="line">//那么这之后，我们把multiply弹出栈，然后square也得到了返回值，再把square弹出栈，</span><br><span class="line">//最后到了printSquare，它调用了console.log，到这里已经没有返回值。我们到了函数的最后部分，</span><br><span class="line">//然后我们完成了。</span><br></pre></td></tr></table></figure></p><p><strong>第二个例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(b) &#123;</span><br><span class="line">    var a = 12;</span><br><span class="line">    return a + b + 35;</span><br><span class="line">&#125;</span><br><span class="line">function g(x) &#123;</span><br><span class="line">    var m = 4;</span><br><span class="line">    return f(m * x);</span><br><span class="line">&#125;</span><br><span class="line">g(21);</span><br></pre></td></tr></table></figure></p><p>调用 g 函数 的时候，创建了第一个 堆( Heap ) 栈(stack) 帧 ，包含了 g 的参数和局部变量。当g调用f的时候，第二个堆栈帧就被创建、并置于第一个 堆栈帧 之上，包含了 f 的参数和局部变量。当 f 返回时，最上层的 堆栈帧 就出栈了（剩下g函数调用的堆栈帧）。当g返回的时候，栈就空了。</p><p><strong>第三个例子:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;,1000);</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p><p>在执行函数 test 的时候，test先入栈，如果不给<code>alert(1)</code>加setTimeout，那么 <code>alert(1)</code>第2个入栈，最后是<code>alert(2)</code>。但现在给<code>alert(1)</code>加上 setTimeout后，<code>alert(1)</code>就被加入到了一个新的堆栈中等待，并1s后执行，因此实际的执行结果就是先 <code>alert(2)</code>，再 <code>alert(1)</code>。</p><p><strong>（3）队列（queue）</strong><br>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都有一个为了处理这个消息相关联的函数。</p><h3 id="任务队列（消息队列）："><a href="#任务队列（消息队列）：" class="headerlink" title="任务队列（消息队列）："></a>任务队列（消息队列）：</h3><p>任务（消息）队列是一个先进先出的队列，它里面存放着各种任务（消息）</p><p><strong>A、同步任务VS异步任务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;Hi&apos;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(&apos;There&apos;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">console.log(&apos;wangxiaoqin&apos;)</span><br></pre></td></tr></table></figure></p><ul><li><p>同步函数：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;Hi’);   /*函数返回时，就看到了预期的效果：在控制台打印了一个字符串*/</span><br></pre></td></tr></table></figure></li><li><p>异步函数：即如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn, 1000);</span><br><span class="line">/*setTimeout是异步过程的发起函数，fn是回调函数*/</span><br></pre></td></tr></table></figure></li><li><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p></li><li><p>异步任务：主线程发起一个异步请求（即执行异步函数），相应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到任务（消息）队列，主线程通过事件循环过程去取任务（消息），然后执行一定的动作(调用回调函数)。看此图可视化描述：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652827e31d9e013?w=294&amp;h=270&amp;f=jpeg&amp;s=11088" alt=""></p></li></ul><p><strong>B、事件循环（Event loop）</strong><br>事件循环，指主线程重复从任务（消息）队列中取任务（消息）、执行的过程。取一个任务（消息）并执行的过程叫做一次循环。<br>即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;   //如果当前没有任何消息queue.waitForMessage 会等待同步消息到达</span><br></pre></td></tr></table></figure></p><p>事件循环中有事件两个字的原因：任务（消息）队列中的每条消息实际上都对应着一个事件——dom事件。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElement(&apos;#btn&apos;);</span><br><span class="line">button.addEventListener(&apos;click&apos;,function(e) &#123;</span><br><span class="line">      console.log();</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></p><p>从异步过程的角度看，addEventListener 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。那么添加的这个任务（消息）事实上就是任务注册异步任务时添加的回调函数。如果 一个异步函数没有回调，那么它就不会放到任务（消息）队列里。</p><p><strong>总结：主线程在执行完当前循环中的所有代码</strong>后，就会到任务（消息）队列取出一条消息，并执行它。到此为止，<strong>就完成了工作线程对主线程的通知，回调函数也就得到了执行。</strong>如果一开始主线程就没有提供回调函数，工作线程就没必要通知主线程，从而也没必要往消息队列放消息。如图：</p><blockquote><p>了解一下工作线程（即异步 http 请求线程，即 Ajax 线程）是如何工作：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652824a98cfba5d?w=600&amp;h=334&amp;f=jpeg&amp;s=32439" alt=""></p><h3 id="4、再来看setTimeout-f-0-所带来的零延迟与事件循环、任务队列的联系"><a href="#4、再来看setTimeout-f-0-所带来的零延迟与事件循环、任务队列的联系" class="headerlink" title="4、再来看setTimeout(f,0)所带来的零延迟与事件循环、任务队列的联系"></a>4、再来看setTimeout(f,0)所带来的零延迟与事件循环、任务队列的联系</h3><p>setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。</p><p>什么意思呢？</p><p><strong>setTimeout的作用是，</strong>将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么不会立刻执行。这里则涉及到了零延迟。</p><p><strong>零延迟 (Zero delay) </strong>并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。也就是说，<code>setTimeout()</code>只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在<code>setTimeout()</code>指定的时间执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">     console.log(1);</span><br><span class="line"> &#125;,0);</span><br><span class="line"> console.log(2)</span><br><span class="line">--&gt;2</span><br><span class="line">   1 //0s后，返回</span><br></pre></td></tr></table></figure></p><p>现在我们知道为什么返回结果是2，1。因为只有在执行完主线程的所有代码之后，主线程空了，才会去任务队列中取任务执行回调函数，去执行回调函数。<br><strong>总结：</strong> <code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到主线程把同步任务和”任务队列”现有的事件都处理完，才会得到执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">console.log(i)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652825f9c4d804b?w=600&amp;h=109&amp;f=jpeg&amp;s=8991" alt=""></p><p>相当于<code>for(var i=0; i&lt;10; i++)</code>这个同步代码执行完之后，i的值变为10 。此时（1s后），执行回调函数，在同步任务中创建了10个定时器均在1s中之后执行，则返回了10</p><p>由此看来，在某种程度上，我们可以利用<code>setTimeout(fn,0)</code>的特性，修正浏览器的任务顺序。</p><h3 id="参考、学习并感谢："><a href="#参考、学习并感谢：" class="headerlink" title="参考、学习并感谢："></a>参考、学习并感谢：</h3><blockquote><p>1.MDN：并发模型与事件循环</p></blockquote><blockquote><p>2.阮一峰JavaScript参考教程：异步操作概述</p></blockquote><blockquote><p>3.李佳怡专栏：【 js 基础 】 setTimeout(fn, 0)的作用</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;之前写过一次被不小心删掉了，幸好思路和参考资料还在，所以赶快写下来。里面涉及了一点点dom事件的操作（但不影响学习）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一、什么是定时器&quot;&gt;&lt;a href=&quot;#一、什么是定时器&quot; class=&quot;headerlink&quot; title=&quot;一、什么是定时器&quot;&gt;&lt;/a&gt;一、什么是定时器&lt;/h1&gt;&lt;p&gt;JS提供定时执行代码功能，叫做定时器（timer），主要由&lt;code&gt;etTimeout()&lt;/code&gt;和&lt;code&gt;setInterval()&lt;/code&gt;这两个函数来完成。&lt;code&gt;setTimeout()&lt;/code&gt;和&lt;code&gt;setInterval()&lt;/code&gt;是windows的两个全局属性。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="异步加载" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="setTimeout" scheme="http://yoursite.com/tags/setTimeout/"/>
    
      <category term="任务队列" scheme="http://yoursite.com/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：07 正则表达式</title>
    <link href="http://yoursite.com/2018/08/17/33-07%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/17/33-07 正则表达式/</id>
    <published>2018-08-16T17:00:54.000Z</published>
    <updated>2018-08-16T17:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、意义"><a href="#一、意义" class="headerlink" title="一、意义"></a>一、意义</h1><p>用来判断用户输入是否符合某些特定规则，如检测判断用户所填信息是否为正确的手机号？正确的邮箱地址？以及在很多文本编辑器中，则更常用来检索、替换那些符合某个模式的文本。<br><a id="more"></a></p><h1 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h1><p>JS中的特定对象，用来指定某些规则，对字符串进行匹配，是否符合规则，或者将其结果拿出来检测是否匹配该结果。</p><h1 id="三、如何创建正则表达式"><a href="#三、如何创建正则表达式" class="headerlink" title="三、如何创建正则表达式"></a>三、如何创建正则表达式</h1><p>通过内置对象RegExp去支持正则表达式。如果我们想匹配字符串中<code>&lt;%xxx%&gt;</code>两个百分号分割的字符串可以这么写。创建正则表达式对象有两种方法：</p><h3 id="1、构造函数方法"><a href="#1、构造函数方法" class="headerlink" title="1、构造函数方法"></a>1、构造函数方法</h3><p><code>var reg=new RegExp(&#39;&lt;%[^%&gt;]+%&gt;&#39;,&#39;g&#39;);</code></p><p><strong>注：</strong> 正则表达式使用<code>new RegExp</code>方法，传递的是字符串，而正则表达式里还有一些参数，表示匹配之后需要遵循什么规则</p><h3 id="2-字面量方法"><a href="#2-字面量方法" class="headerlink" title="2.字面量方法"></a>2.字面量方法</h3><p><code>var reg=/&lt;%[^%&gt;]%&gt;/g;</code><br>注：</p><ul><li>g：<code>global</code>，全文搜索，不添加的话搜索到第一个结果停止搜索</li><li>i：<code>ingore case</code>，忽略大小写，默认大小写敏感</li><li>m：<code>multiple lines</code>，多行搜索</li></ul><h1 id="四、正则表达式如何表达"><a href="#四、正则表达式如何表达" class="headerlink" title="四、正则表达式如何表达"></a>四、正则表达式如何表达</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var reg = /hello/ig   //可看成reg创建了一个正则表达式的对象</span><br><span class="line">--&gt; undefined</span><br><span class="line">reg</span><br><span class="line">--&gt; /hello/gi   //对象，是控制台对一个对象特有的表达</span><br><span class="line">//事实上，reg不是一个字符串，而是一个对象，如下</span><br><span class="line">typeof reg</span><br><span class="line">--&gt;&quot;object&quot;</span><br><span class="line"></span><br><span class="line">//如何表示一个字符串</span><br><span class="line">var str = &apos;/hello/ig&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str</span><br><span class="line">--&gt; &quot;/hello/ig&quot;</span><br><span class="line">typeof str</span><br><span class="line">--&gt; &quot;string&quot;</span><br></pre></td></tr></table></figure><h1 id="五、正则表达式的其他概念"><a href="#五、正则表达式的其他概念" class="headerlink" title="五、正则表达式的其他概念"></a>五、正则表达式的其他概念</h1><p>正则表达式让人望而却步的重要原因是转义字符太多，导致组合出来的也非常多</p><p><strong>自我总结：</strong><br>正则表达式的匹配字符，在预设的字符串中通过正则的匹配字符进行检索，找出匹配该正则字符符合的参数/元素</p><h3 id="1、元字符"><a href="#1、元字符" class="headerlink" title="1、元字符"></a>1、元字符</h3><p>即正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符<br><code>( [ { \ ^ $ | ) ? * + .</code><br>比如我们返回一个带有元字符的正则表达式，需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = &apos;/\[h\]ello/ig&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">reg</span><br><span class="line">--&gt; &quot;/[h]ello/ig&quot;</span><br></pre></td></tr></table></figure></p><p>不是每个元字符都有特定的意义，在不同组合中元字符有不同意义：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652743e8ca0754e?w=600&amp;h=215&amp;f=jpeg&amp;s=20625" alt=""></p><h3 id="2、字符类-匹配"><a href="#2、字符类-匹配" class="headerlink" title="2、字符类 匹配"></a>2、字符类 匹配</h3><p>正则表达式表示一个字符串，匹配的是一个字符串中相应的字符,我们可以使用元字符[ ]构建一个简单的类，用来匹配某一类，<br>如匹配一个手机号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg =/[a-z]/ig</span><br><span class="line">/*或者*/</span><br><span class="line">var reg =/[abc01234]/ig</span><br><span class="line">//[a-z] 或[0-9]表示一个字符，-  表示一个范围和区间</span><br></pre></td></tr></table></figure></p><p>匹配一个数字（或大小写字母）<br><code>var reg =/[0-A9-c5-Bn-Z]/ig</code></p><h3 id="3、取反-匹配"><a href="#3、取反-匹配" class="headerlink" title="3、取反 匹配"></a>3、取反 匹配</h3><p><code>var reg =/[^abc01234]/ig</code><br><code>^</code>表示只要不是中括号里的参数中的任何一个，则都被选中</p><h3 id="4、预定义类-匹配"><a href="#4、预定义类-匹配" class="headerlink" title="4、预定义类 匹配"></a>4、预定义类 匹配</h3><p>即有没有符号代替数字或者非数字？如我们希望匹配一个可以是ab+数字+任意字符的字符串，就可以这样写了 <code>/ab\d./</code><br><code>var reg = /ab\d./</code></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652746c7d1761b0?w=600&amp;h=243&amp;f=jpeg&amp;s=33130" alt=""></p><h3 id="5、边界-匹配"><a href="#5、边界-匹配" class="headerlink" title="5、边界 匹配"></a>5、边界 匹配</h3><p>（1）区分一下<code>^</code>作为取反和边界匹配的差别</p><ul><li><p>如：取反匹配的表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//取反：匹配的是除了hello这个字符串之外的所有元素字符串，</span><br><span class="line">str.match(/[^hello]/g)  </span><br><span class="line">--&gt; (47) [&quot; &quot;, &quot;w&quot;, &quot;r&quot;, &quot;d&quot;, &quot; &quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot; &quot;, &quot;&quot;, &quot; &quot;, &quot;</span><br><span class="line">&quot;, &quot; &quot;, &quot;j&quot;, &quot;i&quot;, &quot;r&quot;, &quot;n&quot;, &quot;g&quot;, &quot;u&quot;, &quot; &quot;, &quot;↵&quot;, &quot; &quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;x&quot;, &quot;i&quot;, &quot;a&quot;, &quot;q&quot;, &quot;i&quot;, &quot;n&quot;, &quot; &quot;, &quot;↵&quot;, &quot; &quot;, &quot;n&quot;, &quot;i&quot;, &quot;a&quot;, &quot;s&quot;, &quot;i&quot;, &quot;j&quot;, &quot;i&quot;]</span><br></pre></td></tr></table></figure></li><li><p>如：边界匹配的表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//边界：匹配的是以hello开头的字符串</span><br><span class="line">str.match(/^hello/g)</span><br><span class="line">--&gt; [&quot;hello&quot;]</span><br><span class="line"></span><br><span class="line">//即我们会匹配这个hello，不过要通过此来验证该hello是否位于字符串的开头</span><br></pre></td></tr></table></figure></li></ul><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello world hello 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/^hello/g)</span><br><span class="line">--&gt; [&quot;hello&quot;]</span><br></pre></td></tr></table></figure></p><p>（2）匹配以XXX结尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.match(/hello$/g)</span><br><span class="line">--&gt; null  //未匹配上</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/hello3$/g)</span><br><span class="line">--&gt; [&quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/^hello\d/g)</span><br><span class="line">--&gt; [&quot;hello1&quot;]</span><br><span class="line">str.match(/hello\d/g)</span><br><span class="line">--&gt; (3) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p>（3）单词边界 匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d\b/g)</span><br><span class="line">--&gt; (3) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello1 whello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d\b/g)</span><br><span class="line">--&gt; (4) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;]  //以此可看出单词边界的一个标准，前后均有空格或者以下情况</span><br></pre></td></tr></table></figure></p><p>或者: <code>-</code>也为单词边界<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d/g)</span><br><span class="line">//注：这里右侧少了一个\b的边界匹配，返回如下：</span><br><span class="line">--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p>或者：<code>\t</code>也为单词边界<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;\thello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d\b/g)</span><br><span class="line">--&gt;(5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p><code>\r</code> 也为单词边界<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;\rhello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d\b/g)</span><br><span class="line">--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p><code>\n</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;\nhello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/\bhello\d\b/g)</span><br><span class="line">--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;]</span><br></pre></td></tr></table></figure></p><p>如何判断一个字符串中是否有某个单词（元素/参数）？（相当于一个class中是否包含某元素？），假设：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;header3 clearfix active header-fixed&apos;</span><br></pre></td></tr></table></figure></p><p>如如何求header这个单词？<br><strong>❌错误解法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;header3 clearfix active header-fixed&apos;</span><br><span class="line">--&gt;undefined</span><br><span class="line">str.match(/\bheader\b/g)</span><br><span class="line">--&gt; [&quot;header&quot;]  //系统默认第四个单词中的header</span><br></pre></td></tr></table></figure></p><p><strong>✅正确解法: </strong><br><code>|</code> 可以匹配空白字符 本身也可以作为开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;header3 clearfix active header-fixed&apos;</span><br><span class="line">--&gt;undefined</span><br><span class="line">str.match(/(^|\s)header($|\s)/g)</span><br><span class="line">--&gt; null  //没有匹配到任何东西</span><br><span class="line">var str = &apos;header3 clearfix active header-fixed header&apos;</span><br><span class="line">undefined</span><br><span class="line">str.match(/(^|\s)header($|\s)/g)</span><br><span class="line">--&gt; [&quot; header&quot;]  //从上一步，知道匹配到最后一个单词header</span><br></pre></td></tr></table></figure></p><h3 id="6、量词-匹配"><a href="#6、量词-匹配" class="headerlink" title="6、量词 匹配"></a>6、量词 匹配</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/11/165274b5caecc0a9?w=600&amp;h=237&amp;f=jpeg&amp;s=26924" alt=""><br>看一个字符串是否为url，该如何匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;http://wangxiaoqin.com&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">var str2 = &apos;https://wangxiaoqin.com&apos;</span><br><span class="line">--&gt;undefined</span><br><span class="line">str.match(/https?:\/\/.+/g) //s 这个字母后加 ? 表示出现零次或一次（最多出现一次）不管有没有出现都行</span><br><span class="line">                          //.  任意字符   +  多次</span><br><span class="line">--&gt; [&quot;http://wangxiaoqin.com&quot;]</span><br><span class="line">str2.match(/https?:\/\/.+/g)</span><br><span class="line">--&gt; [&quot;https://wangxiaoqin.com&quot;]</span><br><span class="line"></span><br><span class="line">//s出现多次，？无效   *有效  其他匹配字符</span><br><span class="line">var str3 = &apos;httpssssss://wangxiaoqin.com&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str3.match(/https?:\/\/.+/g)</span><br><span class="line">--&gt; null</span><br><span class="line">str3.match(/https*:\/\/.+/g)</span><br><span class="line">--&gt; [&quot;httpssssss://wangxiaoqin.com&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="7、实践"><a href="#7、实践" class="headerlink" title="7、实践"></a>7、实践</h3><p>（1）<strong>实践1：如何更精准地判断url？</strong></p><p>固定元素 <code>http://</code>、<code>https://</code>、<code>//</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str.match(/^(https?:)?\/\/.+/)   //(https?:)? ()里的表示可有可无</span><br><span class="line">--&gt; (2) [&quot;http://wangxiaoqin.com&quot;, &quot;http:&quot;, index: 0, input: &quot;http://wangxiaoqin.com&quot;, groups: undefined]</span><br><span class="line">str2.match(/^(https?:)?\/\/.+/)</span><br><span class="line">--&gt; (2) [&quot;https://wangxiaoqin.com&quot;, &quot;https:&quot;, index: 0, input: &quot;https://wangxiaoqin.com&quot;, groups: undefined]</span><br><span class="line">var str4 = &apos;//wangxiaoqin.com&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str4.match(/^(https?:)?\/\/.+/)</span><br><span class="line">--&gt; (2) [&quot;//wangxiaoqin.com&quot;, undefined, index: 0, input: &quot;//wangxiaoqin.com&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p><p>（2）<strong>实践2：如何判断用户的输入是手机号？</strong></p><p>假设：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str1 =&apos;15011112222&apos;</span><br><span class="line">--&gt;undefined</span><br><span class="line">var str2 =&apos;aaadd15011112222&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">var str3 =&apos;150111111222222555555&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">var str4 =&apos;150aaadd11112222&apos;</span><br><span class="line">--&gt; undefined</span><br></pre></td></tr></table></figure></p><p>分析：手机号只有11位、数字开头/结尾、 中国手机号以1开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//接上面代码继续</span><br><span class="line">str1.match(/1[3578]\d&#123;9&#125;/g)</span><br><span class="line">--&gt; [&quot;15011112222&quot;]  // ✅准确无误地完全匹配上</span><br><span class="line">str2.match(/1[3578]\d&#123;9&#125;/g)</span><br><span class="line">--&gt; [&quot;15011112222&quot;]   //虽然也返回正则所规定的，但只是部分匹配</span><br></pre></td></tr></table></figure></p><p>如何接解决？分析：手机号前后都没东西，也就是要以数字1作为开头，结尾也要匹配数字字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//接上面代码</span><br><span class="line">str2.match(/^1[3578]\d&#123;9&#125;/g)</span><br><span class="line">--&gt; null</span><br><span class="line">str1.match(/^1[3578]\d&#123;9&#125;/g)</span><br><span class="line">--&gt;[&quot;15011112222&quot;]   ✅</span><br><span class="line">str3.match(/^1[3578]\d&#123;9&#125;/g)</span><br><span class="line">--&gt; [&quot;15011111122&quot;]   //虽然也返回正则所规定的，也是以1为开头的，但没有结尾</span><br><span class="line"></span><br><span class="line">//$ 结尾匹配上该字符</span><br><span class="line">str1.match(/^1[3578]\d&#123;9&#125;$/g)</span><br><span class="line">--&gt; [&quot;15011112222&quot;]</span><br><span class="line">str2.match(/^1[3578]\d&#123;9&#125;$/g)</span><br><span class="line">--&gt; null</span><br><span class="line">str3.match(/^1[3578]\d&#123;9&#125;$/g)</span><br><span class="line">--&gt; null</span><br><span class="line">str4.match(/^1[3578]\d&#123;9&#125;$/g)</span><br><span class="line">--&gt; null</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165274d0557b863f?w=600&amp;h=217&amp;f=jpeg&amp;s=15027" alt=""></p><h3 id="8、如何具象使用正则？"><a href="#8、如何具象使用正则？" class="headerlink" title="8、如何具象使用正则？"></a>8、如何具象使用正则？</h3><p>（1）先利用字符串的搜索去把正则给应用起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello world 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie&apos;</span><br><span class="line">--&gt; undefined</span><br></pre></td></tr></table></figure></p><p>结果如：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165274e11870bff3?w=600&amp;h=233&amp;f=jpeg&amp;s=50490" alt=""></p><p>（2）接着回忆，利用字符串的搜索功能搜出某个字的起始下标（所传递的是一个字符串）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.search(&apos;world&apos;) </span><br><span class="line">--&gt; 6  //这里可看出str输出的字符串，空格跳过</span><br></pre></td></tr></table></figure></p><p>这里，可以使用正则表达式进行检索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.match(&apos;world&apos;)</span><br><span class="line">str.match(/\d/)</span><br><span class="line">//只匹配到一次，1，拿到就结束</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165274e92922b55a?w=600&amp;h=458&amp;f=jpeg&amp;s=125521" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//匹配所有的数字字符</span><br><span class="line">str.match(/\d/g)</span><br><span class="line">--&gt;(8) [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;]</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165274f4a6612035?w=600&amp;h=308&amp;f=jpeg&amp;s=41100" alt=""></p><h1 id="六、贪婪模式与非贪婪模式"><a href="#六、贪婪模式与非贪婪模式" class="headerlink" title="六、贪婪模式与非贪婪模式"></a>六、贪婪模式与非贪婪模式</h1><h3 id="1、贪婪模式"><a href="#1、贪婪模式" class="headerlink" title="1、贪婪模式"></a>1、贪婪模式</h3><p>在贪婪（默认）模式下，正则引擎【尽可能多】地重复匹配字符<br>先看这个代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;a &quot;witch&quot; and her &quot;boom&quot; is one&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/&quot;.*&quot;/g)</span><br><span class="line">--&gt; [&quot;&quot;witch&quot; and her &quot;boom&quot;&quot;]</span><br></pre></td></tr></table></figure></p><p>按照我们的逻辑来看，本来我们想要匹配的是<code>&quot;witch&quot;</code>和<code>&quot;boom&quot;</code>两个字符串，但是结果却出乎我们的意料，是<code>&quot;witch&quot;and her &quot;boom&quot;</code>这样一个整体的字符串。这样的字符串则是因为正则表达式的贪婪模式起的效果。</p><p>正则引擎演示如下：</p><p>正则的贪婪模式采用了查找算法的形式进行检索匹配字符。正则引擎从字符串的第0位开始检索：（在此为若愚老师打call，他讲正则引擎工作讲得真的很不错😂）<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/1652750251af1a9f?w=600&amp;h=614&amp;f=jpeg&amp;s=156517" alt=""></p><h3 id="2、非贪婪模式"><a href="#2、非贪婪模式" class="headerlink" title="2、非贪婪模式"></a>2、非贪婪模式</h3><p>与贪婪模式相反，可通过在代表数量的标示符后放置<code>?</code>（表示尽可能地少匹配） 来开启非贪婪模式。如：<code>?</code>、<code>+?</code>甚至是<code>??</code>非贪婪模式下，正则引擎尽可能少地重复匹配字符<br>演示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;a &quot;witch&quot; and her &quot;boom&quot; is one&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/&quot;.*?&quot;/g)   </span><br><span class="line">--&gt; (2) [&quot;&quot;witch&quot;&quot;, &quot;&quot;boom&quot;&quot;]</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165278dac3e96834?w=600&amp;h=550&amp;f=jpeg&amp;s=105664" alt=""></p><h1 id="七、分组"><a href="#七、分组" class="headerlink" title="七、分组"></a>七、分组</h1><p>使用量词的时候匹配多个字符，而不是像上面例子只是匹配一个<br>首先，假设写成 <code>hunger{10}</code>的话匹配的是<code>hunge＋r</code>出现10次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hunger&#123;10&#125;/   //hunge＋r出现10次</span><br></pre></td></tr></table></figure></p><p>把hunger作为一个整体呢？使用<code>()</code>就可以达到此目的，我们称为分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(hugner)&#123;10&#125;/</span><br></pre></td></tr></table></figure></p><p><strong>字符</strong>或<code>|</code>在正则引擎中是怎么处理的呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;helloworld&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/hello|sworld/) \ //有个疑问，是(hello)|(sworld),还是hell(o|s)world</span><br><span class="line">              //匹配返回的有可能是hello或者hells</span><br><span class="line">--&gt;[&quot;hello&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined]</span><br><span class="line">验证之后，等同于</span><br><span class="line">str.match(/(hello)|(sworld)/)</span><br><span class="line">--&gt; (3) [&quot;hello&quot;, &quot;hello&quot;, undefined, index: 0, input: &quot;helloworld&quot;, groups: undefined]</span><br><span class="line">str.match(/hello|sworld/g)</span><br><span class="line">--&gt; [&quot;hello&quot;]</span><br><span class="line"></span><br><span class="line">//而事实上，匹配helloworld这个字符串，字符 |  则需要将左右两边相邻的字母用()包裹起来</span><br><span class="line"> str.match(/hell(o|s)world/g)</span><br><span class="line">--&gt; [&quot;helloworld&quot;]</span><br></pre></td></tr></table></figure></p><p>所以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(hello|world)&#123;20&#125;  //表示hello或者world都匹配出现20次</span><br></pre></td></tr></table></figure></p><p>分组的作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str</span><br><span class="line">--&gt; &quot;helloworld&quot;</span><br><span class="line">str.match(/(he)l(lo)/)</span><br><span class="line">--&gt; (3) [&quot;hello&quot;, &quot;he&quot;, &quot;lo&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined]</span><br><span class="line">VS</span><br><span class="line">str.match(/hello/)</span><br><span class="line">--&gt;[&quot;hello&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p><p>分组的价值实践：（同时运用了非贪婪模式的 ？让返回完全匹配 ）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str =&apos;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+?)&quot;/)</span><br><span class="line">--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;, &quot;http://wangxiaoqin.com&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;, groups: undefined]</span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+?)&quot;/)[1]</span><br><span class="line">--&gt;&quot;http://wangxiaoqin.com&quot;</span><br></pre></td></tr></table></figure></p><p> 非贪婪模式 VS贪婪模式<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var str =&apos;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+?)&quot;/)</span><br><span class="line">--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;, &quot;http://wangxiaoqin.com&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, groups: undefined]</span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+?)&quot;/g)</span><br><span class="line">--&gt; [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;]</span><br><span class="line"></span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+)&quot;/)</span><br><span class="line">--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, &quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, groups: undefined]</span><br><span class="line">str.match(/href=&quot;(https?:\/\/.+)&quot;/g)</span><br><span class="line">--&gt; [&quot;href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;]</span><br></pre></td></tr></table></figure></p><h1 id="八、前瞻"><a href="#八、前瞻" class="headerlink" title="八、前瞻"></a>八、前瞻</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str=hunger(?=Byron)</span><br><span class="line"></span><br><span class="line">str.exec(&apos;goodByron123&apos;); //[&apos;good&apos;]</span><br><span class="line">str.exec(&apos;goodCasper123&apos;); //null</span><br><span class="line">str.exec(&apos;goodCasper123&apos;);//null</span><br></pre></td></tr></table></figure><h1 id="九、正则表达式的相关用法"><a href="#九、正则表达式的相关用法" class="headerlink" title="九、正则表达式的相关用法"></a>九、正则表达式的相关用法</h1><h3 id="1、reg-test-str"><a href="#1、reg-test-str" class="headerlink" title="1、reg.test(str)"></a>1、<code>reg.test(str)</code></h3><p>测试字符串参数中是否存正则表达式模式，如果存在则返回true，否则返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\d+\.\d&#123;1,2&#125;$/g;</span><br><span class="line"></span><br><span class="line">reg.test(&apos;123.45&apos;); //true</span><br><span class="line">reg.test(&apos;0.2&apos;); //true</span><br><span class="line">reg.test(&apos;a.34&apos;); //false</span><br><span class="line">reg.test(&apos;34.5678&apos;); //false</span><br></pre></td></tr></table></figure></p><p>实践价值：<br>测试一个手机号是否存在？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^1[3578]\d&#123;9&#125;$/g   //正则的手机号检索标准</span><br><span class="line">--&gt; undefined</span><br><span class="line">reg.test(&apos;18320158956&apos;)</span><br><span class="line">--&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="2、reg-exec-str"><a href="#2、reg-exec-str" class="headerlink" title="2、reg.exec(str)"></a>2、<code>reg.exec(str)</code></h3><p>用于正则表达式模式在字符串中运行查找，持续去运行。如果<code>exec()</code>找到了匹配的文本，则返回一个结果数组,否则返回 <code>null</code><br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var str =&apos;123 456 789&apos;</span><br><span class="line">var reg =/\d&#123;3&#125;/   //未添加g，则匹配一次就结束</span><br><span class="line">reg.exec(str)</span><br><span class="line">[&quot;123&quot;, index: 0, input: &quot;123 456 789&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">/* 进行g的全局匹配 */</span><br><span class="line">var str =&apos;123 456 789&apos;</span><br><span class="line">var reg =/\d&#123;3&#125;/g</span><br><span class="line">reg.exec(str)</span><br><span class="line">--&gt; [&quot;123&quot;, index: 0, input: &quot;123 456 789&quot;, groups: undefined]</span><br><span class="line">reg.exec(str)</span><br><span class="line">--&gt; [&quot;456&quot;, index: 4, input: &quot;123 456 789&quot;, groups: undefined]</span><br><span class="line">reg.exec(str)</span><br><span class="line">--&gt; [&quot;789&quot;, index: 8, input: &quot;123 456 789&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p><p>实践价值：<br>如找出相对应的邮箱，手机号码等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//代码如下：  </span><br><span class="line">  var str =&apos;123 456 789&apos;</span><br><span class="line">  var reg =/\d&#123;3&#125;/g</span><br><span class="line">while(result=reg.exec(str))&#123;</span><br><span class="line">         console.log(result[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt; 123</span><br><span class="line">    456</span><br><span class="line">    789</span><br></pre></td></tr></table></figure></p><h3 id="3、str-split-reg"><a href="#3、str-split-reg" class="headerlink" title="3、str.split(reg)"></a>3、<code>str.split(reg)</code></h3><p>使用<code>split</code>方法把字符串分割为字符数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;h   e  llo wan g xi ao qi   n&apos;</span><br><span class="line">undefined</span><br><span class="line">//以前</span><br><span class="line">str.split(&apos;&apos;)</span><br><span class="line">--&gt; (29) [&quot;h&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;e&quot;, &quot; &quot;, &quot; &quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot; &quot;, &quot;g&quot;, &quot; &quot;, &quot;x&quot;, &quot;i&quot;, &quot; &quot;, &quot;a&quot;, &quot;o&quot;, &quot; &quot;, &quot;q&quot;, &quot;i&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;n&quot;]</span><br><span class="line">str.split(&apos; &apos;)</span><br><span class="line">--&gt; (14) [&quot;h&quot;, &quot;&quot;, &quot;&quot;, &quot;e&quot;, &quot;&quot;, &quot;llo&quot;, &quot;wan&quot;, &quot;g&quot;, &quot;xi&quot;, &quot;ao&quot;, &quot;qi&quot;, &quot;&quot;, &quot;&quot;, &quot;n&quot;]</span><br><span class="line">//现在：用正则表达式做一个检索分类</span><br><span class="line">str.split(/\s/)</span><br><span class="line">--&gt; (14) [&quot;h&quot;, &quot;&quot;, &quot;&quot;, &quot;e&quot;, &quot;&quot;, &quot;llo&quot;, &quot;wan&quot;, &quot;g&quot;, &quot;xi&quot;, &quot;ao&quot;, &quot;qi&quot;, &quot;&quot;, &quot;&quot;, &quot;n&quot;]</span><br><span class="line">str.split(/\s*/)</span><br><span class="line">--&gt; (16) [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;x&quot;, &quot;i&quot;, &quot;a&quot;, &quot;o&quot;, &quot;q&quot;, &quot;i&quot;, &quot;n&quot;]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、意义&quot;&gt;&lt;a href=&quot;#一、意义&quot; class=&quot;headerlink&quot; title=&quot;一、意义&quot;&gt;&lt;/a&gt;一、意义&lt;/h1&gt;&lt;p&gt;用来判断用户输入是否符合某些特定规则，如检测判断用户所填信息是否为正确的手机号？正确的邮箱地址？以及在很多文本编辑器中，则更常用来检索、替换那些符合某个模式的文本。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="正则匹配" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    
      <category term="贪婪模式和非贪婪模式" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：06-5 Math/Math</title>
    <link href="http://yoursite.com/2018/08/17/32-06.5%20Math:Math/"/>
    <id>http://yoursite.com/2018/08/17/32-06.5 Math:Math/</id>
    <published>2018-08-16T16:48:07.000Z</published>
    <updated>2018-08-16T17:17:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h1><h3 id="1、单双引号（实际无区别）"><a href="#1、单双引号（实际无区别）" class="headerlink" title="1、单双引号（实际无区别）"></a>1、单双引号（实际无区别）</h3><p>特别场景下，单引号更严格。如：<code>&quot;It&#39;s a long journey&quot;</code><br><a id="more"></a></p><h3 id="2、转义字符"><a href="#2、转义字符" class="headerlink" title="2、转义字符"></a>2、转义字符</h3><p>就是在内部不能转化的单、双引号前面加上反斜杠，用来转义，成为一个完整的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;he\&apos;llo&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str</span><br><span class="line">--&gt; &quot;he&apos;llo&quot;</span><br><span class="line"></span><br><span class="line">//展示长度</span><br><span class="line">str.length</span><br><span class="line">--&gt; 6</span><br><span class="line"></span><br><span class="line">//展示斜杠</span><br><span class="line">var str = &quot;\\ccc&quot;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str</span><br><span class="line">--&gt; &quot;\ccc&quot;</span><br><span class="line"></span><br><span class="line">//展示换行</span><br><span class="line">//例子1：</span><br><span class="line">var longString = &quot;Long \  //注：注意不要多出空格，会报错</span><br><span class="line">long \</span><br><span class="line">long \</span><br><span class="line">string&quot;;</span><br><span class="line">--&gt; undefined</span><br><span class="line">longString</span><br><span class="line">--&gt; &quot;Long long long string&quot;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">var longString = &apos;Long &apos;</span><br><span class="line">  + &apos;long &apos;</span><br><span class="line">  + &apos;long &apos;</span><br><span class="line">  + &apos;string&apos;;</span><br><span class="line">--&gt; undefined</span><br><span class="line">longString</span><br><span class="line">--&gt; &quot;Long long long string&quot;</span><br><span class="line"></span><br><span class="line">//例子2：</span><br><span class="line">var a = &apos;hel \</span><br><span class="line">\</span><br><span class="line">lo&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">a</span><br><span class="line">&quot;hel lo&quot;</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">var a = &apos;hel\</span><br><span class="line">\</span><br><span class="line">lo&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">a</span><br><span class="line">--&gt; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">//例子3：ES6用法</span><br><span class="line">`</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">`</span><br><span class="line">--&gt; &quot;</span><br><span class="line">    hello</span><br><span class="line">    world</span><br><span class="line">    &quot;</span><br></pre></td></tr></table></figure></p><h3 id="3、字符串常见用法"><a href="#3、字符串常见用法" class="headerlink" title="3、字符串常见用法"></a>3、字符串常见用法</h3><p>（1）长度计算、连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//计算</span><br><span class="line">var str = &quot;hello&quot;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.length</span><br><span class="line">--&gt; 5</span><br><span class="line">str[0]</span><br><span class="line">--&gt; &quot;h&quot;</span><br><span class="line">str[str.length - 1]</span><br><span class="line">--&gt; &quot;o&quot;</span><br><span class="line">str.charAt(0)  //截取字符串的首字母</span><br><span class="line">--&gt; &quot;h&quot;</span><br><span class="line">str.charCodeAt(0) //获取Ascii 码</span><br><span class="line">--&gt; 104</span><br><span class="line"></span><br><span class="line">//连接</span><br><span class="line">var str2 = &quot;world&quot; </span><br><span class="line">--&gt; undefined</span><br><span class="line">var str1 = &quot;hello &quot; //在测试时，发现字符串里空格，字符串内部相应地会出现间隙</span><br><span class="line">--&gt; undefined</span><br><span class="line">var str3 = str1 + str2</span><br><span class="line">--&gt; undefined</span><br><span class="line">str3</span><br><span class="line">--&gt; &quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><p>（2）字符串截取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello world&quot;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.substr(1, 3) </span><br><span class="line">--&gt; &quot;ell&quot;   //第一个是开始位置， 第二个是长度  ell</span><br><span class="line">str.substring(1, 3)</span><br><span class="line">--&gt; &quot;el&quot;    //第一个是开始位置，第二个是结束位置，长度为第二个－第一个  el</span><br></pre></td></tr></table></figure></p><p>（3）字符串查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello my world&quot;;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.search(&apos;my&apos;)</span><br><span class="line">--&gt; 6</span><br><span class="line">str.replace(&apos;my&apos;, &apos;your&apos;)</span><br><span class="line">--&gt; &quot;hello your world&quot;</span><br><span class="line">str.match(&apos;my&apos;)</span><br><span class="line">--&gt; [&quot;my&quot;, index: 6, input: &quot;hello my world&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">//查找位数:ES6中的用法</span><br><span class="line">str.indexOf(&apos;el&apos;)</span><br><span class="line">--&gt; 1</span><br></pre></td></tr></table></figure></p><p>（4）字符串的大小写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello&quot;;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str.toUpperCase()</span><br><span class="line">--&gt; &quot;HELLO&quot;</span><br><span class="line"> str.toLowerCase()</span><br><span class="line">--&gt; &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><p>（5）字符串的拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var color = &apos;red&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">str = &apos;衣服的颜色是&apos; + color</span><br><span class="line">--&gt; &quot;衣服的颜色是red&quot;</span><br><span class="line">str2 = `今天的颜色很$&#123;color&#125;`</span><br><span class="line">--&gt; &quot;今天的颜色很red&quot;</span><br></pre></td></tr></table></figure></p><h1 id="二、Math（JS内置对象）"><a href="#二、Math（JS内置对象）" class="headerlink" title="二、Math（JS内置对象）"></a>二、Math（JS内置对象）</h1><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>看了一下概念，看懂了不懂怎么说，就是用Math提供一种数学计算方法：<br>如图：<img src="https://user-gold-cdn.xitu.io/2018/8/11/16527187b62b720c?w=600&amp;h=828&amp;f=jpeg&amp;s=165879" alt=""></p><h3 id="2、Math的常用属性"><a href="#2、Math的常用属性" class="headerlink" title="2、Math的常用属性"></a>2、Math的常用属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Math.E      // 2.718281828459045</span><br><span class="line">Math.LN2    // 0.6931471805599453</span><br><span class="line">Math.LN10   // 2.302585092994046</span><br><span class="line">Math.LOG2E  // 1.4426950408889634</span><br><span class="line">Math.LOG10E  // 0.4342944819032518</span><br><span class="line">Math.PI     // 3.141592653589793</span><br><span class="line">Math.SQRT1_2 // 0.7071067811865476</span><br><span class="line">Math.SQRT2 // 1.4142135623730951</span><br><span class="line">如：</span><br><span class="line">Math.PI*3*3</span><br><span class="line">--&gt; 28.274333882308138</span><br></pre></td></tr></table></figure><h3 id="3-日常使用Math"><a href="#3-日常使用Math" class="headerlink" title="3.日常使用Math"></a>3.日常使用Math</h3><p>建议理解透每个属性用法，自己做题默念用法规则，在控制台验证自己的结果</p><p>（1）<code>round</code>  用于四舍五入<br>语法：<br><code>Math.round()</code></p><p>对于负值的运算结果与正值不太一样，主要集中于<code>.5</code>的处理上<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.round(-4.6) //-5</span><br><span class="line">Math.round(-4.5) //-4</span><br><span class="line">Math.round(-1.5) //-1</span><br><span class="line">Math.round(-0.5) //-0</span><br></pre></td></tr></table></figure></p><p>而正值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.round(0.5) //1</span><br><span class="line">Math.round(1.5) //2</span><br><span class="line">Math.round(4.5) //5</span><br><span class="line">Math.round(4.8) //5</span><br></pre></td></tr></table></figure></p><p>（2）<code>abs</code>  返回参数值的绝对值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs()</span><br></pre></td></tr></table></figure></p><p>（3）<code>max</code>/<code>min</code>  返回最大参数/最小参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max()</span><br><span class="line">Math.min()</span><br></pre></td></tr></table></figure></p><p>一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.max(4, -1, &apos;s&apos;)  //NaN</span><br><span class="line">Math.max.apply(null,[-2,-9,2,6]) //6</span><br><span class="line">Math.min.apply(null,[-2,-9,2,6]) // -9</span><br></pre></td></tr></table></figure></p><p>（4）<code>floor</code>/<code>ceil</code><br>A、floor 返回小于参数值的最大整数  不等于  取整<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(3.8)  //3</span><br><span class="line">Math.floor(3.5)  //3</span><br><span class="line">Math.floor(3.2)  // 3</span><br><span class="line">Math.floor(-3.2) // -4  </span><br><span class="line">Math.floor(-3.5) //-4</span><br><span class="line">Math.floor(-3.8) //-4</span><br></pre></td></tr></table></figure></p><p>B、<code>ceil</code> 返回大于参数值的最小整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(3.8)  //4</span><br><span class="line">Math.ceil(3.5)  //4</span><br><span class="line">Math.ceil(3.2)  // 4</span><br><span class="line">Math.ceil(-3.2) //-3 </span><br><span class="line">Math.ceil(-3.5) //-3</span><br><span class="line">Math.ceil(-3.8) //-3</span><br></pre></td></tr></table></figure></p><p>（3）<code>pow</code>/<code>sqrt</code></p><ul><li><p><code>pow</code> 用于求平方,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 2) // 4</span><br><span class="line">Math.pow(2, 3) // 8</span><br></pre></td></tr></table></figure></li><li><p><code>sqrt</code> 用于求参数的平方根（即参数包含在这种√￣中的值），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(4) // 2   相当于√4￣=2</span><br><span class="line">Math.sqrt(-4) // NaN</span><br></pre></td></tr></table></figure></li></ul><p>（4）<code>log</code>/<code>exp</code></p><ul><li><code>log</code>   用于返回以e为底的自然对数值</li></ul><p><strong>普及一下对数函数：</strong><br>如果<code>ax=N</code>（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作<code>x=logaN</code>，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。<br><code>Math.log(Math.E)// 1</code></p><ul><li><code>exp</code>  用于返回常数e的参数次方<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(1) // 2.718281828459045  //10÷e</span><br><span class="line">Math.exp(3) // 20.085536923187668</span><br></pre></td></tr></table></figure></li></ul><p>【重点】（5）<code>random</code> 用于求随机数，返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。如你输入<code>Math.random()</code>，任何时候都会生成按照以上规则组成的随机数</p><p><strong>实践0：</strong>返回给定范围内的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实践1：</strong> 均为随机</p><ul><li>获取一个0-100的整数<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165271d5d380b712?w=600&amp;h=533&amp;f=jpeg&amp;s=109709" alt=""></li><li>获取一个0-5之间的整数<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165271e3f266b53f?w=600&amp;h=282&amp;f=jpeg&amp;s=46317" alt=""></li><li>获取一个1-6之间的整数<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165271ea523f25e3?w=600&amp;h=441&amp;f=jpeg&amp;s=78732" alt=""></li><li>获取一个10-20之间的整数<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165271ed487dd392?w=600&amp;h=384&amp;f=jpeg&amp;s=73288" alt=""></li></ul><p><strong>实践2:</strong> 获取一个随机的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function randomStr(len)&#123;</span><br><span class="line">    var str = &apos;&apos; //第3步</span><br><span class="line">    var dict = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&apos;   //第4步</span><br><span class="line">    for(var i= 0; i&lt;len; i++)&#123; //用来执行次数</span><br><span class="line">       var index = Math.floor(Math.random()*dict.length)//通过Math.floor来取整  //用来获取随机长度的整数值</span><br><span class="line">       str += dict[index]  </span><br><span class="line">    &#125; //第5步</span><br><span class="line">   return str//第6步</span><br><span class="line">  </span><br><span class="line">&#125;//第1步：定义一个随机字符串长度，空</span><br><span class="line"></span><br><span class="line">var str = randomStr(32)</span><br><span class="line">console.log(str) //第2步：定义str具体值（注：这个随机字符串包括大小写字母数字等等）</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/11/165271f4aaf11c0d?w=600&amp;h=253&amp;f=jpeg&amp;s=96002" alt=""><br>可以在控制台算一下所声明的 dict随机字符串有多少位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dict = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&apos;</span><br><span class="line">--&gt; undefined</span><br><span class="line">dict.length</span><br><span class="line">--&gt; 63</span><br><span class="line"></span><br><span class="line">//基本需要的是下标为0-62的随机参数</span><br></pre></td></tr></table></figure></p><p><strong>实践3：</strong> 获取一个随机IP</p><p>写一个函数，生成一个随机IP地址，一个合法的IP地址<code>0.0.0.0~255.255.255.255</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function getRandIP()&#123;</span><br><span class="line">  var ip = []</span><br><span class="line">  for(var i = 0;i&lt;4;i++)&#123;   //i&lt;4是由于下标位数</span><br><span class="line">     ip = ip+Math.floor(Math.random()*256)+&quot;.&quot;</span><br><span class="line">     &#125;</span><br><span class="line">return ip </span><br><span class="line">  &#125;</span><br><span class="line">var ip = getRandIP()</span><br><span class="line">console.log(ip) // 输出ip地址</span><br><span class="line">或</span><br><span class="line">function getRandIP()</span><br><span class="line">&#123;</span><br><span class="line">    var temp = 0;</span><br><span class="line">    ip = &apos;&apos;;</span><br><span class="line">    for (var i = 0; i &lt; 4; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = parseInt(Math.random() * 256);</span><br><span class="line">        if (i &lt; 3) </span><br><span class="line">        &#123;</span><br><span class="line">            ip = ip + temp + &apos;.&apos;;           </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ip = ip + temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ip;</span><br><span class="line">&#125;</span><br><span class="line">var ip = getRandIP()</span><br><span class="line">console.log(ip)  //输出ip地址</span><br></pre></td></tr></table></figure><p><strong>实践4：</strong> 获取一个随机颜色字符串</p><p>写一个函数，生成一个随机颜色字符串，合法的颜色为<code>#000000~#ffffff</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getRandColor()&#123;</span><br><span class="line">    var str =&apos;#&apos;</span><br><span class="line">    var dict =&apos;0123456789abcdef&apos;</span><br><span class="line">    for(var i= 1;i&lt;6 ;i++)&#123;</span><br><span class="line">         var index = Math.floor(Math.random()*dict.length)</span><br><span class="line">         str += dict[index] //str = str+dict[index]</span><br><span class="line">&#125;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">var color = getRandColor()</span><br><span class="line">console.log(color)</span><br></pre></td></tr></table></figure></p><h1 id="三、Date（JS的内置对象）"><a href="#三、Date（JS的内置对象）" class="headerlink" title="三、Date（JS的内置对象）"></a>三、Date（JS的内置对象）</h1><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p>是JavaScript提供日期和时间的操作接口</p><h3 id="2、Date的几个静态方法："><a href="#2、Date的几个静态方法：" class="headerlink" title="2、Date的几个静态方法："></a>2、Date的几个静态方法：</h3><p>（1）<code>Date.now()</code> ——获取时间毫秒数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date.now()</span><br><span class="line">--&gt; 1528904474005  //根据实际时间得出的毫秒数也不一样</span><br></pre></td></tr></table></figure></p><p>now方法返回的毫秒数，具体指的是距离1970年1月1日00：00：00的毫秒数<br>或</p><p><code>Date.parse()</code><br><strong>注：</strong>如果解析失败，返回<code>NaN</code><br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date.parse(2011-11-11)</span><br><span class="line">--&gt; 599616000000</span><br></pre></td></tr></table></figure></p><p>（2）<code>new Date()</code><br>A、通过<code>new date</code>方法，获取一个时间对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(2020,8,14)  </span><br><span class="line">--&gt; Mon Sep 14 2020 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure></p><p>通过字符串所生成的时间对象（且没有传递时分秒），获取的则是日期，而对于处于东八区的我们则是8点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str =&apos;2017-08-01&apos;</span><br><span class="line">--&gt; &quot;2017-08-01&quot;</span><br><span class="line">new Date(str)</span><br><span class="line">--&gt; Tue Aug 01 2017 08:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure></p><p>若<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str =&apos;2017-08-01 00:00:00&apos;</span><br><span class="line">--&gt; &quot;2017-08-01 00:00:00&quot;</span><br><span class="line">new Date(str)</span><br><span class="line">--&gt; Tue Aug 01 2017 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure></p><p>B、声明一个变量d，d则是一个日期对象，返回的则是一个字符串，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date()</span><br><span class="line">--&gt; undefined</span><br><span class="line">d</span><br><span class="line">--&gt; Thu Jun 14 2018 00:08:31 GMT+0800 (CST) //字符串，实际时间有所不同</span><br><span class="line">typeof d</span><br><span class="line">--&gt; &quot;object&quot;  //验证为一个对象</span><br></pre></td></tr></table></figure></p><p>通过变量d，一个对象，获取一些必要信息，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d.getDate()</span><br><span class="line">--&gt; 14</span><br><span class="line">d.getFullYear()</span><br><span class="line">--&gt; 2018</span><br><span class="line">d.getMonth()</span><br><span class="line">--&gt; 5</span><br><span class="line">d.getDay()</span><br><span class="line">--&gt; 4</span><br><span class="line">d.getHours()</span><br><span class="line">--&gt; 0</span><br><span class="line">d.getMinutes()</span><br><span class="line">--&gt; 8</span><br><span class="line">d.getSeconds()</span><br><span class="line">--&gt; 31</span><br><span class="line">d.getMilliseconds()</span><br><span class="line">--&gt; 438</span><br></pre></td></tr></table></figure></p><h3 id="3、实践："><a href="#3、实践：" class="headerlink" title="3、实践："></a>3、实践：</h3><p>（1）实践1：100天前是几月几号？</p><p>注：当前时间为：<code>2018.6.19</code> 周二 </p><p>时间大概：<code>15：24：35</code>（时间误差不到3-5mins）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var curTime = Date.now()  //计算当前时间的时间毫秒数</span><br><span class="line">--&gt; undefined</span><br><span class="line">new Date(curTime-100*24*60*60*1000)</span><br><span class="line">--&gt; Sun Mar 11 2018 15:23:02 GMT+0800 (中国标准时间) //获取100天以前的具体日期</span><br><span class="line">new Date(curTime-100*24*60*60*1000).getMonth()</span><br><span class="line">--&gt; 2</span><br><span class="line">new Date(curTime-100*24*60*60*1000).getDate()</span><br><span class="line">--&gt; 11</span><br></pre></td></tr></table></figure></p><p>（2）实践2：复杂函数的执行时间如何计算？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var start = Date.now()</span><br><span class="line">--&gt; undefined</span><br><span class="line">var end =Date.now()</span><br><span class="line">--&gt; undefined</span><br><span class="line">end - start</span><br><span class="line">--&gt; 5196</span><br></pre></td></tr></table></figure></p><p>【重点】（3）实践3：</p><p>写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串（即输出打印出时间戳）。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串：</p><ul><li>刚刚（ t 距当前时间不到1分钟时间间隔）</li><li>3分钟前 (t距当前时间大于等于1分钟，小于1小时)</li><li>8小时前 (t 距离当前时间大于等于1小时，小于24小时)</li><li>3天前 (t 距离当前时间大于等于24小时，小于30天)</li><li>2个月前 (t 距离当前时间大于等于30天小于12个月)</li><li>8年前 (t 距离当前时间大于等于12个月)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function friendlyDate (time) &#123;</span><br><span class="line">    var t = new Date().getTime();</span><br><span class="line">    var d = (t-time)/1000;</span><br><span class="line">    switch(true)&#123;</span><br><span class="line">        case d &lt; 60:</span><br><span class="line">        console.log(&apos;刚刚&apos;);</span><br><span class="line">        break;</span><br><span class="line">        case d &gt;=60 &amp;&amp; d&lt;60*60:</span><br><span class="line">        console.log(Math.floor(d/60)+&apos;分钟前&apos;);</span><br><span class="line">        break;</span><br><span class="line">        case d &gt;=3600 &amp;&amp; d&lt;3600*24:</span><br><span class="line">        console.log(Math.floor(d/3600)+&quot;小时前&quot;);</span><br><span class="line">        break;</span><br><span class="line">        case d &gt;=3600*24 &amp;&amp; d&lt;3600*24*30:</span><br><span class="line">        console.log(Math.floor(d/3600/24)+&quot;天前&quot;);</span><br><span class="line">        break;</span><br><span class="line">        case d &gt;=3600*24*30 &amp;&amp; d&lt;3600*24*30*12:</span><br><span class="line">        console.log(Math.floor(d/3600/24/30)+&quot;月前&quot;);</span><br><span class="line">        break;</span><br><span class="line">        default:</span><br><span class="line">        console.log(Math.floor(d/3600/24/30/12)+&quot;年前&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var str = friendlyDate(Date.now()-1000*60);</span><br><span class="line">console.log(str);</span><br><span class="line">var str2 = friendlyDate(&apos;1483941245793&apos;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、字符串&quot;&gt;&lt;a href=&quot;#一、字符串&quot; class=&quot;headerlink&quot; title=&quot;一、字符串&quot;&gt;&lt;/a&gt;一、字符串&lt;/h1&gt;&lt;h3 id=&quot;1、单双引号（实际无区别）&quot;&gt;&lt;a href=&quot;#1、单双引号（实际无区别）&quot; class=&quot;headerlink&quot; title=&quot;1、单双引号（实际无区别）&quot;&gt;&lt;/a&gt;1、单双引号（实际无区别）&lt;/h3&gt;&lt;p&gt;特别场景下，单引号更严格。如：&lt;code&gt;&amp;quot;It&amp;#39;s a long journey&amp;quot;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="字符串常见用法" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：06-4 ES5 数组拓展</title>
    <link href="http://yoursite.com/2018/08/17/31-06.4%20ES5%20%E6%95%B0%E7%BB%84%E6%8B%93%E5%B1%95/"/>
    <id>http://yoursite.com/2018/08/17/31-06.4 ES5 数组拓展/</id>
    <published>2018-08-16T16:47:56.000Z</published>
    <updated>2018-08-16T17:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、针对Array对象做了大幅拓展"><a href="#一、针对Array对象做了大幅拓展" class="headerlink" title="一、针对Array对象做了大幅拓展"></a>一、针对Array对象做了大幅拓展</h1><h3 id="1、Array-isArray-obj"><a href="#1、Array-isArray-obj" class="headerlink" title="1、Array.isArray(obj)"></a>1、<code>Array.isArray(obj)</code></h3><p>用于判断一个变量（或对象）是否为数组，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([])</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line"> Array.isArray(&#123;&#125;)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2、-indexOf-element-lastIndexOf-element"><a href="#2、-indexOf-element-lastIndexOf-element" class="headerlink" title="2、.indexOf(element) / .lastIndexOf(element)"></a>2、<code>.indexOf(element)</code> / <code>.lastIndexOf(element)</code></h3><p>用于如何判断在一个数组中找到所看到的一个值、数字，或变量是否存在<br>（1）ES3的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         var arr =  [3,  4,  &apos;hello&apos;  ,&apos;wangxiaoqin&apos;] </span><br><span class="line">// undefined </span><br><span class="line">          function  hasWord(arr,item)&#123;  for(var i=0; i&lt;arr.length; i++)&#123;  </span><br><span class="line">                  if(arr[i]  === item)</span><br><span class="line">                  return  true</span><br><span class="line">  &#125;  </span><br><span class="line">return  false </span><br><span class="line"> &#125; </span><br><span class="line"> // undefined </span><br><span class="line">hasWord(arr,&apos;wangxiaoqin&apos;) </span><br><span class="line">// true  </span><br><span class="line">hasWord(arr,&apos;helloo&apos;)  </span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p><p>（2）ES5的拓展做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3,  4,  &apos;hello&apos;  ,&apos;wangxiaoqin&apos;] </span><br><span class="line">//  undefined</span><br><span class="line">arr.indexOf(&apos;wangxiaoqin&apos;) </span><br><span class="line">//  3 </span><br><span class="line">arr.indexOf(&apos;wanxiaoqin&apos;)  </span><br><span class="line">// -1  //写了一个不存在的，直接输出-1</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong><br>那么，依此可以得出，<code>-1</code>也可以作为判断某对象是否存在于该数组</p><h3 id="3、-forEach-element-index-arrary"><a href="#3、-forEach-element-index-arrary" class="headerlink" title="3、.forEach(element,index,arrary)"></a>3、<code>.forEach(element,index,arrary)</code></h3><p>遍历一个数组，可以使用for循环；也可以数组自带的<code>.forEach</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3,  4,  &apos;hello&apos;  ,&apos;wangxiaoqin&apos;] </span><br><span class="line">//  undefined</span><br><span class="line">arr</span><br><span class="line"> --&gt;  (4)  [3,  4,  &quot;hello&quot;,  &quot;wangxiaoqin&quot;] </span><br><span class="line">            arr.forEach(function()&#123; </span><br><span class="line">                   console.log(arguments)  </span><br><span class="line">             &#125;) </span><br><span class="line"> --&gt;Arguments(3)  [3,  0,  Array(4), </span><br><span class="line">      Arguments(3)  [4,  1,  Array(4),  </span><br><span class="line">      Arguments(3)  [&quot;hello&quot;,  2,  Array(4),  </span><br><span class="line">     Arguments(3)  [&quot;wangxiaoqin&quot;,  3,  Array(4),</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653d54a9457803a?w=600&amp;h=309&amp;f=jpeg&amp;s=25609" alt="image"><br>接着,可以使用<code>.forEach</code>遍历该数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(value,index)&#123;  //value指数组中的元素，index指数组中的下标 </span><br><span class="line">              console.log(&apos;&apos;+value+value) </span><br><span class="line">             &#125;)  </span><br><span class="line"> --&gt;33  </span><br><span class="line">      44 </span><br><span class="line">      hellohello</span><br><span class="line">     wangxiaoqinwangxiaoqin</span><br><span class="line"> //undefined</span><br></pre></td></tr></table></figure></p><h3 id="4、-every-function-element-index-array"><a href="#4、-every-function-element-index-array" class="headerlink" title="4、.every(function(element, index, array))"></a>4、<code>.every(function(element, index, array))</code></h3><p>用于满足该数组中函数设定的某个条件，函数返回的是一个布尔值<br>满足条件：</p><ul><li>every是所有函数的每个回调函数都返回true的时候才会返回true，当遇到false的时候终止执行，返回false</li><li>some函数是“存在”有一个回调函数返回true的时候终止执行并返回true，否则返回false<br>如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[3,4,-1,0,5].every(function(val)&#123; </span><br><span class="line">            return val&gt;0?true:false  //使用三目运算符 === if...else</span><br><span class="line">  &#125;)  </span><br><span class="line">//  false</span><br></pre></td></tr></table></figure></li></ul><p><code>.some(function(element,index,array))</code>只要有一个符合，那就返回true；反之，则..</p><h3 id="5、-map-function-element"><a href="#5、-map-function-element" class="headerlink" title="5、.map(function(element))"></a>5、<code>.map(function(element))</code></h3><p>对数组中每一元素进行处理，函数返回值组成一个新数组返回，新数组索引结构和原数组一致，原数组保持不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr2 =  [1,  2,  3,  4,  5,  6].map(function(val)&#123; </span><br><span class="line">              return val*val </span><br><span class="line">        &#125;) </span><br><span class="line">// undefined</span><br><span class="line">arr2 </span><br><span class="line">//  (6)  [1,  4,  9,  16,  25,  36]</span><br></pre></td></tr></table></figure></p><h3 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组的过滤。</span><br><span class="line"></span><br><span class="line">**注：** </span><br><span class="line"></span><br><span class="line">产生新数组，原数组保持不变,如：</span><br></pre></td></tr></table></figure></h3><p>var arr=[3,  5,  6,  -1,  -2,  -3]<br>//  undefined<br>arr.filter(function(val){<br>         return val&gt;0<br>   })<br>//  (3)  [3,  5,  6]  //产生新数组<br>arr<br>//  (6)  [3,  5,  6,  -1,  -2,  -3]  //原数组不变  </p><p>/<em> 所以，我们需要为新数组赋新变量 </em>/<br>var arr2 = arr.filter(function(val){<br>            return val&gt;0<br> })<br>// undefined<br>arr2<br>//  (3)  [3,  5,  6]  </p><p>/<em> 如需过滤出里面的负数 </em>/<br>var arr3 = arr.filter(function(val){<br>             return val &lt;0<br>         })<br>// undefined<br>arr3<br>//  (3)  [-1,  -2,  -3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再如：</span><br></pre></td></tr></table></figure></p><p>var students =  [<br>         {<br>          name:’ad’,<br>          age:10<br>          },<br>         {<br>         name:’bb’,<br>         age:20<br>        },<br>        {<br>         name:’ca’,<br>         age:8<br>         },<br>         {<br>         name:’ce’,<br>        age:5<br>         },<br>]  </p><p>/<em> 假设过滤出数组里年纪大于18岁的 </em>/<br>var age18 =<br>        students.filter(function(students){<br>               return students.age &gt;  18<br>             })<br>               console.log(age18) </p><pre><code>--&gt; [[object Object]  {            age:  20,            name:  &quot;bb&quot;hui           } ] </code></pre><p>/<em> 假设过滤出数组里姓名里带有“c” </em>/<br> var namehasc =<br>            students.filter(function(students){<br>               return students.name.indexOf(‘c’)&gt;-1<br>         })<br>              console.log(namehasc)<br> –&gt;[[object Object]  {<br>                     age:  8,<br>                     name:  “ca”<br>          },  [object Object]  {<br>                 age:  5,<br>                name:  “ce”<br>    }]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以此，可以通过过滤可进行排序、查找、单独的处理</span><br><span class="line"></span><br><span class="line">### 7、`.reduce(function(v1, v2), value)`</span><br><span class="line">两元素（或参数）执行操作，数组元素返回组合成一个值，遍历数组，继续和数组中 其他元素组合，最终得出结果。代码如下：</span><br></pre></td></tr></table></figure></p><p>var arr =  [3,  4,  5]<br>–&gt; undefined<br>arr.reduce(function(v1,v2){<br>           return v1 + v2<br>          })<br>  –&gt;  12  //7+5<br>arr.reduce(function(v1,v2){<br>           return v1 <em> v2<br>         })<br>–&gt;  60  //12</em>5 </p><p>/<em> 使用初始值  .reduce(function(v1, v2), value)  value为初始值 </em>/<br>arr.reduce(function(v1,v2){<br>              return v1 + v2 },100)<br>    –&gt; 112    </p><p>//100(v1)+3(v2)+4+5<br>//103(v1)+4(v2)+5<br> 以此类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 二、学习</span><br><span class="line">### 1、手写reduce功能</span><br><span class="line">A、先补充一些基本JS知识，</span><br><span class="line"></span><br><span class="line">假设：想要克隆一个与`arr`完全一样的`arr2`，但二者互不相干，如何处理?通过使用concat方法，一个数组arr拼接另一个数组，然后得到一个新的数组`arr2`。即通过concat获得一个新数组，拼接的原数组保持不变。实现一个**深拷贝**。</span><br><span class="line"></span><br><span class="line">**注：[ ]空数组也是一个数组**</span><br></pre></td></tr></table></figure></p><p>arr =  [1,2,3]<br>// [1,  2,  3]<br>arr2 = arr.concat([])<br>// [1,  2,  3]<br>arr2<br>// [1,  2,  3]  </p><p>/<em> 测试一下是否二者有关联 </em>/<br> arr2[0]  =  100<br>// 100<br> arr<br>//  [1,  2,  3]<br>arr2<br>//  [100,  2,  3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">B、手写一个reduce功能</span><br></pre></td></tr></table></figure></p><p>function  reduce(arr, fn, initValue){<br>               var arr2 = arr   //===[3, 4, 5, 6]<br>                 while(arr2.length &gt;  1)<br>                  }<br>//第2：如何是实现reduce？计划通过处理arr2 = [3, 4, 5, 6]的v1,v2, 通过function（v1,v2）{return v1+v2}处理，依次循环得出结果 </p><p>   var arr =  [3,  4,  5,  6]<br>  var result =  reduce(arr,  function(v1,v2){<br>                  return v1+v2 //第1：通过此遍历arr数组<br>   },10)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取消初始值去做：</span><br></pre></td></tr></table></figure></p><p>function  reduce(arr, fn){<br>             var arr2 = arr   //===[3, 4, 5, 6]<br>                  while(arr2.length &gt;  1){<br>                    console.log(arr2)<br>                    arr2.splice(0,2,fn(arr2[0],arr2[1]))<br>                     }<br>               return arr2[0]<br>             }  //第3：while(arr2.length &gt; 1)  相当于设置一个条件：当这个数组有两个以上的值时，<br>//第4：arr2 === arr用fn函数进行处理，v1+v2相加替换成一个结果， 使用splice(位数，个数,替换的结果),依次类推得出arr2 === arr的结果  </p><pre><code>       var arr =  [3,  4,  5,  6]                //[7,5,6]               //[12,6]              //[18]        var result =  reduce(arr,  function(v1,v2){                      return v1+v2               })          console.log(result)  //输出结果        --&gt;[3,  4,  5,  6]             [7,  5,  6]            [12,  6]             18</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图：</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94608a6e?w=600&amp;h=375&amp;f=jpeg&amp;s=31303)</span><br><span class="line">但是，这里有个问题，就是`arr2===arr`，却没有实现二者互不相关。如何处理？如图：</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a9487c395?w=600&amp;h=250&amp;f=jpeg&amp;s=22572)</span><br><span class="line">可以通过: 原始数组`.concat([])`组合成一个新数组，且原数组与之无关。如图：</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94983a00?w=600&amp;h=288&amp;f=jpeg&amp;s=26717)</span><br><span class="line"></span><br><span class="line">添加初始值之后，该如何做呢？</span><br></pre></td></tr></table></figure><p>function  reduce(arr, fn,initValue){<br>                  var arr2 = arr.concat([])  //===[3, 4, 5, 6]<br>                  if(initValue !== undefined){  //这里注意 === 会出现报错<br>                  arr2.unshift(initValue)<br>                }<br>//不等于undefined，表示用户传递了这个initValue参数  </p><pre><code>   while(arr2.length &gt;  1){              console.log(arr2)               arr2.splice(0,2,fn(arr2[0],arr2[1]))         }          return arr2[0]   }  var arr =  [3,  4,  5,  6]  var result =  reduce(arr,  function(v1,v2){               return v1 + v2 },10)              console.log(result)  </code></pre><p>//输出值：<br>          –&gt;  [10,  3,  4,  5,  6]<br>                 [13,  4,  5,  6]<br>                 [17,  5,  6]<br>                  [22,  6]<br>                  28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图：</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94b9cf5e?w=600&amp;h=348&amp;f=jpeg&amp;s=30881)</span><br><span class="line">或者减少代码量，采用三目运算符的方法来设置初始值：</span><br></pre></td></tr></table></figure></p><p>function  reduce(arr, fn,initValue){<br>              var arr2 =<br>              (initValue !== undefined?[]:[initValue]).concat(arr)<br>              while(arr2.length &gt;  1){<br>                  console.log(arr2)<br>                  arr2.splice(0,2,fn(arr2[0],arr2[1]))<br>             }<br>               return arr2[0]<br>       }  </p><pre><code>var arr =  [3,  4,  5,  6]  var result =  reduce(arr,  function(v1,v2){             return v1 + v2 },10)             console.log(result)  </code></pre><p>//输出值<br> –&gt;  [3,  4,  5,  6]<br>         [7,  5,  6]<br>         [12,  6]<br>         18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">图：</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94b5b19f?w=600&amp;h=283&amp;f=jpeg&amp;s=23154)</span><br><span class="line"></span><br><span class="line">### 2、将一个数组拍平</span><br><span class="line">对一个无限次嵌套的数组进行拍平，如何处理？</span><br><span class="line"></span><br><span class="line">例子1：这道题也可以作为一个初级JS的思考，每次不会做的话，先从这道题的基本思考方式来看</span><br></pre></td></tr></table></figure></p><p>var arr =  [3,  [‘4,5’,7,[1]],  [2,10]  ]<br>           function  flat(){<br>           }  //重点解决这一块的逻辑，即最终返回一个新的数组<br>       var arr2 =  flat(arr) </p><pre><code>console.log(arr2) </code></pre><hr><p> var arr =  [3,  [‘4,5’,7,[1]],  [2,10]  ]<br>            function  flat(arr){<br>                  var arr2 =  []<br>                  arr.forEach(function(val){<br>                   if(Array.isArray(val)){<br>                    arr2 =arr2.concat(flat(val))<br>              }else{<br>                 arr2.push(val)<br>                }<br>           })<br>          return arr2//不是数组的话就返回  } </p><p> /<em>   flat(arr)就是将一个数组拍平，变成一个普通数组，对arr里进行判断，  如果不是个数组（如3），则放在 var arr2 = []里的空数组里，  如果是数组的，即 [‘4,5’,7,[1]]，则把其放在这个arr.forEach(function(val){})数组里执行，则  重点解决函数这一块的逻辑  :<br>1、定义一个要返回的数组arr2<br>2、遍历原始数组arr,且用函数遍历arr的每一项<br>2.1 if判断是否为数组，采用Array.isArray判断。 若是数组，要处理嵌套数组，再次调用函数，将嵌套函数“拍平”，用递归法一一验证，最后得出结果<br>2.2 else如果不是数组，直接push在arr=[]里  </em>/</p><p> var arr2 =  flat(arr) console.log(arr2)  </p><p>//输出结果<br>–&gt; [3, “4,5”, 7, 1, 2, 10]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子2：</span><br><span class="line">实现一个flatten函数，将一个嵌套多层的数组arry（数组）（嵌套可以是任何层数）转换成只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。如：</span><br></pre></td></tr></table></figure></p><p>   flatten（[1,[2],[3,[[4]]]）=&gt; [1,2,3,4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var arr =  [3,[2,-4,[5,7]],-3,[&apos;aa&apos;,[[&apos;bb&apos;]]]]  </span><br><span class="line">var arr2 =  flatten2(arr) </span><br><span class="line">console.log(arr2)  </span><br><span class="line"></span><br><span class="line">/* 方法1： */</span><br><span class="line">              function  flatten(arr)&#123; </span><br><span class="line">                     var newArr =  []  </span><br><span class="line">                      function  _flat(arr)&#123; </span><br><span class="line">                             arr.forEach(val=&gt;&#123;  //对数组的每一项进行一个遍历   val=&gt;，为匿名函数  </span><br><span class="line">                               if(Array.isArray(val))&#123; </span><br><span class="line">                                      _flat(val) </span><br><span class="line">                            &#125;else&#123; </span><br><span class="line">                                 newArr.push(val) </span><br><span class="line">                               &#125;  </span><br><span class="line">                            &#125;) </span><br><span class="line">                       &#125; </span><br><span class="line">                      _flat(arr)  </span><br><span class="line">                         return newArr &#125;  </span><br><span class="line"></span><br><span class="line">/* 方法2： */ </span><br><span class="line"></span><br><span class="line">        function  flatten2(arr)&#123;  </span><br><span class="line">                  return arr.reduce(function(initArr,currentArr)&#123;  </span><br><span class="line">                  return initArr.concat(Array.isArray(currentArr)?flatten2(currentArr):currentArr) </span><br><span class="line">                   &#125;,[])  </span><br><span class="line">              &#125;  </span><br><span class="line"></span><br><span class="line">/*不是数组的话，就concat；如果是数组，则通过再次调用flatten2(Arr)拍平当前数组flatten2(currentArr) */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、针对Array对象做了大幅拓展&quot;&gt;&lt;a href=&quot;#一、针对Array对象做了大幅拓展&quot; class=&quot;headerlink&quot; title=&quot;一、针对Array对象做了大幅拓展&quot;&gt;&lt;/a&gt;一、针对Array对象做了大幅拓展&lt;/h1&gt;&lt;h3 id=&quot;1、Array-isArray-obj&quot;&gt;&lt;a href=&quot;#1、Array-isArray-obj&quot; class=&quot;headerlink&quot; title=&quot;1、Array.isArray(obj)&quot;&gt;&lt;/a&gt;1、&lt;code&gt;Array.isArray(obj)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于判断一个变量（或对象）是否为数组，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Array.isArray([])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Array.isArray(&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES5" scheme="http://yoursite.com/tags/ES5/"/>
    
      <category term="数组拓展" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：06-3 [Array]</title>
    <link href="http://yoursite.com/2018/08/17/30-06.3%20%5BArray%5D/"/>
    <id>http://yoursite.com/2018/08/17/30-06.3 [Array]/</id>
    <published>2018-08-16T16:47:44.000Z</published>
    <updated>2018-08-16T16:59:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、数组基本使用"><a href="#一、数组基本使用" class="headerlink" title="一、数组基本使用"></a>一、数组基本使用</h1><h3 id="1、如何去声明一个数组"><a href="#1、如何去声明一个数组" class="headerlink" title="1、如何去声明一个数组"></a>1、如何去声明一个数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 值 ]</span><br></pre></td></tr></table></figure><p>值里面可以是数据类型中的任何一个，如数字、字符串、对象、函数、数组等任何<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3，4，5]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>题外话：</strong> 数组正（fu）规（za）的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array(3,4,5)  </span><br><span class="line">//(3)  [3,  4,  5]</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cc590e84b435?w=600&amp;h=245&amp;f=jpeg&amp;s=14614" alt="image"></p><h3 id="2、length（表示数组的个数）"><a href="#2、length（表示数组的个数）" class="headerlink" title="2、length（表示数组的个数）"></a>2、length（表示数组的个数）</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure></p><p>（1）如何获取数组的最后一位具体数值？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[arr.length-1]</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr =  [4,5,6]  </span><br><span class="line">//(3)[4,5,6] </span><br><span class="line"></span><br><span class="line">arr[arr.length-1]  </span><br><span class="line">//6</span><br></pre></td></tr></table></figure></p><p>（2）用<code>arr.length=0</code>来清空数组，变成空数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length=0  --&gt;0 arr --&gt;[]</span><br></pre></td></tr></table></figure></p><p>（3）length如何进行截断（截断一词，是我自己想的，很形象了😂）<br>假设：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [4,5,6] </span><br><span class="line">//undefined</span><br><span class="line">arr</span><br><span class="line">// (3)  [4,  5,  6]</span><br><span class="line"> arr[100]=100  </span><br><span class="line">//100 </span><br><span class="line">arr.length </span><br><span class="line">//101 </span><br><span class="line">arr[3] </span><br><span class="line">// undefined</span><br><span class="line">arr[99] </span><br><span class="line">//undefined</span><br><span class="line">arr[100]  </span><br><span class="line">//100</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>然后，我们通过设置<code>length</code>进行数组截断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.length =  2  </span><br><span class="line">//2 </span><br><span class="line">arr </span><br><span class="line">//(2)  [4,  5]</span><br></pre></td></tr></table></figure></p><h3 id="3、下标使用"><a href="#3、下标使用" class="headerlink" title="3、下标使用"></a>3、下标使用</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[下标位数]</span><br></pre></td></tr></table></figure></p><p>（1）用下标访问数组的每一个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr =  [4,5,6]  </span><br><span class="line">//(3)[4,5,6] </span><br><span class="line">arr[0]  </span><br><span class="line">// 4 </span><br><span class="line">/* 或 */</span><br><span class="line">arr[1]  </span><br><span class="line">//  5</span><br><span class="line">/* 或 */</span><br><span class="line">arr[2] </span><br><span class="line"> // 6</span><br></pre></td></tr></table></figure></p><p>（2）用下标去赋值,假设<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[2]  =100</span><br><span class="line"> arr </span><br><span class="line">//  (3)  [3,  4,  100]</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//为不存在位数赋值</span><br><span class="line"> arr[3]=101</span><br><span class="line">//101 </span><br><span class="line">arr </span><br><span class="line">//(4)  [3,  4,  100,  101]</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[100]=10  </span><br><span class="line">//10 </span><br><span class="line">arr </span><br><span class="line">// (101)  [3,  4,  100,  101, empty × 96,  10]</span><br></pre></td></tr></table></figure></p><p>图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cc590e8bd513?w=600&amp;h=225&amp;f=jpeg&amp;s=11366" alt="image"></p><h3 id="4、使用for循环遍历length，得出数组里具体的值"><a href="#4、使用for循环遍历length，得出数组里具体的值" class="headerlink" title="4、使用for循环遍历length，得出数组里具体的值"></a>4、使用for循环遍历length，得出数组里具体的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr =[4,5,6] </span><br><span class="line">//(3)  [4,  5,  6] </span><br><span class="line"></span><br><span class="line"> for(var i=0;i&lt;arr.length;i++)&#123; </span><br><span class="line">       console.log(arr[i]) </span><br><span class="line"> &#125;  </span><br><span class="line">//4  5  6</span><br></pre></td></tr></table></figure><h1 id="二、数组的一些操作"><a href="#二、数组的一些操作" class="headerlink" title="二、数组的一些操作"></a>二、数组的一些操作</h1><h3 id="1、栈方法：在数组里最后一位进行新增、删除操作"><a href="#1、栈方法：在数组里最后一位进行新增、删除操作" class="headerlink" title="1、栈方法：在数组里最后一位进行新增、删除操作"></a>1、栈方法：在数组里最后一位进行新增、删除操作</h3><p>这是数组中的一种栈方法，能够让我们使用堆栈那样先入后出使用数组<br>（1）新增（于最后一位）：<code>push</code><br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.push()</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.push(&apos;wangxiaoqin&apos;)  </span><br><span class="line">//  4  //返回值输出位数 </span><br><span class="line">arr </span><br><span class="line">//(4)  [4,  5,  6,  &quot;wangxiaoqin&quot;]</span><br></pre></td></tr></table></figure></p><p>（2）去除（掉最后一位）：<code>pop</code><br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.pop()</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.push(&apos;wangxiaoqin&apos;) </span><br><span class="line">// 4  //返回值输出位数 </span><br><span class="line">arr </span><br><span class="line">//(4)  [4,  5,  6,  &quot;wangxiaoqin&quot;]</span><br><span class="line"> arr.pop()  //或console.log(arr.pop())，对应变量是一个结果（或方法） </span><br><span class="line">//&quot;wangxiaoqin&quot; </span><br><span class="line">arr </span><br><span class="line">//(3)  [4,  5,  6]</span><br></pre></td></tr></table></figure></p><h3 id="2、队列方法：数组里第一位新增、删除"><a href="#2、队列方法：数组里第一位新增、删除" class="headerlink" title="2、队列方法：数组里第一位新增、删除"></a>2、队列方法：数组里第一位新增、删除</h3><p>这是数组中的一种队列方法，先入先出的队列法使用数组</p><p>（1）新增（于第一位）：<code>unshift</code><br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift()</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(&apos;wangxiaoqin&apos;) </span><br><span class="line">//4 </span><br><span class="line">arr </span><br><span class="line">//(4)  [&quot;wangxiaoqin&quot;,  4,  5,  6]</span><br></pre></td></tr></table></figure></p><p>（2）删除（掉第一位）：<code>shift</code><br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.shift()</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(&apos;wangxiaoqin&apos;) </span><br><span class="line">//4 </span><br><span class="line">arr </span><br><span class="line">//(4)  [&quot;wangxiaoqin&quot;,  4,  5,  6] </span><br><span class="line">arr.shift()  </span><br><span class="line">//&quot;wangxiaoqin&quot; </span><br><span class="line">arr</span><br><span class="line">//(3)  [4,  5,  6]</span><br></pre></td></tr></table></figure></p><h3 id="3、在数组的任意位置新增、删除"><a href="#3、在数组的任意位置新增、删除" class="headerlink" title="3、在数组的任意位置新增、删除"></a>3、在数组的任意位置新增、删除</h3><p>（1）<code>splice</code>:删除、新增、替换、修改</p><p><strong>A、语法：</strong><br><code>arr.splice  (star位数,length/替换值,具体值)</code></p><p><strong>B、用处：</strong></p><p>用于一次性解决数组添加、删除（二者结合可达到替换效果）</p><p><strong>C、三个参数：</strong></p><ul><li>开始索引</li><li><p>删除元素的位移<br>如：指定前两个参数，可以使用<code>splice</code>删除数组元素，同样会带来索引调整及length调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [1,2,3,4,5]  </span><br><span class="line">// undefined</span><br><span class="line">arr.splice(1,3)//从下标1开始（包括下标1的值2），删除3个，所以数组元素为2，3，4 均被删除  </span><br><span class="line">//(3)  [2,  3,  4]   //所输出的a.splice所执行的结果，是一个新数组为[2, 3, 4]</span><br><span class="line"> arr.length </span><br><span class="line">//2</span><br><span class="line">arr </span><br><span class="line">//(2)  [1,  5]    //同时arr本身剩下[1,5]</span><br></pre></td></tr></table></figure></li><li><p>插入（替换）新元素（可以多写几个）</p></li></ul><p>如：插入和替换，如果从第几个位开始做替换，替换的数组元素个数为0，即把0个元素替换成我需要的数组元素，则是使用<code>splice</code>插入法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr =[1,2,3,4,5] </span><br><span class="line">--&gt;  undefined</span><br><span class="line">arr.splice(1,0,9,99,999)  //从下标1开始，即数组元素2前面，替换（其实就是插入）9，99，999三个数组元素  </span><br><span class="line">//  [] </span><br><span class="line">arr.length </span><br><span class="line">//  8 </span><br><span class="line">arr</span><br><span class="line">//  (8)  [1,  9,  99,  999,  2,  3,  4,  5]</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong> </p><p>这样的插入法，是连续性的，不在同一脚本同一时刻进行不同位数的插入。执行数组插入（替换）是一次完成，数组本身长度发生变化</p><p><strong>实例：</strong></p><p>如怎么去掉数组里的负数值，先看一个错误示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr =[3,  4,  -3,  -2,  -1,  5]  </span><br><span class="line">  --&gt; undefined </span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123; </span><br><span class="line">              if(arr[i]&lt;0)&#123;  //数组里的具体值 </span><br><span class="line">               arr.splice(i,1)  //此时执行完下标为2的-3值，得出新数组[3, 4, -2, -1, 5]  //继续执行i++,此时i=3,此时数组元素-1下标为3，直接跳过数组元素-2的下标</span><br><span class="line">              &#125;  </span><br><span class="line">&#125; </span><br><span class="line">//  [-1] </span><br><span class="line">arr </span><br><span class="line">//  (4)  [3,  4,  -2,  5]</span><br></pre></td></tr></table></figure></p><p>正确示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    var arr =[3,  4,  -3,  -2,  -1,  5]  </span><br><span class="line">// undefined </span><br><span class="line">      for(var i=0;i&lt;arr.length;i++)&#123; </span><br><span class="line">                    if(arr[i]&lt;0)&#123;</span><br><span class="line">                  arr.splice(i,1) </span><br><span class="line">                   i --  //通过退回下标，可执行忽略的那个位数上的数组元素  </span><br><span class="line">                   &#125;  </span><br><span class="line">             &#125; </span><br><span class="line">//undefined</span><br><span class="line">     arr </span><br><span class="line"> //(3)  [3,  4,  5]</span><br></pre></td></tr></table></figure></p><ul><li><code>splice</code>方法返回一个由删除元素组成的新数组，没有删除则返回空数组，则原数组发生改变,如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3,4,5] </span><br><span class="line">// undefined</span><br><span class="line">arr</span><br><span class="line">//(3)  [3,  4,  5] </span><br><span class="line">arr.splice(1,2)  //从下标为1的元素开始，拿出来2个元素作为一个数组返回，原数组发生改变  </span><br><span class="line">//(2)  [4,  5] </span><br><span class="line">arr </span><br><span class="line">//[3]  //原数组发生改变</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.push(8,9,10) </span><br><span class="line"> --&gt;  6 </span><br><span class="line">arr </span><br><span class="line">--&gt;  (6)  [4,  5,  6,  8,  9,  10] </span><br><span class="line">arr.splice(2,0,1,2,3)  //从下标为2的位置（元素6）前开始，删除0个，新增两个元素(在6前面新增8,9,10)  </span><br><span class="line">--&gt;  [] </span><br><span class="line">arr </span><br><span class="line">--&gt;  (9)  [4,  5,  1,  2,  3,  6,  8,  9,  10]</span><br></pre></td></tr></table></figure><p>（2）<code>slice</code><br>语法：<br><code>arr.splice(star,end)</code></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr </span><br><span class="line">// (9)  [4,  5,  1,  2,  3,  6,  8,  9,  10] </span><br><span class="line">arr.slice(2,3)/*从arr下标为2开始，到下标为3结束(不包括3)，做为新数组，原数组不变 */</span><br><span class="line"> // [1] </span><br><span class="line">arr </span><br><span class="line">// (9)  [4,  5,  1,  2,  3,  6,  8,  9,  10]</span><br></pre></td></tr></table></figure></p><h3 id="4、join（加入一个任意字符串（甚至空字符串））"><a href="#4、join（加入一个任意字符串（甚至空字符串））" class="headerlink" title="4、join（加入一个任意字符串（甚至空字符串））"></a>4、<code>join</code>（加入一个任意字符串（甚至空字符串））</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join()  //灵活应对</span><br></pre></td></tr></table></figure><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3,4,5] </span><br><span class="line">// undefined</span><br><span class="line">arr</span><br><span class="line">// (3)  [3,  4,  5] </span><br><span class="line">arr.join(&apos;-&apos;)  </span><br><span class="line">// &quot;3-4-5&quot; </span><br><span class="line">/* 或 */</span><br><span class="line">arr.join(&apos;.&apos;) </span><br><span class="line">// &quot;3.4.5&quot;</span><br></pre></td></tr></table></figure></p><h3 id="5、reverse（数组里的值进行倒序（本身发生变化））"><a href="#5、reverse（数组里的值进行倒序（本身发生变化））" class="headerlink" title="5、reverse（数组里的值进行倒序（本身发生变化））"></a>5、<code>reverse</code>（数组里的值进行倒序（本身发生变化））</h3><p>倒序法，会修改原数组</p><p>语法：<br><code>arr.reverse()</code></p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr=[3,4,5,6,7,8]  </span><br><span class="line">// undefined</span><br><span class="line">arr</span><br><span class="line">// (6)  [3,  4,  5,  6,  7,  8] </span><br><span class="line">arr.reverse()  </span><br><span class="line">// (6)  [8,  7,  6,  5,  4,  3]</span><br></pre></td></tr></table></figure></p><p>假如，当数组索引（下标）不是连续或以0 开始，结果需要注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a =  [1,2,3,4,5] </span><br><span class="line"> // undefined</span><br><span class="line">a =[]  </span><br><span class="line">// [] </span><br><span class="line">a[2]=2 </span><br><span class="line">// 2 </span><br><span class="line">a[3]=3  </span><br><span class="line">// 3 </span><br><span class="line">a[7]=4  </span><br><span class="line">// 4 </span><br><span class="line">a[8]=5  </span><br><span class="line">// 5 </span><br><span class="line">a.reverse()  </span><br><span class="line">// (9)  [5,  4, empty × 3,  3,  2, empty × 2]</span><br></pre></td></tr></table></figure></p><h3 id="6、concat（合成两个数组）"><a href="#6、concat（合成两个数组）" class="headerlink" title="6、concat（合成两个数组）"></a>6、<code>concat</code>（合成两个数组）</h3><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a =  [1,  2,  3,  4,  5] </span><br><span class="line"> --&gt;undefined </span><br><span class="line">var b =  [6,  7,  8,  9] </span><br><span class="line"> --&gt;undefined</span><br><span class="line">a.concat(b)  </span><br><span class="line">// (9)  [1,  2,  3,  4,  5,  6,  7,  8,  9]  //返回一个新数组，由于原数组保持不变，所以需要为这个数组赋值一个新变量 </span><br><span class="line">a</span><br><span class="line">// (5)  [1,  2,  3,  4,  5]  //原数组保持不变</span><br><span class="line"> b </span><br><span class="line">// (4)  [6,  7,  8,  9]  //原数组保持不变</span><br></pre></td></tr></table></figure></p><h3 id="7、sort（对数组进行排序）"><a href="#7、sort（对数组进行排序）" class="headerlink" title="7、sort（对数组进行排序）"></a>7、<code>sort</code>（对数组进行排序）</h3><p>排序法，是一种内部的排序。可排序数字、字符串</p><p>语法：<br><code>a.sort()</code></p><p>如：</p><ul><li><p><strong>对数字</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a=[5,4,3,2,1] </span><br><span class="line"> // undefined</span><br><span class="line">a.sort()  </span><br><span class="line">// (5)  [1,  2,  3,  4,  5]</span><br></pre></td></tr></table></figure></li><li><p><strong>对字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a=[5,&quot;a&quot;,  &quot;c&quot;,  &quot;h&quot;,  &quot;z&quot;] </span><br><span class="line">// undefined</span><br><span class="line">a.sort() </span><br><span class="line">// (5)  [5,  &quot;a&quot;,  &quot;c&quot;,  &quot;h&quot;,  &quot;z&quot;]</span><br></pre></td></tr></table></figure></li></ul><p>但是假如，这样排序，结果则不是按顺序排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a=[7,8,9,10,11]  </span><br><span class="line">// undefined</span><br><span class="line">a.sort() </span><br><span class="line">// (5)[10,  11,  7,  8,  9]</span><br></pre></td></tr></table></figure></p><p>不加参数用<code>sort</code>排序法直接排序，它会将数组里的元素当成字符串去排序。按照字母表排序，7就比10大，这时候我们可以在<code>sort</code>内部传入自定义排序函数（比较函数）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var a=[7,8,9,10,11] </span><br><span class="line"> --&gt;undefined</span><br><span class="line">a.sort() </span><br><span class="line">// (5)  [10,  11,  7,  8,  9]</span><br><span class="line"> a.sort(function(v1,v2)&#123;</span><br><span class="line">                return v1-v2 </span><br><span class="line">           &#125;) </span><br><span class="line">// (5)  [7,  8,  9,  10,  11]</span><br><span class="line"></span><br><span class="line">/*或者*/</span><br><span class="line"></span><br><span class="line">var friends =  [&#123;age:3,name:&apos;dog&apos;&#125;,&#123;age:2,name:&apos;cat&apos;&#125;,&#123;age:4,name:&apos;bird&apos;&#125;] </span><br><span class="line"> --&gt;undefined</span><br><span class="line">friends.sort(function(v1,v2)&#123;  </span><br><span class="line">             return v1.age -v2.age </span><br><span class="line">               &#125;) </span><br><span class="line">          // --&gt;(3)  [&#123;…&#125;,  &#123;…&#125;,  &#123;…&#125;]  </span><br><span class="line">                   --&gt;0:  &#123;age:  2, name:  &quot;cat&quot;&#125;  </span><br><span class="line">                        1:  &#123;age:  3, name:  &quot;dog&quot;&#125; </span><br><span class="line">                        2:  &#123;age:  4, name:  &quot;bird&quot;&#125; length: 3__proto__:  Array(0) </span><br><span class="line">              friends </span><br><span class="line">             //--&gt;(3)  [&#123;…&#125;,  &#123;…&#125;,  &#123;…&#125;] </span><br><span class="line">                       friends.sort(function(v1,v2)&#123; </span><br><span class="line">                                 return v1.name &gt; v2.name </span><br><span class="line">                       &#125;)  </span><br><span class="line">              //--&gt;(3)  [&#123;…&#125;,  &#123;…&#125;,  &#123;…&#125;]  </span><br><span class="line">                      --&gt;  0:  &#123;age:  4, name:  &quot;bird&quot;&#125;  </span><br><span class="line">                             1:  &#123;age:  2, name:  &quot;cat&quot;&#125;  </span><br><span class="line">                             2:  &#123;age:  3, name:  &quot;dog&quot;&#125; </span><br><span class="line">                             length: 3__proto__:  Array(0)</span><br></pre></td></tr></table></figure></p><h1 id="三、如何创建一个数组"><a href="#三、如何创建一个数组" class="headerlink" title="三、如何创建一个数组"></a>三、如何创建一个数组</h1><h3 id="1、通过构造函数"><a href="#1、通过构造函数" class="headerlink" title="1、通过构造函数"></a>1、通过构造函数</h3><p>数组，作为一个特殊对象，通过传统的<code>newArray</code>创建数组</p><h3 id="2、通过使用字面量"><a href="#2、通过使用字面量" class="headerlink" title="2、通过使用字面量"></a>2、通过使用字面量</h3><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=  [5] </span><br><span class="line">// undefined</span><br><span class="line">a.length </span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong><br>使用带初始化参数的方式创建数组的时候，最好最后不要带多余的<code>,</code>，在不同的浏览器下对此处理方式不一样，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a1 =  [1,2,3,]</span><br><span class="line">//该脚本在现代浏览器上运行结果和我们设想一样，长度是3，但是在低版本IE下确实长度为4的数，而最后一条数据是undefined,就会造成误会 。</span><br><span class="line">      console.log(a1.length) </span><br><span class="line">      console.log(a1)</span><br></pre></td></tr></table></figure></p><h1 id="四、数组的索引、长度"><a href="#四、数组的索引、长度" class="headerlink" title="四、数组的索引、长度"></a>四、数组的索引、长度</h1><p>数组也是对象，我们可以使用索引的奥秘在于，数组会把索引值转换为对应字符串（如 <code>1=&gt;“1”</code>）作为对象属性名<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr =[1,2,3,4] arr[0]  </span><br><span class="line">// 1 </span><br><span class="line"> var i =  1 </span><br><span class="line">console.log(arr[i])  </span><br><span class="line">// 2</span><br><span class="line">console.log(arr[++i])  </span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p><p><strong>题外话：</strong> </p><p>不过在做这道题的时候，我发现一旦没有深刻理解操作符和运行机制的话，会导致结果不同，如：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cc590e9aca0b?w=600&amp;h=214&amp;f=jpeg&amp;s=17246" alt="image"><br>由于<code>i++</code>是后置，运行时按照：先拿i的值——再进行<code>++</code>操作；<code>++i</code>则是前置，运行时按照：先<code>++</code>操作再拿i的值。所以，运行机制上</p><h1 id="五、数组的两三话"><a href="#五、数组的两三话" class="headerlink" title="五、数组的两三话"></a>五、数组的两三话</h1><h3 id="1、数组的底层数据结构"><a href="#1、数组的底层数据结构" class="headerlink" title="1、数组的底层数据结构"></a>1、数组的底层数据结构</h3><p><code>数组 === 特殊的对象</code>（注：对象，由属性和属性值构成）。通过数组和对象的研究可以看出，数组可看成在对象的基础上做了一层的封装，然后自身又增加了一些方法。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr =  [4,5,6] </span><br><span class="line"> //--&gt;(3)  [4,  5,  6] </span><br><span class="line">          //--&gt;0:  4  //展开之后数组的底层数据结构  </span><br><span class="line">                1:  5  </span><br><span class="line">                2:  6</span><br><span class="line">                length:  3 __proto__:  Array(0)</span><br></pre></td></tr></table></figure></p><p>再如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj =  &#123;1:4,2:5,3:6,length:3&#125;  </span><br><span class="line"> //&#123;1:  4,  2:  5,  3:  6, length:  3&#125;//数组底层的数据结构构成</span><br><span class="line">obj[1]  </span><br><span class="line"> // 4</span><br><span class="line">obj.length </span><br><span class="line">//  3</span><br></pre></td></tr></table></figure></p><h3 id="2、数组的一些用法"><a href="#2、数组的一些用法" class="headerlink" title="2、数组的一些用法"></a>2、数组的一些用法</h3><p>（1）关于数组里的属性和值的一些奇怪的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr [-10]  =  &apos;aaa&apos;  </span><br><span class="line">--&gt;  &quot;aaa&quot; </span><br><span class="line">arr [-10]  </span><br><span class="line">--&gt;  &quot;aaa&quot; </span><br><span class="line">arr </span><br><span class="line">  //--&gt;(3)  [4,  5,  6,  -10:  &quot;aaa&quot;]  </span><br><span class="line">       (3)  [4,  5,  6,  -10:  &quot;aaa&quot;]  </span><br><span class="line">         --&gt;  0:  4 </span><br><span class="line">                1:  5  </span><br><span class="line">                 2:  6 </span><br><span class="line">                 -10:  &quot;aaa&quot;  //这是一个很奇怪的属性和值， </span><br><span class="line">            length:  3</span><br><span class="line">            __proto__:  Array(0)</span><br></pre></td></tr></table></figure></p><p>（2）关于数组中删除的问题</p><p>A、首先，删除数组元素，可以直接使用<code>delete</code>，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr =  [3,4,5]  </span><br><span class="line">//undefined</span><br><span class="line">arr </span><br><span class="line">//  (3)  [3,  4,  5]  </span><br><span class="line">delete arr[2]//通过最后的输出，则能知道数组里的是位数属性 </span><br><span class="line"> //true</span><br><span class="line">   arr</span><br><span class="line">// (3)  [3,  4, empty]</span><br><span class="line">      console.log(arr[2])  </span><br><span class="line">// undefined</span><br><span class="line">   undefined</span><br></pre></td></tr></table></figure></p><p>B、以此，我们可以联想到，如果<code>a[2]</code>被赋值为<code>undefined</code>，情况也和<code>delete</code>之后的<code>undefined</code>类似，不会改变数组长度，也不会改变其他数据的<code>index</code>和<code>value</code>对应关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、数组基本使用&quot;&gt;&lt;a href=&quot;#一、数组基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、数组基本使用&quot;&gt;&lt;/a&gt;一、数组基本使用&lt;/h1&gt;&lt;h3 id=&quot;1、如何去声明一个数组&quot;&gt;&lt;a href=&quot;#1、如何去声明一个数组&quot; class=&quot;headerlink&quot; title=&quot;1、如何去声明一个数组&quot;&gt;&lt;/a&gt;1、如何去声明一个数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var arr = [ 值 ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值里面可以是数据类型中的任何一个，如数字、字符串、对象、函数、数组等任何&lt;br&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var arr =  [3，4，5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数组操作" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：06-2{ &quot;JSON&quot; }</title>
    <link href="http://yoursite.com/2018/08/17/29-06.2%7B%20%22JSON%22%20%7D/"/>
    <id>http://yoursite.com/2018/08/17/29-06.2{ &quot;JSON&quot; }/</id>
    <published>2018-08-16T16:47:28.000Z</published>
    <updated>2018-08-16T16:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>JSON，用于数据交换的文本格式（解析之后得到一个相应的对象），是一种数据格式,如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> &quot;name&quot;:&quot;wangxiaoqin&quot;, </span><br><span class="line"> &quot;age&quot;:3</span><br><span class="line">  &#125;  </span><br><span class="line">//  &#123;name:  &quot;wangxiaoqin&quot;, age:  3&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="二、Json对值得类型和格式有严格规定"><a href="#二、Json对值得类型和格式有严格规定" class="headerlink" title="二、Json对值得类型和格式有严格规定"></a>二、Json对值得类型和格式有严格规定</h1><ul><li>复合类型的值：数组、对象（不能是函数、正则表达式对象、日期对象）</li><li>简单类型的值：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>Infinity</code>和<code>undefined</code>）</li><li>字符串必须使用双引号（不能使用单引号）</li><li>对象的键名必须放在双引号里面。</li><li>数组或对象最后一个成员的后面不能加逗号</li></ul><h3 id="1、合格的-JSON-值"><a href="#1、合格的-JSON-值" class="headerlink" title="1、合格的 JSON 值"></a>1、合格的 JSON 值</h3><p><strong>注：</strong>合格的 JSON 值：空数组<code>[ ]</code> 、  空对象<code>{}</code> 、<code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]  </span><br><span class="line">&#123;  &quot;one&quot;:  1, &quot;two&quot;:  2, &quot;three&quot;: 3 &#125; </span><br><span class="line">&#123;&quot;names&quot;:  [&quot;张三&quot;,  &quot;李四&quot;]  &#125; </span><br><span class="line">[ &#123;  &quot;name&quot;: &quot;张三&quot;&#125;, &#123;&quot;name&quot;:  &quot;李四&quot;&#125; ]</span><br></pre></td></tr></table></figure></p><h3 id="2、不合格的JSON值"><a href="#2、不合格的JSON值" class="headerlink" title="2、不合格的JSON值"></a>2、不合格的JSON值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;name: &quot;张三&quot;, &apos;age&apos;: 32 &#125;  // 属性名必须使用双引号 </span><br><span class="line"></span><br><span class="line">[32,  64,  128,  0xFFF]    //不能使用十六进制值 0xFFF </span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:  &quot;张三&quot;,  &quot;age&quot;: undefined&#125;  //不能使用undefined </span><br><span class="line"> </span><br><span class="line">&#123;&quot;name&quot;:  &quot;张三&quot;,  </span><br><span class="line">          &quot;birthday&quot;:  new  Date(&apos;Fri, 26 Aug 2011 07:13:10 GMT&apos;),  </span><br><span class="line">          &quot;getName&quot;: function() &#123;  </span><br><span class="line">               return this.name;  </span><br><span class="line">                 &#125; </span><br><span class="line">        &#125;   //不能使用函数和日期对象</span><br></pre></td></tr></table></figure><h1 id="三、如何JS中处理JSON格式数据"><a href="#三、如何JS中处理JSON格式数据" class="headerlink" title="三、如何JS中处理JSON格式数据"></a>三、如何JS中处理JSON格式数据</h1><h3 id="1、把一个符合JSON格式规则的字符串解析成对象——JSON-parse"><a href="#1、把一个符合JSON格式规则的字符串解析成对象——JSON-parse" class="headerlink" title="1、把一个符合JSON格式规则的字符串解析成对象——JSON.parse()"></a>1、把一个符合JSON格式规则的字符串解析成对象——<code>JSON.parse()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str =  &apos;&#123;&quot;name&quot;:&quot;wangxiaoqin&quot;,&quot;age&quot;:3&#125;&apos; </span><br><span class="line">JSON.parse(str)  </span><br><span class="line">//&#123;name:  &quot;wangxiaoqin&quot;, age:  3&#125; </span><br><span class="line"></span><br><span class="line">/*调用单独属性*/</span><br><span class="line"> JSON.parse(str).age</span><br><span class="line"> // 3</span><br><span class="line"> JSON.parse(str).name </span><br><span class="line">//&quot;wangxiaoqin&quot;</span><br></pre></td></tr></table></figure><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cc0d90bb1b50?w=600&amp;h=307&amp;f=jpeg&amp;s=24615" alt="image"></p><p><strong>题外话：</strong></p><p><strong>深拷贝的另一种写法</strong></p><p>利用<code>JSON.parse()</code>实现一个简单数据的<strong>深拷贝</strong> ，对象转字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj =  &#123;</span><br><span class="line">       name:  &apos;hunger&apos;, </span><br><span class="line">       age:  3, </span><br><span class="line">       friends:  [&apos;aa&apos;,  &apos;bb&apos;,  &apos;cc&apos;]  </span><br><span class="line">        &#125;//定义一个对象  </span><br><span class="line"></span><br><span class="line">/* 将对象解析成字符串 */</span><br><span class="line"> JSON.stringify(obj)  </span><br><span class="line">//&quot;&#123;&quot;name&quot;:&quot;hunger&quot;,&quot;age&quot;:3,&quot;friends&quot;:[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]&#125;&quot;  </span><br><span class="line"></span><br><span class="line">/* 再把字符串解析成对象 */  </span><br><span class="line">JSON.parse(JSON.stringify(obj)) </span><br><span class="line">//&#123;name:  &quot;hunger&quot;, age:  3, friends:  Array(3)&#125; </span><br><span class="line"></span><br><span class="line"> //深拷贝：相当于重组对象，外观一样，内核已变</span><br></pre></td></tr></table></figure></p><h3 id="2、把一个JS对象解析成字符串——JSON-stringify"><a href="#2、把一个JS对象解析成字符串——JSON-stringify" class="headerlink" title="2、把一个JS对象解析成字符串——JSON.stringify()"></a>2、把一个JS对象解析成字符串——<code>JSON.stringify()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj =  &#123;a:1, b:2&#125;</span><br><span class="line">//&#123;a:  1, b:  2&#125; </span><br><span class="line"></span><br><span class="line">JSON.stringify(obj)  </span><br><span class="line">//&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 解析为字符串值符合JSON格式 */</span><br></pre></td></tr></table></figure><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cc0d90cd0ea8?w=600&amp;h=298&amp;f=jpeg&amp;s=15301" alt="image"></p><h1 id="四、Javascript对象和JSON的关系"><a href="#四、Javascript对象和JSON的关系" class="headerlink" title="四、Javascript对象和JSON的关系"></a>四、Javascript对象和JSON的关系</h1><ul><li>javascript对象的字面量写法只是长的像 JSON 格式数据（JS属于模仿JSON），二者属于不同的范畴</li><li>JavaScript 对象中很多类型(函数、正则、<code>Date</code>) ，JSON 格式的规范并不支持</li><li>JavaScript 对象的字面量写法更宽松（如可不为属性名引号）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h1&gt;&lt;p&gt;JSON，用于数据交换的文本格式（解析之后得到一个相应的对象），是一种数据格式,如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;quot;name&amp;quot;:&amp;quot;wangxiaoqin&amp;quot;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;quot;age&amp;quot;:3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  &amp;#123;name:  &amp;quot;wangxiaoqin&amp;quot;, age:  3&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：06-1{对象}</title>
    <link href="http://yoursite.com/2018/08/17/28-06.1%7B%E5%AF%B9%E8%B1%A1%7D/"/>
    <id>http://yoursite.com/2018/08/17/28-06.1{对象}/</id>
    <published>2018-08-16T16:27:10.000Z</published>
    <updated>2018-08-16T16:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h1><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p> 本质上是一种无序的数据集合，由若干个“键值对”（又称为：成员）（key-value）构成。其中，键值对，包括键名（key，即成员的名称）、键值（value，即成员的值）。<br><a id="more"></a></p><h3 id="2、先前我们对对象的定义："><a href="#2、先前我们对对象的定义：" class="headerlink" title="2、先前我们对对象的定义："></a>2、先前我们对对象的定义：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object()  </span><br><span class="line">// &#123;&#125; </span><br><span class="line">⏬</span><br><span class="line"> var obj =  object() </span><br><span class="line">obj </span><br><span class="line">//&#123;&#125;</span><br></pre></td></tr></table></figure><p>再让我们看看，<code>{}</code>+键值对所定义的对象，让我们再看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj =  &#123;</span><br><span class="line">          p:  &apos;Hello World&apos; </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>这样看来，相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object()  ===  &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>例子中，<code>{}</code>定义了一个对象，且被赋值给变量obj。这个对象内部包含一个键值对，P为“键名”，字符串<code>hello world</code>为“键值”，即：<code>{键名：键值}</code>，包含多对键值对，每个键值对之间用逗号分隔，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o =  &#123; p1:  &apos;Hello&apos;, p2:  &apos;World&apos;  &#125;;</span><br></pre></td></tr></table></figure></p><p>是不是知道对象是什么了？事实上，<code>{key：value}</code>这种写法，在JS中我们把它称为JS的对象字面量（也是数组字面量写法）。让我们继续。。。</p><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><p>首先要定义一个对象</p><h3 id="1、对象的一般写法："><a href="#1、对象的一般写法：" class="headerlink" title="1、对象的一般写法："></a>1、对象的一般写法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    var company =  &#123;</span><br><span class="line">                 name:&apos;wangxiaoqin&apos;</span><br><span class="line">        &#125; </span><br><span class="line"> --&gt;undefined</span><br><span class="line"></span><br><span class="line">/* 调用属性name，输出值：&quot;wangxiaoqin&quot;  */</span><br><span class="line">       company </span><br><span class="line">  //&#123;name:  &quot;wangxiaoqin&quot;&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var company =  &#123; </span><br><span class="line">          name:  &apos;世界你好&apos;, </span><br><span class="line">          age:  3, </span><br><span class="line">           sayHello:  function()&#123;</span><br><span class="line">                   console.log(&apos;hello world&apos;)  </span><br><span class="line">              &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">/* 分别调用各属性和值 */</span><br><span class="line">company.name</span><br><span class="line">//  &quot;世界你好&quot; </span><br><span class="line">company.age </span><br><span class="line">// 3 </span><br><span class="line">company.sayHello()  </span><br><span class="line">//hello world</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653cb7f78868e1b?w=600&amp;h=632&amp;f=jpeg&amp;s=42898" alt="image"></p><h3 id="2、对象里属性值的获取写法："><a href="#2、对象里属性值的获取写法：" class="headerlink" title="2、对象里属性值的获取写法："></a>2、对象里属性值的获取写法：</h3><p>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(company.name)</span><br><span class="line">//变量名.属性名    以此来调用值</span><br><span class="line">``` </span><br><span class="line">方法二：</span><br></pre></td></tr></table></figure></p><p>console.log(company[‘name’])<br>//变量名[‘字符串’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误写法：</span><br></pre></td></tr></table></figure></p><p>company[name]<br> // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 3、新增属性，直接赋值</span><br></pre></td></tr></table></figure></p><p>company.addr =  ‘杭州市’<br>//“杭州市”  </p><p>/<em> 验证：调用变量，输出：{属性：值}  </em>/<br>company<br>//{name:  “世界你好”, age:  3, sayHello: ƒ, addr:  “杭州市”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者</span><br></pre></td></tr></table></figure></p><p>company[‘business’]  =  ‘学习课程’<br>//“学习课程” </p><p>company<br>//  {name:  “世界你好”, age:  3, sayHello: ƒ, addr:  “杭州市”, business:  “学习课程”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4、遍历对象里的属性和值</span><br><span class="line">使用：</span><br></pre></td></tr></table></figure></p><p>for(var 属性名 in 声明的变量）{<br>               console.log(key)<br>               console.log（company[key]）<br>           }<br>//key进行遍历时，每一次循环这个变量key，都能调用key里的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">效果如下：</span><br></pre></td></tr></table></figure></p><p>for(var key in company){<br>             console.log(key)<br>         }<br>// name<br>// age<br>// sayHello<br>//  addr<br>// business<br>// undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而单个的属性名如何调用:</span><br></pre></td></tr></table></figure></p><p>company[key]  === company[‘name’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 三、具体使用</span><br><span class="line">### 1、键名：</span><br><span class="line">（1）键名是字符串（加不加引号都可以）</span><br></pre></td></tr></table></figure></p><p>var o =  { ‘p’: ‘Hello World’};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）键名是数值，会被自动转为字符串</span><br></pre></td></tr></table></figure></p><p>var o ={<br>  1: ‘a’,<br>  3.2: ‘b’,<br>  1e2: true,<br>  1e-2: true,<br>  .234: true,<br>  0xFF: true<br>};</p><p>o<br>// Object {<br>//   1: “a”,<br>//   3.2: “b”,<br>//   100: true,<br>//   0.01: true,<br>//   0.234: true,<br>//   255: true<br>// }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）键名不符合标识符条件：第一个字符为数字、含空格和运算符等，必须加上引号（否则报错），如：</span><br></pre></td></tr></table></figure></p><pre><code>var o =  {       &apos;1p&apos;:  &quot;Hello World&quot;,        &apos;h w&apos;:  &quot;Hello World&quot;,         &apos;p+q&apos;:  &quot;Hello World&quot;  };</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2、键名 === 属性</span><br><span class="line">如果属性值为函数 `===`方法，能像函数那样调用</span><br></pre></td></tr></table></figure><p>var o =  {<br>              p:  function  (x)<br>          {<br>        return  2  * x;<br>         }<br>      };<br>    //p为函数 </p><p>  o.p(1)<br> // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 3、多个对象的属性，用逗号分隔（随意加不加）</span><br><span class="line"></span><br><span class="line">### 4、属性可以动态创建（不一定在对象声明时就指定）</span><br><span class="line">如：对`obj`对象的`foo`属性赋值，结果就在运行时创建了`foo`属性。</span><br></pre></td></tr></table></figure></p><p>var obj =  {};<br>  obj.foo =  123;<br>  obj.foo<br>// 123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5、引用</span><br><span class="line">（1）对象的引用：</span><br><span class="line"></span><br><span class="line">A、不同的变量名指向同一个对象，那么它们（变量名）都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</span><br></pre></td></tr></table></figure></p><p>var o1 =  {};<br> var o2 = o1;</p><p> o1.a =  1;<br>o2.a       // 1 </p><p>o2.b =  2;<br>o1.b      // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B、取消某一个变量对于原对象的引用，不会影响到另一个变量。</span><br></pre></td></tr></table></figure></p><p>var o1 =  {};<br> var o2 = o1;<br> o1 =  1;<br>o2      // {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）传值引用：不同变量名不对同一对象引用，</span><br><span class="line"></span><br><span class="line">第（1）种的引用只限于对象，对原始类型的数据则使用传值引用</span><br><span class="line">当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。</span><br></pre></td></tr></table></figure></p><p>var x =  1;  var y = x; x =  2; y // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6、表达式 ？语句？</span><br></pre></td></tr></table></figure></p><p>{ foo:  123  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作为语句，可能是一个代码区块，里面有一个标签`foo`，指向表达式`123`。` === `如果行首是大括号，一律解释为语句（即代码块），如：</span><br></pre></td></tr></table></figure></p><p>/<em> 假如没有赋值，js引擎默认为块语句 </em>/<br> { foo:123  }  ==={ label：123}<br>–&gt;{foo:  123}<br>       -&gt;foo:  123<br>        -&gt;<strong>proto</strong>: Object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作为表达式，可能是一个包含foo属性的对象`===`,如果要解释为表达式（即对象），必须在大括号前加上圆括号，如：</span><br></pre></td></tr></table></figure></p><p>({ foo:123})<br>   //123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**题外话：关于eval**</span><br><span class="line">（1）将字符串当做JS语句去执行</span><br></pre></td></tr></table></figure></p><p>eval(‘console.log(123)’)<br>//  123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（2）`字符串 === 对象`：</span><br><span class="line"></span><br><span class="line">没有`圆括号 ===块语句===代码块` VS `圆括号===表达式===对象`</span><br></pre></td></tr></table></figure></p><p>eval(‘{foo: 123}’)<br>// 123<br> eval(‘({foo: 123})’)<br> // {foo: 123}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###7、检测变量是否声明（或被定义）</span><br><span class="line">可以在全局作用域中这样检测：</span><br><span class="line">（1）没有声明</span><br></pre></td></tr></table></figure></p><p>‘abc’  in window<br>//  false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）有声明</span><br></pre></td></tr></table></figure></p><p>var hello<br> //undefined<br> ‘hello’  in window<br>// true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8、查看所有属性</span><br><span class="line">查看对象本身的所有属性，可用`Object.key`或使用`for...in`循环遍历。</span><br><span class="line">（1）方法一：`Object.keys`</span><br></pre></td></tr></table></figure></p><p>var o =  {<br>       key1:  1,<br>       key2:  2<br>  };</p><p> Object.keys(o);<br> //(2)  [“key1”,  “key2”]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）方法二：`for...in循环遍历`</span><br></pre></td></tr></table></figure></p><p>var o =  {<br>        key1:  1,<br>        key2:  2<br> };<br> for(var keys in o){<br>            console.log(keys)<br>   }<br>// VM4390:6   key1<br>// VM4390:6   key2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 9、delete命令</span><br><span class="line">（1）删除一个存在的属性：</span><br><span class="line"></span><br><span class="line">两种情况：</span><br><span class="line"></span><br><span class="line">**A、只能删除属性**</span><br></pre></td></tr></table></figure></p><p>var o =  {p:  1};<br> Object.keys(o)<br>//  [“p”]<br>delete o.p -&gt;o.p<br>Object.keys(o)<br>//  []<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**B、不能删除var命令声明的变量**</span><br><span class="line"></span><br><span class="line">var声明的全局变量都是顶层对象的属性，而且默认不得删除。</span><br></pre></td></tr></table></figure></p><p>var p =  1;<br>delete p   // false<br>delete    window.p   // false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（2）删除一个不存在的属性</span><br><span class="line">delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的，只能保证读取这个属性肯定得到`undefined`。</span><br></pre></td></tr></table></figure></p><p>var o =  {};<br>delete o.p // true<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、对象&quot;&gt;&lt;a href=&quot;#一、对象&quot; class=&quot;headerlink&quot; title=&quot;一、对象&quot;&gt;&lt;/a&gt;一、对象&lt;/h1&gt;&lt;h3 id=&quot;1、定义：&quot;&gt;&lt;a href=&quot;#1、定义：&quot; class=&quot;headerlink&quot; title=&quot;1、定义：&quot;&gt;&lt;/a&gt;1、定义：&lt;/h3&gt;&lt;p&gt; 本质上是一种无序的数据集合，由若干个“键值对”（又称为：成员）（key-value）构成。其中，键值对，包括键名（key，即成员的名称）、键值（value，即成员的值）。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="表达式和语句" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="键名和键对" scheme="http://yoursite.com/tags/%E9%94%AE%E5%90%8D%E5%92%8C%E9%94%AE%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>hello，JS：05引用类型和深浅拷贝</title>
    <link href="http://yoursite.com/2018/08/17/27-05%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/08/17/27-05引用类型和深浅拷贝/</id>
    <published>2018-08-16T16:26:51.000Z</published>
    <updated>2018-08-16T16:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本类型VS引用类型"><a href="#一、基本类型VS引用类型" class="headerlink" title="一、基本类型VS引用类型"></a>一、基本类型VS引用类型</h1><p><strong>注：</strong> 这里的内存，为虚拟内存</p><h3 id="1、引用类型："><a href="#1、引用类型：" class="headerlink" title="1、引用类型："></a>1、引用类型：</h3><ul><li>定义：保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象</li><li>包括：对象、数组、函数、正则</li></ul><p>假设变量中有一个函数，函数内东西特别多（或者有一个对象，对象里的数据特别大），这里可选堆的空白处存放函数、对象的数据（随机选择未使用的空白堆，随意变大变小），放在堆中的均为引用类型<br><a id="more"></a></p><h3 id="2、基本类型（值类型）："><a href="#2、基本类型（值类型）：" class="headerlink" title="2、基本类型（值类型）："></a>2、基本类型（值类型）：</h3><ul><li>定义：指的是保存在栈内存中的简单字段（成块排列，栈，允许放进去拿出来）</li><li>包括：数值(number)、布尔值(boolean)、<code>null</code>、<code>undefined</code>、<code>string</code>(在赋值传递中会以引用类型的方式来处理)</li></ul><p>栈里面仍存有变量，只不过存放的不是数据，而是大数据地址，比如这个地址为<code>0x0011</code>,栈内存放的东西，均为可控、较小容量。从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上。</p><h3 id="3、实例一：基本类型"><a href="#3、实例一：基本类型" class="headerlink" title="3、实例一：基本类型"></a>3、实例一：基本类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  var a </span><br><span class="line">  var b </span><br><span class="line">  var obj </span><br><span class="line">  var obj2</span><br><span class="line"> </span><br><span class="line"> a =  1;</span><br><span class="line"> b =  2; </span><br><span class="line"> var obj =  &#123; </span><br><span class="line">     name:  &apos;xiaoqin&apos;, </span><br><span class="line">     sex:  &apos;male&apos;, </span><br><span class="line">      age:  30,</span><br><span class="line">      friend:  &#123; </span><br><span class="line">name:  &apos;hello&apos;, age:  100 </span><br><span class="line">      &#125; </span><br><span class="line"> &#125;  </span><br><span class="line">var newObj =  &#123;&#125;</span><br><span class="line">     b = a; </span><br><span class="line">     console.log(b)</span><br><span class="line">  //返回1</span><br></pre></td></tr></table></figure><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c99908d2458a?w=478&amp;h=372&amp;f=jpeg&amp;s=13231" alt="image"></p><p>（1）基本类型的值被赋值给另一个变量，其实就是分配内存空间<br>一开始，<code>a</code>的值为 1 ，当使用<code>a</code> 来初始化<code>b</code>时，<code>b</code>值此时为1。但<code>b</code>中的1与<code>a</code>中的是完全独立的，该值只是<code>a</code>中的值的一个副本。说明在栈里变量再次变化，但这个两个变量可以参加任何操作而相互不受影响。</p><p><strong>总结：</strong><br>一个变量赋值给另一个变量时，其实是分配了一块新的内存空间。按照以上操作，基本类型在赋值操作后，事实上就<code>a</code>分配了一块新内存空间给<code>b</code>，两个变量是相互不受影响。</p><p>（2）基本类型的比较是值的比较 只有在它们的值相等的时候它们才相等。 当比较的两个值的类型不同的时候<code>==</code>运算符会进行类型转换，但是当两个值的类型相同的时候，即使是<code>==</code>也相当于是<code>===</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = true;</span><br><span class="line">console.log(a == b);//true</span><br></pre></td></tr></table></figure></p><p>（3）基本类型的变量其实就是存放在栈区。结合以上，栈区指内存里的栈内存，但是栈区里包括了变量名和变量值。</p><h3 id="4、实例二：（续上面的例子）引用类型"><a href="#4、实例二：（续上面的例子）引用类型" class="headerlink" title="4、实例二：（续上面的例子）引用类型"></a>4、实例二：（续上面的例子）引用类型</h3><p>（1）引用类型的值是可变的<br>可为引用类型添加属性和方法，也可以删除其属性和方法。<br>看一下这个例子：一个为引用类型的变量赋值给另一个为引用类型的变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  var obj2 = obj //控制台测试一下二者的值</span><br><span class="line"> obj</span><br><span class="line">//  &#123;name:  &quot;ruoyu&quot;, sex:  &quot;male&quot;, age:  30, friend:  &#123;…&#125;&#125; </span><br><span class="line">obj2</span><br><span class="line"> // &#123;name:  &quot;ruoyu&quot;, sex:  &quot;male&quot;, age:  30, friend:  &#123;…&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>值是一样的。因为<code>var obj2=obj</code>，即通过<code>obj</code>的值（一个对象）赋值给<code>obj2</code>，那么<code>obj2</code>的值就是赋值后原本<code>obj</code>对应属性和值。作为一个引用类型，它被放在堆中。所以寻找<code>obj2</code>则在堆里找到，只是换了另一个名字为<code>obj2</code></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c99908e2a777?w=600&amp;h=501&amp;f=jpeg&amp;s=11616" alt="image"></p><p><strong>总结：</strong><br>原本在栈中的对象分别指向了同一个堆，那么存放在堆中即为对象的内存地址。引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。</p><p>（2）引用类型的比较是引用的比较<br>A、我们先看一下基本类型值的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj3 =  &apos;&#123;name: &apos;hello&apos;&#125;&apos;;  </span><br><span class="line">var obj4 =  &apos;&#123;name: &apos;hello&apos;&#125;&apos;;</span><br><span class="line"> console.log( obj3 == obj4 ); </span><br><span class="line"> // true</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong><br>可以得出基本类型的比较：当两个比较值的类型相同(如字符串)的时候，相当于是用 <code>===</code> ，所以输出是true。</p><p>B、再来看一下引用类型值的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj3 =  &#123;name:  &apos;hello&apos;&#125;</span><br><span class="line">var obj4 =  &#123;name:  &apos;hello&apos;&#125;</span><br><span class="line"> obj3 === obj4   </span><br><span class="line"> //返回false，说明二者并不相等</span><br></pre></td></tr></table></figure></p><p>为什么是false？不相等呢？<br>放在栈中的变量 <code>obj3</code>、<code>obj4</code>，声明前置均为<code>undefined</code>，当两者均被被声明值的时候，是两个对象，引用类型是引用访问，相当于在堆中分别开辟了两个空间，堆中会有对应的属性+值，此时这两个对象在堆中存的便是堆的地址。<code>obj4</code>与<code>obj3</code>一样都开辟了新的堆空间，但是存放的地址也不一样。判断<code>obj3</code>是否与<code>obj4</code>相等，看了分析之后，便知道堆存放的地址并不同，二者也就不相等</p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c999091f92e7?w=600&amp;h=397&amp;f=jpeg&amp;s=14312" alt="image"></p><p>（3）引用类型的值是同时保存在栈内存和堆内存中的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function  sum()&#123; </span><br><span class="line">              console.log(&apos;sum...&apos;)</span><br><span class="line">     &#125;  </span><br><span class="line">var sum2 = sum; </span><br><span class="line"> sum2()  </span><br><span class="line">//返回sum... 二者是相等的</span><br></pre></td></tr></table></figure></p><p>我们可以就此分析，函数<code>function sum()</code>,分别有变量<code>sum</code>和函数对象代码（为引用类型，已放在堆中）。之后sum赋值给<code>sum2</code>，即<code>sum2</code>事实上使用的是赋值后<code>sum</code>所指代堆的内存地址,即后续<code>sum</code>和<code>sum2</code>共用了堆里的代码（变量的内存地址就像指针一样，通过JS自身引擎找到这个堆），一堆东西起了两个不同的名字</p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c99908fb2972?w=600&amp;h=291&amp;f=jpeg&amp;s=8420" alt="image"></p><p><strong>总结：</strong> js不同于其他语言，其不允许直接访问内存中的位置，即不能直接操作对象的内存空间，实际上，是操作对象的引用，所以引用类型的值是按引用访问的。</p><p>准确地说，引用类型的存储需内存的栈区（栈区是指内存里的栈内存）和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，然后，栈区内存地址也可以说是该对象在堆内存的地址。</p><h1 id="二、引用类型的实际应用"><a href="#二、引用类型的实际应用" class="headerlink" title="二、引用类型的实际应用"></a>二、引用类型的实际应用</h1><h3 id="1、函数的参数传递"><a href="#1、函数的参数传递" class="headerlink" title="1、函数的参数传递"></a>1、函数的参数传递</h3><p>第1个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function  inc(n)&#123; </span><br><span class="line">          n++; </span><br><span class="line">        &#125;  </span><br><span class="line">var a =  10; </span><br><span class="line"> inc(a)</span><br><span class="line"> console.log(a)  </span><br><span class="line"> </span><br><span class="line">//返回10  </span><br><span class="line"></span><br><span class="line">/*等同于*/</span><br><span class="line"> function  inc()&#123; </span><br><span class="line">       var n = arguments[0] </span><br><span class="line">       n++ </span><br><span class="line">  &#125; </span><br><span class="line"> //在函数的一开始将var a = 10赋值进var n = arguments[0]，  //n=arguments[0]=10,此时与n++为11并没有返回，所以与a并无关系  </span><br><span class="line"></span><br><span class="line">var a =  10  </span><br><span class="line">inc(a)</span><br><span class="line"> console.log(a)</span><br><span class="line"> </span><br><span class="line"> //返回10</span><br></pre></td></tr></table></figure></p><p>✨第2个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     function  incObj(obj)&#123;</span><br><span class="line">     //var obj = o     //0x0001 </span><br><span class="line">       obj.n++ </span><br><span class="line">        &#125; </span><br><span class="line">   var o =  &#123;n:  10&#125;    //o = 0x0001  对其做声明，为一个对象  </span><br><span class="line">   incObj(o)</span><br><span class="line">   console.log(o)  </span><br><span class="line"></span><br><span class="line">//等同于  </span><br><span class="line">      function  incObj()&#123; </span><br><span class="line">                var obj =arguments[0] </span><br><span class="line">                 obj.n++  </span><br><span class="line">          &#125; </span><br><span class="line"> //incObj(o) 相当于function incObj()&#123;var obj =arguments[0]；obj.n++&#125;，</span><br><span class="line">  //可知道obj=arguments[0]=o,相当于设obj为临时变量，而o= 0x0001  var o =  &#123;n:  10&#125;  incObj(o) console.log(o)</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c9990925cc8d?w=600&amp;h=356&amp;f=jpeg&amp;s=19355" alt="image"></p><p><strong>总结：</strong><br>引用类型的本质，变量所存的是这个对象的内存地址指向堆，当去做赋值时是把这个地址进行一个赋值；当去访问的时候是通过这个地址去访问这个对象</p><p>✨第3个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function  squireArr( arr )&#123;  </span><br><span class="line">        //var arr = 0x0011  </span><br><span class="line">           for(var i =  0; i &lt; arr.length; i++)&#123; </span><br><span class="line">                   arr[i]  = arr[i]  * arr[i]; </span><br><span class="line">        &#125;</span><br><span class="line"> &#125; </span><br><span class="line">           var arr =  [2,1,3,6] </span><br><span class="line">           squireArr(arr) </span><br><span class="line">           console.log(arr) </span><br><span class="line">     //(4) [4, 1, 9, 36]</span><br></pre></td></tr></table></figure></p><p>即把<code>function squireArr(arr){}</code>中的数组<code>squireArr(arr)</code>里的每一项变为原来的平方，即参数<code>arr</code>为数组里的值，用for循环进行操作，外界调用时，只需调用一次<code>squireArr(arr)</code>，事实上数组<code>squireArr(arr)</code>操作就是对<code>arr</code>的操作</p><p>✨第4个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        function  squireArr2( arr )&#123; </span><br><span class="line">                  var newArr =  []; </span><br><span class="line">                   for(var i =  0; i &lt; arr.length; i++)&#123; </span><br><span class="line">                              newArr[i]  = arr[i]  * arr[i]; </span><br><span class="line">                       &#125; </span><br><span class="line">                        return newArr; </span><br><span class="line">                   &#125;  </span><br><span class="line">                  var arr2 =  squireArr2(arr) </span><br><span class="line">                  console.log(arr2)  //返回(4) [16, 1, 81, 1296] </span><br><span class="line"></span><br><span class="line">             arr </span><br><span class="line">            // (4)  [4,  1,  9,  36] </span><br><span class="line">arr2 --&gt;  (4)  [16,  1,  81,  1296]</span><br></pre></td></tr></table></figure></p><h3 id="2、对象的深浅拷贝"><a href="#2、对象的深浅拷贝" class="headerlink" title="2、对象的深浅拷贝"></a>2、对象的深浅拷贝</h3><p>针对这个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var obj;  </span><br><span class="line">var obj2;  </span><br><span class="line"> var obj =  &#123;</span><br><span class="line">          name:  &apos;ruoyu&apos;,</span><br><span class="line">          sex:  &apos;male&apos;,</span><br><span class="line">          age:  30, </span><br><span class="line">          friend:  &#123; </span><br><span class="line">            name:  &apos;hello&apos;,</span><br><span class="line">            age:  100 </span><br><span class="line">               &#125; </span><br><span class="line">       &#125;  </span><br><span class="line">      var obj2 = obj;</span><br></pre></td></tr></table></figure></p><p>想要创造一个新的b，那么就需要遍历原始a的每一项属性<code>+</code>值，用来获取成为新个体的b所需的东西，并一一对b进行改造，即从一无所有，改造成与a相似的新个体，此为<strong>克隆</strong>。</p><p>如果在遍历的时候，b这个新个体只是遍历a的前半部分或者局部，那么这称之为<strong>浅拷贝</strong>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function  shallowCopy(oldObj)  &#123; </span><br><span class="line">             var newObj =  &#123;&#125;;  </span><br><span class="line">              for(var i in oldObj)  &#123; </span><br><span class="line">                  if(oldObj.hasOwnProperty(i))  &#123;</span><br><span class="line">                          newObj[i]  = oldObj[i];  </span><br><span class="line">                   &#125; </span><br><span class="line">            &#125;</span><br><span class="line">          return newObj; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>而如果b是遍历原始a的每一项属性和值，但是b又是一个独立个体，与a不相关，当修改b的时候，a仍然不会发生变化，而这叫做<strong>深拷贝</strong>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function  deepCopy(oldObj)  &#123; </span><br><span class="line">           var newObj =  &#123;&#125;; </span><br><span class="line">            for(var key in oldObj)  &#123; </span><br><span class="line">                    if(typeof oldObj[key]  ===  &apos;object&apos;)  &#123;</span><br><span class="line">                       newObj[key]  =  deepCopy(oldObj[key]); </span><br><span class="line">                   &#125;else&#123; </span><br><span class="line">                      newObj[key]  = oldObj[key]; </span><br><span class="line">                             &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                 return newObj;  </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p><strong>json——string——对象</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、基本类型VS引用类型&quot;&gt;&lt;a href=&quot;#一、基本类型VS引用类型&quot; class=&quot;headerlink&quot; title=&quot;一、基本类型VS引用类型&quot;&gt;&lt;/a&gt;一、基本类型VS引用类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 这里的内存，为虚拟内存&lt;/p&gt;
&lt;h3 id=&quot;1、引用类型：&quot;&gt;&lt;a href=&quot;#1、引用类型：&quot; class=&quot;headerlink&quot; title=&quot;1、引用类型：&quot;&gt;&lt;/a&gt;1、引用类型：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象&lt;/li&gt;
&lt;li&gt;包括：对象、数组、函数、正则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设变量中有一个函数，函数内东西特别多（或者有一个对象，对象里的数据特别大），这里可选堆的空白处存放函数、对象的数据（随机选择未使用的空白堆，随意变大变小），放在堆中的均为引用类型&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="引用类型" scheme="http://yoursite.com/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="深拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="http://yoursite.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
</feed>
