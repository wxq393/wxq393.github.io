<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS脚本异步加载]]></title>
    <url>%2F2018%2F08%2F18%2F46-JS%E8%84%9A%E6%9C%AC%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言：在梳理知识点的时候，发现作为浏览器渲染中的机制之一——异步加载机制，当用户访问站点，需要下载各种资源，例如JS脚本，CSS，图片，iframe等，它是实现现代网站进行加载页面时一种必不可少的手段。查资料加上老师拓展课程均对于异步加载机制还有很多方法可以说，故抽出来单独进行一个知识点的梳理。 了解js脚本异步加载前，我们有必要先了解一下浏览器在页面样式和js的作用下出现的两种页面常见场景：白屏和fouc（无样式内容闪烁）。 一、白屏和FOUC1、即指影响浏览器页面加载顺序的两种场景-白屏：特指一种场景，打开页面是一片白色，突然页面出现，样式正确。那么一片白色的时间，则称之为白屏。-FOUC (Flash of UnstyledContent)：无样式内容闪烁，网速情况差，打开页面时仍有样式，之后样式时有时无，甚至一开始并无出现样式，突然样式恢复。（常出现在firefox浏览器） 此类现象，在不同浏览器进行的资源加载和页面渲染时，所采用的不同的处理方式，并不是bug。 2、写一个server，验证白屏和fouc效果在样式文件index.html中12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;fouc &amp; 白屏&lt;/title&gt; &lt;!--在下面模拟一个延时装置--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt; //设置这个工具，当请求该文件时，服务器会延迟请求10s再去加载这个资源，以此可以模拟一个网速特别慢的情况 &lt;link rel=&quot;stylesheet&quot; href=&quot;a.css?t=3&quot;&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;饥人谷&lt;/p&gt;&lt;!-- &lt;script src=&quot;A.js?t=5&quot;&gt;&lt;/script&gt; --&gt; &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/15/1653c442f35af77c?w=211&amp;h=200&amp;f=png&amp;s=8004&quot; alt=&quot;&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;c.css?t=6&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;http://a.jrg.com:8080/B.js?t=4&quot; &gt;&lt;/script&gt; &lt;script src=&quot;http://b.jrg.com:8080/A.js?t=8&quot; &gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; （1）关于白屏，需要注意的是，浏览器对于样式和js的处理，即CSS 和 JS 放置顺序。推荐：将样式放在&lt;head&gt;里面,将JS放在&lt;body&gt;内部下方。 如上面代码所示，html页面里引入了两个css：a.css和b.css。b.css引用了c.ss（@import&quot;./c.css?t=5&quot;;）b.css中加入了一个10s的延时文件（&lt;link rel=&quot;stylesheet&quot;href=&quot;b.css?t=10&quot;&gt;），加载这个10s的css样式文件，浏览器是如何完成加载工作，有两种方式： 第1种： html解析完成，此时10s延时的css文件先不管，先展示&lt;body&gt;里所展示的内容，等css文件全加载后再去计算样式，再去重新渲染一次 第2种： 即使html的dom树已经解析、渲染都完成，对未加载完成的样式都必须等待，即css样式要全部加载、获取，img资源加载完成，此时底部JS立刻执行，才一次性展示出页面。例子中展示这种方法，即为白屏很久的原因。 （2）不同浏览器的不同处理机制所出现的场景不同 A、白屏场景（常出现在chrome）： 打开一个国外网站，使用国外服务器，嵌在css的字体使用的是谷歌字体，运行特别慢，等了好久突然出现页面样式效果。这是因为页面需要等待css样式加载所有完成，甚至出现404加载失败，最后才展示出页面。那么那段加载时间，等待了几秒左右的白色一片的页面，就是白屏 B、Fouc场景（常出现在Firefox）： 一开始的时候，先让你看见样式，如字的小号样式，样式加载完后看到所规定字号的大字。对用户来说，同样的样式，突然从小变大，则这个场景就是Fouc（无样式内容闪烁）。 总结： 不管是css样式，还是js文件，只要加长延时，都会造成白屏 （3）CSS 和 JS 最佳放置顺序 使用 link 标签将样式表放在顶部 将JS放在底部 （3.1）场景：假设JS文件页面顶部： JS脚本会阻塞后面内容的呈现 JS脚本会阻塞其后组件（如图片）的下载 JS加载时间过长，css需等待，则会出现一段时间白屏 场景说明： 引入一个JS文件在顶部，设置一个延时时间。 加载顺序： css—js—img—全部获取到展现页面效果 此时，img和css加载时会并发加载，即如一个域名下同时加载两个文件（并发是有限度的），加载在顶部的js时，会禁用并发img和css，并阻止其他内容下载和渲染。 js并不影响css加载，但是会影响css样式的一个计算。当js加载时，css已经获取到（不过此时页面还是一片空白），直到js获取立即执行后，图片立刻出现，页面才展示效果。所以js文件放入页面顶部&lt;head&gt;里，也会导致白屏现象出现 （3.2）JS加载特点总结 A、优先加载js文件，加载后js立刻去执行，展示页面（CSS样式则是全部加载完，然后一次性展示出页面） 注： css放前面，优先加载；若放后面，其他资源则会阻碍css加载，那么时机就太晚。 B、由于渲染线程和js脚本线程是互斥的，白屏是渲染进程被阻塞的原因，当碰到script标签的时候，会先执行js脚本，然后再渲染。 （放顶部时）JS加载时机过晚导致一系列问题，脚本会阻塞后面内容的呈现、脚本会阻塞其后组件的下载（主要指img资源下载）、白屏等。 （放底部）则可以先让其他先加载完成，JS立刻执行的特点可以“扫尾”最后的页面效果 C、JS脚本操作页面上的html+css元素，（放顶部时）JS先执行，元素都未加载到（即不存在），未出现在文档流中【加载，这里指资源加载和资源是否出现在文档流中】，所以也不能操作相应JS功能，此时后台将会报错。 D、（放顶部时）其他JS若作为一种框架语言，则能提前形成一个初步的框架有效构成页面结构。 二、JS脚本的异步加载1、一个问题？即一个放在的js文件，如下：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 原本放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载呢？ 2、解决方法： async和defer（1）作用：没有 defer 或async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该&lt;script&gt;标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。也就是说，使用defer或async后能够改变这种加载、执行的时机。 常应用在引用了广告和统计的页面中，不会影响、堵塞，更不会影响到到页面其他元素 （2）asyncHTML5里为script标签里新增了async属性，用于异步加载脚本：不保证顺序（独立的个体）123&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;/*或*/&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 浏览器解析到HTML里的该行script标签，发现指定为async，会异步下载解析执行脚本（即加载后续文档元素的过程将和script.js的加载并行进行）。 页面的DOM结构里假设&lt;script&gt;在img之前，如果你的浏览器支持async的话，就会异步加载脚本。此时DOM里已经有img了，所以脚本里能顺利取到img的src并弹框。 （3）defer&lt;script&gt;标签里可以设置defer，表示延迟加载脚本：脚本先不执行，延迟到文档解析和显示后执行，有顺序123&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;/*或*/&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; 浏览器解析到HTML里该行&lt;script&gt;标签，发现指定为defer，会暂缓下载解析执行脚本，等到页面文档解析并加载执行完毕后，才会加载该脚本（更精确地说，是在DOM树构建完成后，在DOMContentLoaded事件触发前，加载defer的脚本）。 页面的DOM结构里假设script在img图片之前，如果你的浏览器支持defer的话，就会延迟到页面加载完后才下载脚本。此时DOM里已经有img元素了，所以脚本里能顺利取到img的src并弹框。 总结： JS实质采用一种可以更自由地选择加载时机和任何位置，让处于顶部的js文件能够像在底部时，在页面必要元素加载完成时进行“异步”加载。 三、同步与异步 同步：等待结果 异步：不等待结果 注意，异步常常伴随回调一起出现，但是异步不是回调，回调也不一定是异步。12345678910111213// 同步的 sleepfunction sleep(seconds)&#123; var start = new Date() while(new Date() - start &lt; seconds * 1000)&#123; &#125; return&#125;console.log(1) sleep(3) //3秒内要不断重复做一些无意义的工作才能保证js运行按顺序console.log(&apos;wake up&apos;)console.log(2)//执行结果的顺序是：打印1——停3s——醒来——打印2，但事实上js环境内，停3s不可能不做事情 12345678同步的 sleep//异步的 sleepfunction sleep(seconds, fn)&#123; setTimeout(fn, seconds * 1000)&#125;console.log(1)sleep(3, ()=&gt; console.log(&apos;wake up&apos;))console.log(2) 画一张同步&amp;异步工作的示意图：可以看出，用了异步之后，JS 的空闲时间多了许多。 但是注意，在 JS 空闲的这段时间，实际上是浏览器中的计时器在工作（很有可能是每过一段时间检查是否时间到了，具体要看 Chrome 代码） 四、遇到异步实例1、前端经常遇到的异步：图片加载是需要时间的12document.getElementsByTagNames(&apos;img&apos;)[0].width // 宽度为 0console.log(&apos;done&apos;) 刚开始是直接获取宽度12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/17/16546d713fd568f0?w=1200&amp;h=799&amp;f=jpeg&amp;s=121670&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;var w = document.getElementsByTagNames(&apos;img&apos;)[0].widthconsole.log(w) 先画一个示意图：由此可知，js在img网络请求还没执行完的时候紧随执行，可知为异步12//先获取网络请求前img信息，为空对象var img = document.getElementsByTagName(&apos;img&apos;)[0] img等待网络请求完成后，获取完整图片信息后，便会触发一个onload事件：12345//等待完成之后执行的内容：img如果加载成功，就会触发一个onload的事件，获取它的宽度并打印出宽度img.onload = function()&#123; var w =img.width console.log(w)&#125; ✨完整代码：1234567891011121314var img = document.getElementsByTagName(&apos;img&apos;)[0]//异步不等继续执行，异步回调函数：等待到网络请求完成后触发onload事件img.onload = function()&#123; var w =img.width console.log(w)&#125;console.log(img.width)/*或*/document.getElementsByTagNames(&apos;img&apos;)[0].onload = function()&#123; console.log(this.width) // 宽度不为 0 console.log(&apos;real done&apos;)&#125;console.log(&apos;done&apos;) 总结： 异步想拿到一个结果，常采用监听一个事件，然后告知（这个事件的完成时间不确定，不可预测），那就可以挂一个函数在onload上，等你请求完成，调用一下onload事件，此为回调函数。 2、面试题中的异步1234567let liList = document.querySelectorAll(&apos;li&apos;)for(var i=0; i&lt;liList.length; i++)&#123; liList[i].onclick = function()&#123; console.log(i) &#125;&#125;//获取dom结构的所有li元素，获取li的长度去遍历，每一个点击后都能打印出东西 把 var i 改成 let 就可以破解：https://zhuanlan.zhihu.com/p/28140450 先让我运行上面的js代码：这里，js代码运行，还要注意一个技巧：变量提升，即 var i = 0 【关键点】变量提升为：12var ii =0 那么，代码如下：1234567let liList = document.querySelectorAll(&apos;li&apos;)var i //i是贯穿6次循环的一个变量（没有多个）for(i=0; i&lt;liList.length; i++)&#123; liList[i].onclick = function()&#123; console.log(i) &#125;&#125; 画一个时序图： 可以看出，js执行代码时，当i=5，i++结果为6的时候，并不小于liList.length，那么就跳出该循环，最后输出结果：i=6。js代码执行完，用户开始操作他的鼠标，假设等待3ms后，执行click li，当你最先click的时候（i=0，liList[0]，此时js已经执行完代码，输出i = 6 ），而不是在绑定事件的时候打印出几，就是几。 在这里，我们有必要知道，异步函数以下绑定事件为：123XXXX.onclick function()&#123; console.log(i) &#125; 浏览器并未等该异步执行，直接进入for循环，直接将i=6输出，然后第一个click才出现，浏览器不会等click出现才去打印i 值如何解决？——使用let 假设你已经知道let（不懂看这篇文章）：方应杭：我用了两个月的时间才理解let 将代码var i改为let：123456let liList = document.querySelectorAll(&apos;li&apos;)for(let i=0; i&lt;liList.length; i++)&#123; liList[i].onclick = function()&#123; console.log(i) &#125;&#125; 运行如下：为何let能一一打印出结果呢？即let不会被提升到外面，let作用域即处于for循环函数里，即每一次循环，liList[i]都有一个新的 i 值。let会在每一次进入循环时，产生一个分身i1-i6. 画一个运行图：【缺】 3、AJAX 中的异步（必须）12345678//同步的Ajaxlet request = $.ajax(&#123; url: &apos;.&apos;, //1、获取当前 url async: false&#125;)//2、此时，该函数会等待请求完成才执行下一步console.log(request.responseText)//打印出这个请求的响应文本，即当前html页面//responseText:响应文本 相当于同步，js在该函数中什么都没做，但就是停了几十ms，如同一个呆滞的人白白浪费了一段空闲时间。 而Ajax的异步如何做？——async:true12345678$.ajax(&#123; url: &apos;.&apos;, async: true, success: function(responseText)&#123; console.log(responseText) &#125;//表示：如果请求返回回来，麻烦调用以下success这个函数，然后把得出的结果打印出来&#125;)console.log(&apos;请求发送完毕&apos;) 在控制台上，模拟一个网速很慢的操作：Network——slow 3G，如图：首先ajax函数会发一个请求，继续执行第二句console.log，这就是ajax中的异步。在这里，先不管ajax里的请求成功或失败，直接执行第二句代码。不等，即为异步；而等则是一定要拿到结果才进行下一步。时间不到，异步绝对拿不到结果。 画一下图：如果我们把它改为同步：async:false，并模拟一个很慢的网速：Network——add，参数设置如下：同步之后，代码运行演示如下： 五、异步的形式从上面的例子中：可以通过绑定onload事件获取宽度大小，或者ajax中的success函数。一般，有两种方式拿到异步结果 1、傻逼方法：轮询2、正规方法：回调回调的形式 Node.js 的 error-first 形式1234567fs.readFile(&apos;./1.txt&apos;, (error, content)=&gt;&#123; if(error)&#123; // 失败 &#125;else&#123; // 成功 &#125; &#125;) -jQuery 的 success / error 形式12345$.ajax(&#123; url:&apos;/xxx&apos;, success:()=&gt;&#123;&#125;, error: ()=&gt;&#123;&#125; &#125;) -jQuery 的 done / fail / always 形式123$.ajax(&#123; url:&apos;/xxx&apos;, &#125;).done( ()=&gt;&#123;&#125; ).fail( ()=&gt;&#123;&#125; ).always( ()=&gt; &#123;&#125;) Prosmise 的 then 形式123$.ajax(&#123; url:&apos;/xxx&apos;, &#125;).then( ()=&gt;&#123;&#125;, ()=&gt;&#123;&#125; ).then( ()=&gt;&#123;&#125;) 六、如何处理异常？ 如何使用多个 success 函数？ 在有多个成功回调的情况下，如何处理异常？ 自己返回 Promise12345678910function ajax()&#123; return new Promise((resolve, reject)=&gt;&#123; 做事 如果成功就调用 resolve 如果失败就调用 reject &#125;)&#125;var promise = ajax()promise.then(successFn, errorFn) Promise 深入阅读： Promise/A+ 规范： async / await12345678function buyFruit()&#123; return new Promise((resolve, reject)=&gt;&#123; 做事 如果成功就调用 resolve 如果失败就调用 reject &#125;)&#125;var promise = await ajax() 123456async functon fn()&#123; var result = await buyFruit() return result&#125;var r = await fn()console.log(r)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步加载</tag>
        <tag>白屏和Fouc</tag>
        <tag>defer和async</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端编码规范]]></title>
    <url>%2F2018%2F08%2F18%2F45-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、命名技巧1、语义化即合适标签+合适命名（1）语义化标签优先（2）基于功能命名、内容命名、表现命名（3）简略、明了、无后患tips：可自己改名字、翻译成英文单词 2、范例（1）12345678910111213&lt;!-- 不好 --&gt;&lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;article_title&quot;&gt;编码规范&lt;/div&gt; &lt;div class=&quot;the_content&quot;&gt;今天讲的内容是编码规范，讲师 &lt;div class=&quot;darkbold&quot;&gt;若愚&lt;/div&gt; @饥人谷&lt;/div&gt;&lt;/div&gt;&lt;!-- 好 --&gt;&lt;article&gt; &lt;h1&gt;编码规范&lt;/h1&gt; &lt;p&gt;今天讲的内容是编码规范，讲师 &lt;b&gt;若愚&lt;/b&gt; @饥人谷&lt;/p&gt;&lt;/article&gt; （2）12345678910&lt;!-- 不好 --&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;&lt;div class=&quot;s&quot;&gt;&lt;/div&gt;&lt;a class=&quot;link&quot; href=&quot;#&quot;&gt;&lt;/a&gt;&lt;!-- 好 --&gt;&lt;div class=&quot;success&quot;&gt;&lt;/div&gt;&lt;div class=&quot;theme-color&quot;&gt;&lt;/div&gt;&lt;a class=&quot;login&quot; href=&quot;#&quot;&gt;&lt;/a&gt; （3）1234567&lt;!-- 好 --&gt;&lt;article class=&quot;movies&quot;&gt;...&lt;/article&gt;&lt;article class=&quot;news&quot;&gt;...&lt;/article&gt;&lt;!-- 不好 --&gt;&lt;article class=&quot;blue&quot;&gt;...&lt;/article&gt;&lt;article class=&quot;redBg mt30 bigText&quot;&gt;...&lt;/article&gt; 3、命名范例123456789101112（1）.所有命名都使用英文小写推荐：`&lt;div class=&quot;main&quot;&gt;&lt;/div&gt; `不推荐： `&lt;div class=&quot;Main&quot;&gt;&lt;/div&gt; `（2）.命名用引号包裹推荐：`&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; `不推荐： `&lt;div id=header&gt;&lt;/div&gt; `（3）.用中横线连接推荐：`&lt;div class=&quot;mod-modal&quot;&gt;&lt;/div&gt; `不推荐： `&lt;div class=&quot;modModal&quot;&gt;&lt;/div&gt; `（4）.命名体现功能，不涉及表现样式(颜色、字体、边框、背景等推荐：`&lt;div class=&quot;text-lesser&quot;&gt;&lt;/div&gt;`不推荐： `&lt;div class=&quot;light-grey&quot;&gt;&lt;/div&gt;` 4、常见命名第一种： .wrap或.wrapper– 用于外侧包裹 .container或 .ct – 包裹容器 .header – 用于头部 .body – 页面 body .footer – 页面尾部 aside、sidebar – 用于侧边栏 .content – 和header footer对应，用于主要内容 .navigation – 导航元素 .pagination – 分页第二种： .tabs &gt;.tab – tab 切换 .breadcrumbs – 导航列表、面包屑 .dropdown – 下拉菜单 .article – 文章 .main – 用于主体 .thumbnail – 头像，小图像 .media – 媒体资源 .panel – 面板 .tooltip – 鼠标放置上去的提示 .popup – 鼠标点击弹出的提示第三种： .button、.btn – 按钮 .ad – 广告 .subnav– 二级导航 .menu – 菜单 .tag – 标签 .message或者.notice – 提示消息 .summary – 摘要 .logo – logo .search – 搜索框 .login – 登录第四种： .register – 注册 .username – 用户名 .password – 密码 .banner – 广告条 `.copyright – 版权 .modal或者.dialog– 弹窗第五种：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var 名字 = &#123; 状态: [ &apos;inverse&apos;, &apos;toggled&apos;, &apos;switched&apos;, &apos;original&apos;, &apos;initial&apos;, &apos;identified&apos;, &apos;disabled&apos;, &apos;loading&apos;, &apos;pending&apos;, &apos;syncing&apos;, &apos;default&apos; ], 修饰: [ &apos;dark&apos;, &apos;light&apos;, &apos;shaded&apos;, &apos;flat&apos;, &apos;ghost&apos;, &apos;maroon&apos;, &apos;pale&apos;, &apos;intense&apos;, &apos;twisted&apos;, &apos;narrow&apos;, &apos;wide&apos;, &apos;smooth&apos;, &apos;separate&apos;, &apos;clean&apos;, &apos;sharp&apos;, &apos;aligned&apos; ], 元素: [ &apos;pagination&apos;, &apos;modal&apos;, &apos;popup&apos;, &apos;article&apos;, &apos;story&apos;, &apos;flash&apos;, &apos;status&apos;, &apos;state&apos;, &apos;media&apos;, &apos;block&apos;, &apos;card&apos;, &apos;teaser&apos;, &apos;badge&apos;, &apos;label&apos;, &apos;sheet&apos;, &apos;poster&apos;, &apos;notice&apos;, &apos;record&apos;, &apos;entry&apos;, &apos;item&apos;, &apos;figure&apos;, &apos;square&apos;, &apos;module&apos;, &apos;bar&apos;, &apos;button&apos;, &apos;action&apos;, &apos;knob&apos; ], 布局: [ &apos;navigation&apos;, &apos;wrapper&apos;, &apos;inner&apos;, &apos;header&apos;, &apos;footer&apos;, &apos;aside&apos;, &apos;section&apos;, &apos;divider&apos;, &apos;content&apos;, &apos;container&apos;, &apos;panel&apos;, &apos;pane&apos;, &apos;construct&apos;, &apos;composition&apos;, &apos;spacing&apos;, &apos;frame&apos; ]&#125; 二、CSS编码规范1、书写规范 tab 用两个空格表示 css的 :后加个空格，{前加个空格 每条声明后都加上分号 换行，而不是放到一行 颜色用小写，用缩写, #fff 小数不用写前缀, 0.5s -&gt; .5s；0不用加单位 尽量缩写，margin: 5px 10px 5px 10px -&gt;margin: 5px 10px ### 2、范例——google编码规范1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Not recommended */.test &#123; display: block; height: 100px&#125;/* Recommended */.test &#123; display: block; height: 100px;&#125;/* Not recommended */h3 &#123; font-weight:bold;&#125;/* Recommended */h3 &#123; font-weight: bold;&#125;/* Not recommended: missing space */#video&#123; margin-top: 1em;&#125;/* Not recommended: unnecessary line break */#video&#123; margin-top: 1em;&#125;/* Recommended */#video &#123; margin-top: 1em;&#125;/* Not recommended */a:focus, a:active &#123; position: relative; top: 1px;&#125;/* Recommended */h1,h2,h3 &#123; font-weight: normal; line-height: 1.2;&#125;/* Always put a blank line (two line breaks) between rules. */html &#123; background: #fff;&#125;body &#123; margin: auto; width: 50%;&#125;/* Not recommended */@import url(&quot;//www.google.com/css/maia.css&quot;);html &#123; font-family: &quot;open sans&quot;, arial, sans-serif;&#125;/* Recommended */@import url(//www.google.com/css/maia.css);html &#123; font-family: &apos;open sans&apos;, arial, sans-serif;&#125; 三、参考 google html css编码规范 google html css编码规范 bootstrap编码规范 bootstrap编码规范 其中，对新手前端写代码较重要的因素：声明顺序。相关的属性声明应当归为一组，并按照下面的顺序排列： Positioning（定位） Box model（盒模型） Typographic（与文字相关，字体大小宽高居中） Visual（颜色相关） 由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。 其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。 命名这货真难 命名这货真难 总结：链接里的文章强烈建议通看一遍]]></content>
      <categories>
        <category>前端</category>
        <category>前端基本认识</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
        <tag>元素命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2018%2F08%2F18%2F44-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[前言关于这一节的内容，看了一些编译原理才能略懂一二，据说还要去看一些C语言。。。所以计算机基础理论知识在往后的日子里还会相应补充。新手们还是多专注于多看书和多实践，很怕误导你们😅。老司机们如果有空闲看到这请轻拍~😂 一、什么是浏览器兼容问题同一份代码在各浏览器上显示效果正常，有些不正常 不正常的原因是什么？(不支持的属性? bug？) 如何让它展示正常?(条件注释？ 单独Hack？) 二、为什么会有浏览器兼容问题 同一产品，版本越老， bug 越多 同一产品，版本越新，功能越多 不同产品，不同标准，不同实现方式 三、处理兼容的时候要考虑 浏览器市场份额 常查CSS属性是否兼容 时常查 Hack 的写法 四、处理兼容问题的思路1、要不要做产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）成本的角度 (有无必要做某件事) 2、做到什么程度让哪些浏览器支持哪些效果 3、如何做(1)根据兼容需求选择技术框架/库(jquery的版本) (2)根据兼容需求选择兼容工具（htmlshiv.js、respond.js、css reset、normalize.css、modernizr） (3)postcss贴一个方方老师对postcss的经典回答：各位前端大神能不能通俗的说一下PostCSS到底能做什么？对于手写css的优势在哪？ (4)条件注释、CSS Hack、js 能力检测做一些修补 4、渐进增强和优雅降级(1)渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 (2)优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 五、处理兼容问题的手段1、合适的框架Bootstrap (&gt;=ie8)；jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9)；Vue (&gt;= ie9)… 2、条件注释即IE条件注释是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。如：12345678910111213 &lt;!--[if IE 6]&gt; &lt;p&gt;You are using Internet Explorer 6.&lt;/p&gt; &lt;![endif]--&gt; &lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt;alert(1);&lt;/script&gt; &lt;!--&lt;![endif]--&gt; /* if（如果是）非IE浏览器，else（那么）我的页面上该 &lt;script&gt;alert(1);&lt;/script&gt;标签会生效，弹出一个1；如果在IE浏览器上，这段本身是有效的，即能控制该效果，所以在其他浏览器这段则会被注释掉。*/ &lt;!--[if IE 8]&gt; &lt;link href=&quot;ie8only.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;![endif]--&gt; 3、CSS hack（1）定义由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能在不同的浏览器中也能得到我们想要的页面效果。 （2）常见hack写法利用该方法去检测浏览器兼容问题1234567891011.box&#123; color: red; _color: blue; /*针对后期检查将ie6和其他浏览器区别开来的标准*/ *color: pink; /*同上，ie6、7*/ color: yellow\9; /*ie/edge 6-8*/&#125;以上属性均是采用样式覆盖形式，去相应地在所在浏览器属性生效&lt;!–-[if IE 7]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;ie7.css&quot; type=&quot;text/css&quot; /&gt;&lt;![endif]–-&gt; （3）常见兼容处理范例例子A：123456.target&#123; display: inline-block; *display: inline;/*在IE6、7中会生效，产生类似bfc的效果，可添加宽高，与其他浏览器所使用的display: inline-block;有相同效果*/ *zoom: 1;&#125; 例子B：12345678.clearfix:after&#123; content: &apos;&apos;; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1; /* 仅对ie67有效 */&#125; 例子C：12345678.clearfix:after&#123; content: &apos;&apos;; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1; /* 仅对ie67有效 */&#125; 例子D：1234&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 例子E：123456&lt;!DOCTYPE html&gt;&lt;!--[if IEMobile 7 ]&gt; &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot;class=&quot;no-js iem7&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt; &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie7 oldie&quot;&gt; &lt;![endif]--&gt;]--&gt;&lt;!--[if IE 7 ]&gt; &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie7 oldie&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt; &lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js ie8 oldie&quot;&gt; &lt;![endif]--&gt;&lt;!--[if (gte IE 9)|(gt IEMobile 7)|!(IEMobile)|!(IE)]&gt;&lt;!--&gt;&lt;html dir=&quot;ltr&quot; lang=&quot;en-US&quot; class=&quot;no-js&quot;&gt;&lt;!--&lt;![endif]--&gt; （4）常见属性的兼容情况：多使用 caniuse.com inline-block: &gt;=ie8 min-width/min-height: &gt;=ie8 :before,:after:&gt;=ie8 div:hover:&gt;=ie7 inline-block: &gt;=ie8 background-size: &gt;=ie9 圆角: &gt;= ie9 阴影: &gt;= ie9 动画/渐变: &gt;= ie10]]></content>
      <categories>
        <category>前端</category>
        <category>计算机基本知识</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
        <tag>渐进增强</tag>
        <tag>优雅降级</tag>
        <tag>CSS hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：14闭包（词法作用域）]]></title>
    <url>%2F2018%2F08%2F17%2F43-14%E9%97%AD%E5%8C%85%EF%BC%88%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：看过一些相关文章，知道想理解闭包，词法作用域和作用域（链）是非常重要的前置知识，结合之前所学，可以继续学习词法作用域和闭包。想告诉一些前端萌新们：记录的知识都是在我理解的基础上记录下来的，也希望大家是理解的情况下去学习哦~（注意看我加粗的语句） 可以回顾一下之前的作用域和作用域链： #hello，JS：04作用域和作用域链 简单说一下作用域（链）的变量（标识符）如何找？ 函数在执行的过程中，先从自己内部找声明过的变量 如果找不到，再从创建当前函数所在的作用域(词法作用域)去找, 以此往上（注：如果找不到则为undefined或报错） 注意找的是变量的当前的状态 参考资料：lce_shou《深入理解闭包之前置知识→作用域与词法作用域》 前置知识：一、了解词法作用域前，补充作用域下标识符的查找规则看完了作用域和作用域链知识，我们有必要了解一下JS编译过程：JavaScript是有编译过程的。先从这段简单的代码开始：var name = &#39;iceman&#39;，它的编译过程其实有两个动作： 编译器在当前作用域中声明一个变量name 运行时引擎在作用域中查找该变量，找到了name变量并为其赋值 证明以上的说法：12console.log(name); // 输出undefinedvar name = &apos;iceman&apos;; 在var name = &#39;iceman&#39;的上一行输出name变量，并没有报错，输出undefined，说明输出的时候该变量已经存在了，只是没有赋值而已。 其实编译器是这样工作的，在代码执行之前从上到下的进行编译，当遇到某个用var声明的变量的时候，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量。 上面的这段简单的代码包含两种查找类型： 输出变量的值时查找类型是：RHS，即变量出现在右侧时进行RHS查询。（作用域中查找变量都是RHS）。RHS就是取到它的源值。 找到变量为其赋值的查找类型是：LHS，即变量出现在赋值操作的左侧时进行`LHS查询。（所有的赋值操作中查找变量都是LHS） 注： “赋值操作的左侧和右侧”，并不意味着只是“=”，实际上赋值操作还有好几种形式。作用域中查找变量都是RHS。查找规则是从当前作用域开始找，如果没找到再到父级作用域中找，一层层往外找，如果在全局作用域如果还没找到的话，就会报错了：ReferenceError: 某变量 is not defined 所有的赋值操作中查找变量都是LHS。其中a=4这类赋值操作，也是会从当前作用域中查找，如果没有找到再到外层作用域中找，如果到全局变量啊这个变量，在非严格模式下会创建一个全局变量a。 注：非常不建议这么做，因为轻则污染全局变量，重则造成内存泄漏（比如：a = 一个非常大的数组，a在全局变量中，一直用有引用，程序不会自动将其销毁）。 二、词法作用域是什么？熟悉作用域后，通常我们将其定义为一套规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。 我们在前面有抛出一个概念：“词法作用域是作用域的一种工作模型”，作用域有两种工作模型：一种主流的是，JavaScript的静态作用域——词法作用域，另一种则是动态作用域（比较少的语言在用）。先看一下这个代码：12345678function fn1(x) &#123; var y = x + 4; function fn2(z) &#123; console.log(x, y, z); &#125; fn2(y * 5);&#125;fn1(6); // 6 10 50 例子中有三个嵌套的作用域：A、B、C， A 为全局作用域，有一个标识符：fn1 B 为fn1所创建的作用域，有三个标识符：x、y、fn2 C为fn2所创建的作用域，有一个标识符：z 如图：作用域， 是由其代码写在哪里决定的，并且是从外向内逐级包含的。词法作用域， 即在你写代码时将变量和块作用域写在哪里来决定，编译阶段就能够知道全部标识符在哪里以及是如何声明的，词法作用域就是静态的作用域，能够预测在执行代码的过程中如何查找变量（标识符），它在你书写代码时就确定。 一些疑问：根据相关资料了解，这里面还会涉及：关于eval()和with的对其词法作用域有其特殊“欺骗”性，以此产生的性能问题，以及ES6中有了let、const所出现的块级作用域。我还没接触到很全面，所以我暂时不会记录这一方面的知识😂~ 进入正题：三、闭包是什么？1、对闭包的各种解释 MDN的解释：A closure is the combination of a function and the lexical environment within which that function was declared.闭包，是一个变量所声明的函数+它的词法作用域的结合。 JavaScriptKit的解释A closure is the local variables for a function - kept alive after the function has returned闭包对于函数来说是个本地变量，这个变量是当这个函数返回的时候，变量还存在。闭包，能访问当前函数外的变量。 还有《JavaScript高级程序设计》的解释：闭包是一个函数，指有权访问另一个函数作用域中的变量的函数。 《JavaScript权威指南》的解释：从技术的角度讲，所有的JavaScript函数都是闭包。它们都是对象，它们都关联到作用域链。 【较认可】《你不知道的JavaScript》的解释：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 闭包，是基于词法作用域书写代码时产生的一种现象。通过下面的实践你会知道，闭包在代码中随处可见，不用特意为其创建而创建，前端萌新们，我们可能不知道我们写代码的过程中其实已经产生了闭包。 2、闭包的作用 封装数据 暂存数据 3、从实例浅析闭包实例1： 先看看下面这个代码：12345678function fn1() &#123; var name = &apos;iceman&apos;; function fn2() &#123; console.log(name); &#125; fn2();&#125;fn1(); 根据《JavaScript高级程序设计》中可知，这个函数出现了闭包。fn2访问到了fn1的变量，满足了书中对闭包的定义“有权访问另一个函数作用域中的变量的函数”，fn2本身是个函数，所以满足《JavaScript权威指南》所说的“所有的JavaScript函数都是闭包”不过，看得出这是多个函数嵌套，特别是fn2本身是函数，也是一个返回值，也是fn1的赋值变量，对于基础不牢的小白来说还是很容易混淆的。 实例2： 让我们看看下面这个代码：123456789101112function car()&#123; var speed = 0 function fn()&#123; speed++ console.log(speed) &#125; return fn&#125;var speedUp = car()speedUp() //1speedUp() //2 分析如下： fn的词法作用域能访问car的作用域 根据条件执行fn函数内的代码，fn当做值返回 car执行后，将fn的引用赋值给speedUp，赋值过程即speedUp=car=fn 执行speedUp，分别输出1，2 通过引用的关系，speedUp就是fn函数本身（speedUp=fn）。执行speedUp能正常输出变量speed的值，这不就是“fn能记住并访问它所在的词法作用域”，而fn函数（被speedUp调用）的运行是在当前词法作用域之外。 通常，当car函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放闭包那段内存空间，但是闭包就这样神奇地将car的作用域存活了下来，fn依然持有该作用域的引用，这块引用即：12345var speed = 0 function fn()&#123; speed++ console.log(speed) &#125; 以上引用就是闭包 总结： 某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。 4、从经典实例深入学习闭包实例3： 用for循环输出函数值的问题，先看下面代码：1234567var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = function()&#123; return i &#125;;&#125;console.log( fnArr[3]() ) // 10 通过for循环，预期的结果我们是会输出0-9，但最后执行的结果，在控制台上显示则是全局作用域下的10个10。 这是因为当我们执行fnArr[3]时，先从它当前作用域中找i的变量，没找到i变量，从全局作用域下找。开始了从上到下的代码执行，要执行匿名函数function时，for循环已经结束（for循环结束的条件是当i大于或等于10时，就结束循环），然后执行函数function，此时当i等于[0,1,2,3,4,5,6,7,8,9]时，此时i再执行函数代码，输出值都是i循环结束时的最终值为：10，所以是输出10次10。 由此可知：i 是声明在全局作用域中，function匿名函数也是执行在全局作用域中，那当然是每次都输出10了。 延伸： 那么，让 i 在每次迭代的时候都产生一个私有作用域，在这个私有的作用域中保存当前 i的值12345678910var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = (function()&#123; var j = i return function()&#123; return j &#125; &#125;)()&#125;console.log(fnArr[3]()) //3 用一种更简洁、优雅的方式改造：将每次迭代的 i 作为实参传递给自执行函数，自执行函数用变量去接收输出值123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = (function(j)&#123; return function()&#123; return j &#125; &#125;)(i)&#125;console.log( fnArr[3]() ) // 3 待续…]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
        <tag>词法作用域</tag>
        <tag>作用域和作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,JS:12-03搭建服务器（下）]]></title>
    <url>%2F2018%2F08%2F17%2F42-12.03%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[（一）实例一：写一个简单的服务器一、nodejs写服务器1、下载github代码 2、开始操作：（1）分析项目文件step0中的文件index.js，代码如下：1var http = require(&apos;http&apos;)//是nodejs的内置模块——http(服务器） 即nodejs通过require加载一个模块（一个对象，提供了一些方法能够实现所需要的功能），服务器的底层是由这个nodejs的http模块实现 （2）回到项目文件，用nodejs的内置模块创建一个server：123http.createServer(function(req , res)&#123;&#125;)//内含一个回调函数 以上函数实质上内部是一个异步过程，内部可以创建一个服务器，以这个函数作为对应的参数去处理请求。 当浏览器去访问这个服务器的时候，该请求底层会被封装成一个对象。 一个对象：参数req（随意取名），即用户请求的信息都存在这个req对象中，通过获取req得到相关的信息数据（如用户IP、域名，以及一些浏览器的域名等等） 另一个对象：参数res，即需要返回给用户哪些东西 （3）最终在项目文件中创建一个有着基本设置的服务器。代码如下：123456789//index.jsvar http = require(&apos;http&apos;)var server = http.createServer(function(req, res)&#123; console.log(req) //用户请求所附带的信息 res.write(&apos;hello world&apos;) //返回浏览器自带的一些信息 res.end()&#125;)server.listen(9000) //用listen启动这个静态服务器 （4）终端启动：1$ node index.js 此时终端进入一个空白状态（输入无用），即服务器处于一个启动状态，等待用户输入 （5）浏览器输入服务器地址：localhost:9000 （地址不一定一样，端口号自己弄）。出现如图： 同时，终端相应出现req这个对象所附带的用户请求的信息（随意截图）注： 事实上，console.log所执行的请求数据，除了可以是设定好的参数req，也可以是任意字符串，或者包含数据的json数据等等（不演示了） 至此，写了一个简单的服务器延伸：解析一下响应体如何进入服务器——服务器处理请求——返回数据：拿 res.write(&#39;hello world&#39;)举例：res.write（即一个响应体）是把数据（即&#39;helloworld&#39;）放到http的response响应体里（即响应内容里）当我们代码请求后输入url发出网络请求，请求时浏览器自动添加响应头相关信息，请求发至服务器之后，则会开始执行以下代码：【这里就是开发者开发不同页面的个性创造所在】12345var server = http.createServer(function(req, res)&#123; console.log(req) //用户请求所附带的信息 res.write(&apos;hello world&apos;) //返回浏览器带的信息（即响应体，页面展现的内容） res.end()&#125;) 该服务器发了一个响应res（response），此时服务器后台出现响应头（一些浏览器默认参数），如图： 响应体对应代码中，则res所请求的内容，这里是&#39;hello world&#39;： 总结，这是网站后台的一个基本逻辑3、扩展：设置响应头通过res.setHeader()设置响应头，如可添加：1234res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)//text/plain 表示返回内容用字符串（明文）去呈现或者当成html渲染，如text/html//charset=gbk 表示返回的内容用gbk解码，也可设置为charset=utf-8解码 即项目文件代码为：12345678910//index.jsvar http = require(&apos;http&apos;)var server = http.createServer(function(req, res)&#123; console.log(&apos;jiengu&apos;)//服务器响应的内容 res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;) res.write(&apos;你好世界&apos;)//响应体：页面展现的内容 res.end()&#125;)server.listen(9000) 重启终端：1$ node index.js 服务器后台响应头设置相应参数后，出现如图：注意： 如出现乱码文件，实质可以在服务器的响应头层面去设置编码方式。如果返回的是一个html则可以从meta里去设置 延伸：ajax的请求头 VS nodejs的响应头miya Wang：#hello，JS：12-01技术方案：Ajax 使用和原理 ajax请求头：即服务器发送、返回时带的一些资源数据，如将url包含的一些各类数据作为请求资源，做一些加载、拼接等，然后返回结果数据。 nodejs的响应头：服务器对所请求的东西后台参数的一些响应，如设置页面展示效果的展示 4、加一个定时器观察服务器的响应项目文件代码如下：123456789101112131415161718192021222324//项目文件：(新）index.jsvar http = require(&apos;http&apos;)var server = http.createServer(function(request, response)&#123; setTimeout(function()&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/html; charset=utf-8&apos;)//响应头：论及权限高，charset=utf-8作为请求http(浏览器)级别的请求,去解码//发一个请求去响应：头、身体内容，根据头解释身体内容（一堆字符串） response.writeHead(404, &apos;Not Found&apos;) response.write(&apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;gbk&quot; /&gt;&lt;/head&gt;&apos;) response.write(&apos;&lt;body&gt;&apos;) response.write(&apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;) response.write(&apos;&lt;/body&gt;&apos;) response.write(&apos;&lt;/html&gt;&apos;) response.end() &#125;,2000);&#125;)console.log(&apos;open http://localhost:8080&apos;)server.listen(8080) 重新启动终端：1$ node index.js 检查——控制台 ,延伸：针对http对应的状态码作用。先看到几个效果： 当Status Code:200时，如图： 当Status Code:400时，如图：页面打开了（页面出现：你好）请求是成功的,但是打开控制台显示请求为红色，且console出现报错：404(Notfound)。一旦浏览器收到状态码为404，它则认为文件请求失败，但实际上它也是收到请求并返回数据的。 总结： 所请求的状态码通过response.writeHead()写出，完全由你来决定其页面呈现的状态 （二）实例二：实现一个静态服务器准备好打包好的项目文件夹（包含html(css样式/js交互/图片））——网站放置在远程服务器上——通过执行服务器的相关js文件（执行node server.js）——运行服务器 那么，这个运行服务器的js文件到底是怎么实现访问页面？分析项目文件step1中的文件关键js文件：server.js，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//server.jsvar http = require(&apos;http&apos;) //前面说了，创建http服务器的底层内置模块var path = require(&apos;path&apos;) //该模块可以处理不同系统下的url（不同系统路径写法不一）var fs = require(&apos;fs&apos;) //该模块读、写文件var url = require(&apos;url&apos;) //该模块自动解析url，读取信息，如控制台求locationfunction staticRoot(staticPath, req, res)&#123; console.log(staticPath) var pathObj = url.parse(req.url, true) console.log(pathObj) if(pathObj.pathname === &apos;/&apos;)&#123; pathObj.pathname += &apos;index.html&apos; &#125; var filePath = path.join(staticPath, pathObj.pathname) // var fileContent = fs.readFileSync(filePath,&apos;binary&apos;) // res.write(fileContent, &apos;binary&apos;) // res.end() fs.readFile(filePath, &apos;binary&apos;, function(err, fileContent)&#123; if(err)&#123; console.log(&apos;404&apos;) res.writeHead(404, &apos;not found&apos;) res.end(&apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;) &#125;else&#123; console.log(&apos;ok&apos;) res.writeHead(200, &apos;OK&apos;) res.write(fileContent, &apos;binary&apos;) res.end() &#125; &#125;) &#125;console.log(path.join(__dirname, &apos;static&apos;))var server = http.createServer(function(req, res)&#123; staticRoot(path.join(__dirname, &apos;static&apos;), req, res)&#125;)server.listen(8080)console.log(&apos;visit http://localhost:8080&apos; ) 当用户访问localhost:8080/index.html，如何让用户看到项目文件的内容呢？实现的关键，分解来看：1234567891011var http = require(&apos;http&apos;) var path = require(&apos;path&apos;) var fs = require(&apos;fs&apos;) var url = require(&apos;url&apos;) var server = http.createServer(function(req, res)&#123; staticRoot(path.join(__dirname, &apos;static&apos;), req, res)&#125;)server.listen(8080)console.log(&apos;visit http://localhost:8080&apos; ) 通过http.creatServer创建一个server，listen去启动一个服务器，监听8080端口，请求到来之后，进入server这个函数里，处理这个请求。写一个函数staticRoot()作为静态文件路径，将路径名、req、res都传递进去，如：1staticRoot(path.join(__dirname, &apos;static&apos;), req, res) __dirname 为nodejs的内置变量，代表当前的文件server.js 再加上【static】，那么，path.join(__dirname, &#39;static&#39;) 则会生成一个 绝对路径,然后通过下面代码运行测试：123function staticRoot(staticPath, req, res)&#123; console.log(staticPath)&#125; 控制台随即得到项目文件的相关文件信息，通过绝对路径能读取文件。获取路径之后进行操作，需要通过用户的url，给用户返回一些特定内容，发出请求得到返回的是console.log(req.url)，req.url所返回的均是项目文件中的相关文件，即请求的均是这些文件index.html、a.css、logo.png，并得到，得到之后进行解析，如何解析？代码如下：12var pathObj = url.parse(req.url, true)console.log(pathObj) 实现一个默认页面：设置一个默认路径：localhost:8080/index.html ，如何实现？代码如下：123if(pathObj.pathname === &apos;/&apos;)&#123; pathObj.pathname += &apos;index.html&apos;&#125; 发现原来可以这样设置一个默认路径的页面，也是很兴奋哦~：通过一个parseName去得到一个完整路径，即静态目录路径则进入打包项目文件夹里，那么加上pathObj.pathname就得到该项目文件所请求的绝对路径地址filePath，代码如下：1var filePath = path.join(staticPath, pathObj.pathname) 如何读取文件？代码如下第1种：直接法123var fileContent = fs.readFileSync(filePath,&apos;binary&apos;)res.write(fileContent, &apos;binary&apos;)res.end() 第2种：异步（也可作为当做制作404的页面状态）123456789101112fs.readFile(filePath, &apos;binary&apos;, function(err, fileContent)&#123; if(err)&#123; console.log(&apos;404&apos;) res.writeHead(404, &apos;not found&apos;) res.end(&apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;) &#125;else&#123; console.log(&apos;ok&apos;) res.writeHead(200, &apos;OK&apos;) res.write(fileContent, &apos;binary&apos;) res.end() &#125; &#125;) ？处理关于乱码的事情 （三）实例三：实现功能更复杂的静态服务器（使用nodejs服务器理由解析）如url可获取任何数据，mock数据与前端交互。分析项目文件step2中的文件server-simple.js，代码如下:1234567891011121314151617181920212223242526272829303132var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)http.createServer(function(req, res)&#123; var pathObj = url.parse(req.url, true) console.log(pathObj) switch (pathObj.pathname) &#123; case &apos;/getWeather&apos;: //请求对应天气 var ret if(pathObj.query.city == &apos;beijing&apos;)&#123; ret = &#123; city: &apos;beijing&apos;, weather: &apos;晴天&apos; &#125; &#125;else&#123; ret = &#123; city: pathObj.query.city, weather: &apos;不知道&apos; &#125; &#125; res.end(JSON.stringify(ret)) break; case &apos;/user/123&apos;: //对应的路由 res.end( fs.readFileSync(__dirname + &apos;/static/user.tpl&apos; )) break; default: res.end( fs.readFileSync(__dirname + &apos;/static&apos; + pathObj.pathname) ) &#125;&#125;).listen(8080) 先分解简单代码：1234567891011121314151617var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)//根据函数req.url进行语句操作，假设req.url是请求getWeather，//res.end()括号内则是请求后所要获取的结果。http.createServer(function(req, res)&#123; switch (req.url)&#123; case &apos;/getWeather&apos;: res.end(JSON.stringify(&#123;a:1,b:2&#125;)) break; case &apos;/user/123&apos;: res.end( fs.readFileSync(__dirname + &apos;/static/user&apos;)) break; default: res.end( fs.readFileSync(__dirname + &apos;/static&apos;+req.url)) &#125;&#125;).listen(8080) 总结： 创建模块：http+fs模块——创建一个server——该server函数返回一个操作对象——该操作对象调用并启动端口为8080的服务器。当任何请求到来，只要以localhost:8080为前缀的url就会到达该服务器 终端启动：1$ node server-simple.js 刷新页面处理js文件中函数对象的请求，即123456789101112http.createServer(function(req, res)&#123; switch (req.url)&#123; case &apos;/getWeather&apos;: res.end(JSON.stringify(&#123;a:1,b:2&#125;)) break; case &apos;/user/123&apos;: res.end( fs.readFileSync(__dirname + &apos;/static/user&apos;)) break; default: //表示用户希望请求的是一个静态文件，直接从static文件夹中读取文件req.url res.end( fs.readFileSync(__dirname + &apos;/static&apos;+req.url)) &#125;&#125;).listen(8080) 当我们访问static下的html、css、图片或者直接调取请求模块，都能获取相应的内容 一个复杂网站，具有静态功能，提供静态文件；可以处理动态路由；可以mock数据，通过以下代码启示：12345678var http = require(&apos;http&apos;)http.createServer(function(req, res)&#123; switch (req.url)&#123; case &apos;/getWeather&apos;: res.end(JSON.stringify(&#123;a:1,b:2&#125;)) break; &#125;&#125;).listen(8080) 可以写一个ajax：12345678//b.jsvar xhr = new XMLHttpRequest()xhr.open(&apos;GET&apos;, &apos;/getWeather?city=hangzhou&apos;, true)xhr.send()xhr.onload = function()&#123; console.log(JSON.parse(xhr.responseText))&#125; 待续…看nodejs这一节最后的时候，不知道是有点困逻辑无法梳理，还有一点复杂服务器的实现暂时看得不是很懂😂。并且对于nodejs的一些理论基础知识也是相对空白，看了阿里出品的《七天学会NodeJS》才发现原来老师是将理论融进这短短的几节课，然后就理解了很多理论的知识。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>nodejs</tag>
        <tag>后台服务器</tag>
        <tag>静态服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：12-02搭建服务器(上)]]></title>
    <url>%2F2018%2F08%2F17%2F41-12.02%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[一、如何获取数据（涉及开发流程）1、获取数据前端部分写了一个ajax，请求需要发送到服务器的接口上，服务器如果是不存在，直接报错，且无法后续测试，对于数据的处理、渲染无从谈起。接口如何运作起来，有数据返回，接口：后端开发 2、网站的开发流程（1）需求（前端、后端）（2）前后端工作 前端：写页面（html、css样式，js交互） 后端：提供数据 （3）如做一个天气预报的页面网站：对前端页面功能的分解，数据需要什么？（前端主导？两者主导？） 与后端协商：天气预报的数据接口：根据城市获取当天的天气；根据城市、日期获取某天的天气（接口url、传递的参数（城市？经纬度、ip、中英文）、返回数据格式（结构？字段？）） 前端：模拟假数据（与后端协商后） （4）前后端开发完成，进行真实数据的测试、优化 3、搭建服务器终端，启用静态服务器：1$ http-server 打开相应地址：我的是，http://127.0.0.1:8080 （你的端口号不一定和我一样，不要纠结） 点开文件，简单功能开发时，把对应功能的接口放在html对应目录下，新建一个文件（json数据文件，即对应功能的数据），上传至githubpages或其他静态页面服务器上，其功能存在，继续进行功能的交互，就能获取相应功能数据。 二、mock数据方法1、方法1、线上githubpagesmock数据（1）github创建一个项目：wxq393/wangyiyunmusic（2）分别创建文件A、html文件——home.html123456789101112131415161718192021222324252627282930313233343536//home.html&lt;!doctype html&gt;&lt;head&gt; &lt;style&gt; .cate .item &#123; border: 1px solid #ccc; line-height: 20px; padding: 0 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;div class=&quot;cate&quot;&gt;&lt;/div&gt; &lt;/main&gt;&lt;script&gt;var xhr = new XMLHttpRequest()xhr.open(&apos;GET&apos;, &apos;/wangyiyunmusic/cate.json&apos;, true)xhr.send()xhr.onload = function()&#123; render(JSON.parse(xhr.responseText)) console.log(JSON.parse(xhr.responseText))&#125;function render(cateData)&#123; for(var i = 0; i &lt; cateData.length; i++)&#123; var node = document.createElement(&apos;div&apos;) node.classList.add(&apos;item&apos;) node.innerText = cateData[i] document.querySelector(&apos;.cate&apos;).appendChild(node) &#125;&#125;&lt;/script&gt;&lt;/body&gt; 如图：熟悉一下dom的语法 B、json文件——cate.json（注意路径）12//cate.json[&quot;90后&quot;, &quot;80后&quot;, &quot;清晨&quot;, &quot;工作&quot;] C、直接githubpage去mock数据，如图： 2、方法2 使用 easymock mock数据A、进入http://easy-mock.com/创建url域名——创建接口——编辑json数据——更新、预览：即能看到返回的数据12345678910/*json数据编写：*/&#123; &quot;success&quot;: true, &quot;data&quot;: [ &quot;80后&quot;, &quot;90后&quot;, &quot;00后&quot;, &quot;清晨喝咖啡&quot; ]&#125; 返回数据另一种方法：点击主页面生成的url，使用终端测试，也能返回相应数据 1$ curl url地址 如图： B、（继续）尝试在本地测试使用项目文件，添加请求数据的文件（文件名：1.html），代码如下：123456789101112131415161718192021222324252627282930313233//1.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() //所请求的数据url地址 xhr.open(&apos;GET&apos;,&apos;https://easy-mock.com/mock/5b51c4919ce5fe26a0a3043d/getType&apos;,true) xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;) xhr.onerror = function()&#123; console.log(&apos;error&apos;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 右键启动该项目的终端服务器：1$ http-server 相应打开对应项目文件的url地址——检查——显示数据格式文件（定义好数据），说明所请求的数据已返回： 3、方法3 使用 http://rapapi.org/org/index.do4、方法4 使用 server-mock]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>获取数据</tag>
        <tag>mock数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：12-01技术方案：Ajax使用和原理]]></title>
    <url>%2F2018%2F08%2F17%2F40-12.01%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%EF%BC%9AAjax%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前端和后端如何交互，从网站的层面上，如何去呈现？如何和后端去交互？如何向后端获取数据和请求？需要一种方法。一、页面如何和后端交互几种方法： 1、form表单提交：form表单提交实例如我们把method改为get，用get方法拼装成一个带有用户名和密码的新的url地址，向服务器去发送请求，相应关键信息（用户名和密码）都会传递给服务器，进行处理；post则是直接将这些关键信息直接发给服务器（而不是通过url传递），后台监听到数据直接处理。这里涉及了get和post的处理。请回看：miya Wang：浅谈HTML表单（一）：表单提交原理（涉及post和get） 这种表单提交的交互方式，提交时页面发生跳转即出现新的页面，体验感不好；再者，页面提交为单向提交，后台给什么反馈？反应？均不知道什么结果。 2、websocket3、ajax二、Ajax1、定义：Ajax，即AsynchronousJavaScript+XML，是一种依赖前端元素获取数据的方法，它是一种技术方案（不是一种新技术），Ajax主要通过XMLHttpRequest这个浏览器的内置对象向服务器发出HTTP请求，并接收HTTP响应，实现在页面不刷新情况下和服务端进行数据交互。 2、交互形式Ajax一般用xml格式数据进行数据交互，现今ajax与服务器交互则是倾向于JSON格式规范数据格式，后端可以发任何格式的数据格式。 伴随着浏览器（chrome）升级（IE6-10），从原本依赖现有的CSS/HTML/Javascript去向服务器发送请求到现在最核心依赖浏览器提供的XMLHttpRequest对象（使用JS操作这个对象获取相应的响应，得到数据），即 控制台操作XMLHttpRequest、fetch，可显示它们均是浏览器的内置对象 三、如何实现Ajax XMLHttpRequest fetch（注意兼容性使用can i use） 实现基本方式：12345678&lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true) xhr.send() var data = xhr.responseText console.log(data)&lt;/script&gt; 1、通过get方式去请求（1）通过js去写XMLHttpRequest来设置ajax123456789101112131415//1.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest()// XMLHttpRequest()是一个函数，通过new的方式去生成一个对象 xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)// 做一些设置：发请求，发给谁？/有post或者get方式/同步异步；设置ajax：请求的方法，请求的服务器（或资源），异步方式（true) xhr.send() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台显示一个报错： 报错显示无法与当前服务器交互，只能通过跨域请求。请求必须以http或者https开头的json格式文件，即所请求的服务器为1&apos;https//1.json&apos; 解决方法：通过http-server服务器去发请求，获取数据 打开该文件的终端，通过终端打开http-server 然后输入带有刚才文件名的服务器地址：http://127.0.0.1:8081/1.html 随即出现以下报错， 由于还没设置后端数据文件，点开链接出现找不到该网页（404）： 接下来如何解决：通过模拟数据，创建一个1.json的文件1234&#123; &quot;name&quot;:&quot;wangxiaoqin&quot; &quot;age&quot; : 1&#125; 然后网页打开服务器的json格式地址：http://127.0.0.1:8081/1.json即出现 打开html的服务器网页控制台，看到json数据通过ajax获取到 此时，我们拿到数据，并没有在js中操作如何拿到数据，是同步？异步？ 第1种：同步的时候，如何拿到数据？注：此方法为同步，造成网页一直在计算中，不能前进 ，可能造成页面卡死状态代码如下：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,false) //设置同步 xhr.send() var data = xhr.responseText console.log(data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时控制台console响应，数据到来，并通知到如图： 总结： 如果是同步的方式执行代码，代码一行行执行，到xhr.send()的时候，代码执行就暂停，漫长地等待着数据的到来，数据到来之后通过xhr.responseText拿到数据。 设置一个ajax：创建对象——参数设置——发送——数据到来——拿到数据 第2种：异步的方式获取数据代码如下：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)//异步方式 xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; var data = xhr.responseText console.log(data) &#125;) // 或者 // xhr.onload = function()&#123; // var data = xhr.responseText // console.log(data) // &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时控制台console响应，数据到来，并通知到，如图： （2）通过状态码/状态值获取数据A、添加status（状态码）方式获取【与onload事件相对应】 当我修改代码中json数据文件名： js中添加一个console.log(xhr.status) (状态码)范例代码如下：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true)//修改json文件名 xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; //添加状态码： console.log(xhr.status) var data = xhr.responseText console.log(data) &#125;) // 或者 // xhr.onload = function()&#123; // var data = xhr.responseText // console.log(data) // &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行结果如下：将json文件名修改，造成了控制台报错。即明知道出错，但却一无所知 不修改json文件名 代码如下：1234567891011//1.json&lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true)//不修改json文件名 xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) var data = xhr.responseText console.log(data) &#125;)&lt;/script&gt; 如图： 总结：控制台出现状态码的响应，返回后端设置的相应数据 状态码200，表示这个文件存在； 状态码404，表示这个文件不存在； 状态码503，服务器表示收到请求，但内部自己报错了，未返回合理的数据; 状态码304，表示服务器是进行了缓存状态 当1.json时，12345678910111213141516//1.json&lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true) xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) //当状态码为200时，获取这个数据 if(xhr.status ===200)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;)&lt;/script&gt; 结果如图： 当1a.json时，12345678910111213141516//1a.json&lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true) xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) //当状态码为200时，获取这个数据 if(xhr.status ===200)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;)&lt;/script&gt; 如图：比较完整地在设置多个状态码条件下，ajax该如何向后台要取数据，完整代码如下12345678910111213141516171819202122232425262728293031//1.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1a.json&apos;,true) xhr.send() xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;//数据文件：1.json&#123; &quot;name&quot;:&quot;wangxiaoqin&quot; &quot;age&quot; : 1&#125; B、使用readyState（状态值）方式获取数据【与onreadystatechange事件相对应】js中添加另一种状态：readyState 绑定事件获取方法：（1）on+一个事件（2）addEventListener绑定一个函数事件 范例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//1.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;,&apos;/1.json&apos;,true) xhr.send() // 使用readyStatechange方法 console.log(&apos;readyState:&apos;,xhr.readyState) xhr.addEventListener(&apos;readystatechange&apos;,function()&#123; console.log(&apos;readyState:&apos;,xhr.readyState) &#125;) // 或者xhr.onreadystatechange = function()&#123; // console.log(&apos;readyState:&apos;,xhr.readyState) // &#125; xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;) // // 或者 // xhr.onload = function()&#123; // var data = xhr.responseText // console.log(data) // &#125; xhr.onerror = function()&#123; console.log(&apos;error&apos;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台如图： 对象中有一个状态值：readyState，这个状态与后端交互时，该状态会发生几次改变，每次改变都会触发该状态的change事件，每次监听这个事件，则输出readyState。即第一次请求状态改变为1，当触发change事件的时候，则开始变化：readyState2，3，4 总结：AJAX实际运行中的几种状态值：AJAX实际运行当中，对于访问XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是：0 - (未初始化)还没有调用send()方法1 - (载入)已调用send()方法，正在发送请求2 - (载入完成)send()方法执行完成，3 - (交互)正在解析响应内容4 - (完成)响应内容解析完成，可以在客户端调用了对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。 2、readyState VS status 区别通过对readyState 和 status的一系列操作，可以知道： readyState：表明客户端与客户的交互状态过程 status：体现的是服务器对请求的反馈，数据是否正常 load: 当状态为4（等同于readyState===4），4为一种完成状态（响应内容解析完成状态），触发调用load事件 为此，我专门查了关于eadyState和status两种ajax状态，找到这么一篇资料较为好理解，可以看看,原文戳：AJAX 状态值(readyState)与状态码(status)详解 （1）AJAX状态值(readyState)与状态码(status)区别A、AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成）B、AJAX状态码是指， 无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。123if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; putData(ajax.responseText);&#125; （2） AJAX运行步骤与状态值说明在AJAX实际运行当中，对于访问XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是：0 - (未初始化)还没有调用send()方法1 - (载入)已调用send()方法，正在发送请求2 - (载入完成)send()方法执行完成，3 - (交互)正在解析响应内容4 - (完成)响应内容解析完成，可以在客户端调用了对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。 （3）AJAX状态码说明1：请求收到，继续处理2：操作成功收到，分析、接受3：完成此请求必须进一步处理4：请求包含一个错误语法或不能完成5**：服务器执行一个完全有效请求失败100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本200——交易成功201——提示知道新文件的URL202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求300——请求的资源可在多处得到301——删除请求数据302——在其他地址发现了请求数据303——建议客户访问其他URL或访问方式304——客户端已经执行了GET，但文件未变化305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除400——错误请求，如语法错误401——请求授权失败402——保留有效ChargeTo头响应403——请求不允许404——没有发现文件、查询或URl405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求500——服务器产生内部错误501——服务器不支持请求的函数502——服务器暂时不可用，有时是为了防止发生系统过载503——服务器过载或暂停维修504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长505——服务器不支持或拒绝支请求头中指定的HTTP版本 （4） AJAX运行步骤示义图 3、继续探究一下所请求的后端数据文件在xhr.open()中要求请求服务器，即请求一个资源，而url则是定位一个资源,将所请求的服务器定位成请求一些资源，如&#39;/hello.json&#39;。假如模拟后端的数据，比如请求一个登陆数据：&#39;/login&#39;，请求时带有一些参数，如将用户所输入的数据拼装成类似url形式：&#39;/login?username=wangxiaoqin&amp;password=12345&#39;作为资源请求 4、通过post形式去请求数据123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;POST&apos;,&apos;/1.json&apos;,true) xhr.send(&apos;username=wangxiaoqin&amp;password=12345&apos;)//直接发送数据 xhr.addEventListener(&apos;load&apos;,function()&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) ||xhr.status ===304)&#123; var data = xhr.responseText console.log(data) &#125;else&#123; console.log(&apos;error&apos;) &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &#39;username=wangxiaoqin&amp;password=12345&#39; 这段拼接的过程可以通过写一个函数展现：12345678910111213//传递一个参数：makeUrl(&#123; username:&apos;wangxiaoqin&apos;, password:12345&#125;)//拼接一个url,通过遍历这个对象，进行拼接function makeUrl(obj)&#123; var arr = [] for(var key in obj)&#123; arr.push(key + &apos;=&apos; + obj[key]) &#125; return arr.join(&apos;&amp;&apos;) &#125; 那么，xhr.send()便直接可以发送这个对象1234xhr.send(makeUrl(&#123; username:&apos;wangxiaoqin&apos;, password:12345&#125;)) 四、ajax几种写法1、第1种： 关键词： readyState === 4onreadystatechange 12345678910111213141516var xhr = new XMLHttpRequest()xhr.open(&apos;GET&apos;, &apos;http://api.jirengu.com/weather.php&apos;, true)xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4) &#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; //成功了 console.log(xhr.responseText) &#125; else &#123; console.log(&apos;服务器异常&apos;) &#125; &#125;&#125;xhr.onerror = function()&#123; console.log(&apos;服务器异常&apos;)&#125;xhr.send() 2、第2种： 关键词：onload1234567891011121314var xhr = new XMLHttpRequest()xhr.open(&apos;GET&apos;, &apos;http://api.jirengu.com/weather.php&apos;, true)xhr.onload = function()&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; //成功了 console.log(xhr.responseText) &#125; else &#123; console.log(&apos;服务器异常&apos;) &#125;&#125;xhr.onerror = function()&#123; console.log(&apos;服务器异常&apos;)&#125;xhr.send() 3、第3种：封装1个ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//封装，调用ajax对象，传递一些固定参数function ajax(opts)&#123; var url = opts.url var type = opts.type || &apos;GET&apos;// ||或：前者undefined，默认后者 var dataType = opts.dataType || &apos;json&apos; var onsuccess = opts.onsuccess || function()&#123;&#125; var onerror = opts.onerror || function()&#123;&#125; var data = opts.data || &#123;&#125; //将上面用户请求的数据对象进行处理，拼接一个url var dataStr = [] for(var key in data)&#123; dataStr.push(key + &apos;=&apos; + data[key]) &#125; dataStr = dataStr.join(&apos;&amp;&apos;) if(type === &apos;GET&apos;)&#123; url += &apos;?&apos; + dataStr &#125; //做一个ajax var xhr = new XMLHttpRequest() xhr.open(type, url, true) xhr.onload = function()&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; //成功了 if(dataType === &apos;json&apos;)&#123; onsuccess( JSON.parse(xhr.responseText))//返回的数据 &#125;else&#123; onsuccess( xhr.responseText) &#125; &#125; else &#123; onerror() &#125; &#125; xhr.onerror = onerror if(type === &apos;POST&apos;)&#123; xhr.send(dataStr) &#125;else&#123; xhr.send() &#125;&#125;//ajax设置一些参数对象ajax(&#123; url: &apos;http://api.jirengu.com/weather.php&apos;, data: &#123; city: &apos;北京&apos; &#125;, onsuccess: function(ret)&#123; console.log(ret) &#125;, onerror: function()&#123; console.log(&apos;服务器异常&apos;) &#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>前后端交互</tag>
        <tag>状态码status</tag>
        <tag>封装Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：11浏览器基础：BOM对象和浏览器储存]]></title>
    <url>%2F2018%2F08%2F17%2F39-11%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%EF%BC%9ABOM%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[（一）BOM对象一、BOM是什么dom，指的是页面上的元素，而bom是针对浏览器的一种对象模型，用于描述这种对象与对象之间层次关系的模型。浏览器本身的特性（如当前位置、浏览器宽高、以及系统环境等），而这些与当前的web页面并无关系，而是与当前的window（整个浏览器的窗口，不只是页面，不要误解）相关。 二、BOM包含什么？BOM的核心是window对象。表示浏览器的一个实例。在浏览器中，即是javascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象，这就意味着在网页中定义的任意变量、函数、对象都是以window作为Global对象。 注：所有在全局作用域中声明的变量、函数、对象都会作为window的属性和方法，如全局变量都是window对象的一个属性如在全局作用域下，在控制台下1234567891011121314var a = 1window.a --&gt;1/* 或 */window.document--&gt;#document/* 或声明一个函数如 */function printName()&#123; console.log(age);&#125;window.printName--&gt;ƒ printName()&#123; console.log(age);&#125; 三、常用的window对象1、window.innerHeight和 window.innerWidth返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。即当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小 （1）window.innerHeight123//我随意调了浏览器的大小后的高度window.innerHeight--&gt;568 （2）window.innerWidth12window.innerWidth--&gt;320 2、window.scrollTo、window.scrollBy、window.scroll12window.scrollTo(0, 0) //页面回到顶部window.scrollTo(0, 300) // 滚动条移动到300px处 两个参数分别是水平、垂直方向偏移 scrollBy可以相对当前位置移动滚动条，而不是移动到绝对位置1scrollBy(0, 100); // 滚动条下移100px 移动端滚动：window.scrollTo(0,1);即手机浏览器上的搜索栏则会本隐藏掉 3、navigatornavigator是一个存储浏览器相关信息的对象。作为属性，它的值也是一个对象。打开控制台所示，有部分重要参数了解一下：1234//表示的是当前用户代理是什么，即使用什么设备用浏览器userAgent:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&quot;navigator.userAgent&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&quot; 4、window.getComputedStyle1var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;); 获取当前元素所有最终使用的样式的属性 5、scrollX和scrollY这两个值随着滚动位置变化而变化 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 6、window.frameswindow.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。如何在当前页面下定位到a.html里面的dom元素？如图：此时可以使用window.frames去获取所有iframe，定位到含有a.html的这个对象，再从里面获取我们所需要的dom元素（注意同源策略问题出现） 需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 7、screen并不是浏览器的屏幕，指的是当前设备的屏幕 8、URL的编码/解码方法可以先看看若愚老师写的这篇文章，对于编码和乱码会有一个初步的认识：若愚：聊一聊编码与乱码 JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 如当我们在某网页的控制台里输入：12location.href--&gt;&quot;http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/bom.html&quot; url中包含的中文字符，自动转码，即encodeURI()转换成unidode码注： encodeURI方法不会对下列字符编码1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+&apos; encodeURIComponent方法不会对下列字符编码1231. ASCII字母2. 数字3. ~!*()&apos; 如何用？ 实际例子来说，encodeURIComponent会把 http:// 编码成 http%3A%2F%2F而encodeURI却不会。如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。1encodeURI(&quot;http://blog.jirengu.com/?cat=11&amp;a=饥人谷&quot;); //&quot;http://blog.jirengu.com/?cat=11&amp;a=%25E9%25A5%25A5%25E4%25BA%25BA%25E8%25B0%25B7&quot;; 其中，汉字被编码。但是如果你用了encodeURIComponent，那么结果变为1&quot;http%3A%2F%2Fblog.jirengu.com%2F%3Fcat%3D11%26a%3D%25E9%25A5%25A5%25E4%25BA%25BA%25E8%25B0%25B7&quot; escape,encodeURI,encodeURIComponent有什么区别? 了解一下：个人倾向于这个回答：escape,encodeURI,encodeURIComponent有什么区别? 9、alert()，prompt()，confirm()三者都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 alert()1alert(1) 如图： prompt()1234var a = prompt(&apos;enter something&apos;) //跳出弹出框//undefineda//&quot;100&quot; 如图： confirm()1234var isOk = confirm(&apos;r u ok?&apos;)//弹出确定/取消键// undefinedisOk// true confirm方法返回一个布尔值，如果用户点击“确定”，则返回true；如果用户点击“取消”，则返回false。 （二）浏览器存储cookie &amp; session &amp; localStorage 一、cookie1、cookie 是什么：储存在用户本地终端上的数据，也叫浏览器缓存 2、如何找到cookie：打开页面控制台——Application——Storeage——localstorge、cookie（对象）cookie用于把一些记录信息存储在当前的页面下。存储在cookie当前域名下的一小段数据，存储空间很小，不超过4kb；对应参数Name、Value、Domain、Path、Expires（生效时间）、Size等，如图： 设置cookie时的参数： path：表示 cookie影响到的路径，匹配该路径才发送这个cookie。expires 和 maxAge：告诉浏览器cookie时候过期，maxAge是cookie多久后过期的相对时间。不设置这两个选项时会产生sessioncookie，sessioncookie是transient的，当用户关闭浏览器时，就被清除。一般用来保存session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到cookie。 3、cookie 怎么产生：Cookie是由Web服务器保存在用户浏览器 (客户端 )上的小文本文件,它可 以包含有关用户的信息。由网络服务器发送出来存储在网络浏览器上，下次它回到该网络服务器时，还可以在该浏览器读此信息。 注： 每次向服务端发送请求，Cookies都会被带到HTTP中，即网络请求 Request headers中都会带上cookie。如果cookie太多太大，造成负载太大，对传输效率会有影响。 4、常用做法：cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用HTTP协议规定的set-cookie来让浏览器种下cookie，这是最常见的做法。（打开一个网站，清除全部cookie，然后刷新页面，在network的Responseheaders试试找一找set-cookie吧）。比如百度搜索，输入网址——向服务器发请求——服务器给出响应，打开控制台——Network——Headers，看见响应头、尾。响应头对应有set-cookie该请求，浏览器则把该字段种进cookie里面。 查看cookie： cookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。在控制台用「document.cookie」查看你当前正在浏览的网站的cookie。 5、Cookies可以加失效日期，失效日期过了，就会自动删除Cookies，一般来说可以用Cookies记录用户名，不能记录密码，否则不安全。6、可以在浏览器中存储东西，和LocalStorage作用类似；可以控制cookie的生命期，Cookie数量和长度受限制二、localstorge1、localStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 js手动清除。2、不参与网络传输。3、一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。localstorge：对应参数key、value，存储量大 如何存储数据，如控制台测试效果： 假设讲一个数组存储进localstorge[&#39;name&#39;],它会自动将数组转换成字符串，出现的name的数据则为[object object],即数据已经丢失,如图： 想要把一个对象存储进localstorge，将对象转换成字符串（二者可用json互转）存储进去，如图： 4、SessionStorage VS LocalStorageSessionStorage和LocalStorage接口类似，但是SessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。 三、session1、Session是一种特殊的Cookies，用于识别用户。cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在cookie中了，而且如果cookie中数据字段太多会影响传输效率。为了解决这些问题，就产生了session，session中的数据是保留在服务器端的。 当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。 用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个session，用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。 2、session 的运作通过一个session_id来进行。session_id通常是存放在客户端的cookie中，比如在express中，默认是connect.sid这个字段，当请求到来时，服务端检查cookie中保存的session_id并通过这个session_id与服务器端的sessiondata关联起来，进行数据的保存和修改。 即当你浏览一个网页时，服务端随机产生一个1024比特长的字符串，然后存在你 cookie 中的connect.sid字段中。当你下次访问时，cookie会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。 创建session后，会把关联的session_id通过setCookie添加到http响应头部中。 浏览器在加载页面时发现响应头部有set-cookie字段，就把这个cookie 种到浏览器指定域名下。 当下次刷新页面时，发送的请求会带上这条cookie，服务端在接收到后根据这个session_id来识别用户。 cookie 是存储在浏览器里的一小段「数据」，而session是一种让服务器能识别某个用户的「机制」，session在实现的过程中需要使用cookie。当然有时候说到 session 也指服务器里创建的那个和用户身份关联的对象。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>BOM对象</tag>
        <tag>浏览器储存</tag>
        <tag>cookie &amp; session &amp; localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：10-03常见和自定义事件使用]]></title>
    <url>%2F2018%2F08%2F17%2F38-10.03%E5%B8%B8%E8%A7%81%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、click—点击事件代码如下：1234$(&apos;#btn&apos;).addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;click&apos;) console.log(this) &#125;) 二、dblclick—双击左键，监听左键1234$(&apos;#btn1&apos;).addEventListener(&apos;dblclick&apos;, function()&#123; console.log(&apos;dblclick&apos;) console.log(this)&#125;) 三、鼠标放上去触发事件1、mouse1 mouseover—当鼠标放上去时，则触发事件 mouseoutr—当鼠标跨到另一领域时，则与mouseover同时触发事件代码如下 ：1234567891011121314 //当鼠标放上去时，则触发事件 $(&apos;.ct&apos;).addEventListener(&apos;mouseover&apos;, function()&#123; console.log(&apos;mouseover&apos;) console.log(this) //this.style.borderColor = &apos;blue&apos; this.classList.add(&apos;hover&apos;) &#125;)//鼠标移出的时（不管是移出孩子还是父亲），则会触发事件，且每次只触发一次： $(&apos;.ct&apos;).addEventListener(&apos;mouseout&apos;, function()&#123; console.log(&apos;mouseout...&apos;) //this.style.borderColor = &apos;red&apos; this.classList.remove(&apos;hover&apos;) &#125;) 移动的情况一：从外—老子内框——儿子框—退回老子框——外，控制台打印结果为：12345678910111213//外—老子内框mouseover &lt;div class=&quot;ct hover&quot; style=&quot;font-size: 20px&quot;&gt;…&lt;/div&gt;//老子内框——儿子框mouseout...mouseover&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;//儿子框—退回老子框mouseout...mouseover&lt;div class=&quot;ct hover&quot; style=&quot;font-size: 20px&quot;&gt;…&lt;/div&gt;//退回老子框——外mouseout... 移动的情况二：从外—老子内框—儿子框—外，控制台打印结果为：123456789//外—老子内框mouseover&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;//老子内框—儿子框mouseout...mouseover&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt;//儿子框—外mouseout... 在控制台测试之后，老子内框—儿子框，每次穿过子元素都会触发该事件，就会相对应地出现mouseout...和mouseover123mouseout...mouseover&lt;div class=&quot;ct hover&quot; style=&quot;font-size:20px&quot;&gt;…&lt;/div&gt; 2、mouse2 mouseenter—只要在该事件的范围内，则只触发一次 mouseleave—只要离开这个事件，则触发该事件代码如下:12345678910111213//鼠标进去 $(&apos;.ct1&apos;).addEventListener(&apos;mouseenter&apos;, function()&#123; console.log(&apos;mouseenter...&apos;) //this.style.borderColor = &apos;blue&apos; this.classList.add(&apos;hover&apos;) &#125;) //鼠标离开 $(&apos;.ct1&apos;).addEventListener(&apos;mouseleave&apos;, function()&#123; console.log(&apos;mouseleave...&apos;) //this.style.borderColor = &apos;blue&apos; this.classList.remove(&apos;hover&apos;) &#125;) 图： 四、input输入表单1、焦点问题 focus—获取焦点状态 blur —失去焦点状态代码如下：123456789101112 /*focus，获取焦点的一个状态：点击之后出现focus，focus为被激活状态，用户可以去输入内容*/ $(&apos;#input-name&apos;).addEventListener(&apos;focus&apos;, function()&#123; console.log(&apos;focus...&apos;) console.log(this.value) &#125;) /*blur，失去焦点状态：当鼠标移出输入框再点击页面任意处，则输入框是无法输入任何东西*/ $(&apos;#input-name&apos;).addEventListener(&apos;blur&apos;, function()&#123; console.log(&apos;blur...&apos;) console.log(this.value) &#125;) 图：用于校验： 当用户输入完对应内容后，当tab切换了下一个输入框（或做了其他的事情），就会失去焦点，也就blur 2、keyup 输入后按下确定键，再松开代码如下：1234567//keyup，输入内容按下，再松开$(&apos;#input-name&apos;).addEventListener(&apos;keyup&apos;, function(e)&#123; console.log(&apos;keyup...&apos;) console.log(this.value) console.log(e) this.value = this.value.toUpperCase() &#125;) 图： 3、change 当输入框里的值改变，并失去焦点，则会触发change事件代码如下：1234567$(&apos;#input-name&apos;).addEventListener(&apos;change&apos;, function(e)&#123; console.log(&apos;change...&apos;) console.log(this.value) console.log(e) this.value = this.value.toUpperCase() //当监听到change事件时，则执行这一行，this.value则能获取当前表单设置的值，toUpperCase则变为大写，重新设置这个值 &#125;) 图： 五、submit —表单按钮提交触发submit事件即form表单事件。form表单，有一个按钮需要提交，此时用JS触发submit即直接使用form.submit，此时则会触发submit事件，此时form则会监听到代码如下：12345678910$(&apos;#form&apos;).addEventListener(&apos;submit&apos;, function(e)&#123; e.preventDefault(); //先阻止一些默认事件（即先不要提交） if(/^\w&#123;6,12&#125;$/.test($(&apos;#username&apos;).value))&#123; //再做一些检测 $(&apos;#form&apos;).submit(); &#125;else&#123; $(&apos;#form .msg&apos;).innerText = &apos;出错了&apos; $(&apos;#form .msg&apos;).style.display = &apos;block&apos; console.log(&apos; no submit...&apos;); &#125; &#125;) 六、window事件1、scroll —滚动事件。当你滚动的时，会触发scroll事件（会触发多次）代码如下：123window.addEventListener(&apos;scroll&apos;, function(e)&#123; console.log(&apos;scroll..&apos;) &#125;) 2、resize —窗口变化事件。当窗口发生变化时，会触发resize事件（会触发多次）代码如下：123window.addEventListener(&apos;resize&apos;, function(e)&#123; console.log(&apos;resize..&apos;) &#125;) 图： 七、load/onload事件1、在window上代码如下：1234//当页面所有资源加载完成，则触发(涉及到所有资源，所以触发时机较晚） window.onload = function()&#123; console.log(&apos;window loaded&apos;) &#125; 2、在document上代码如下：1234 //DOM 结构解析完成（并不是页面上资源加载完成，而是dom结构渲染完成）document.addEventListener(&apos;DOMContentLoaded&apos;, function()&#123; console.log(&apos;DOMContentLoaded &apos;) &#125;) （浏览器渲染步骤其一）dom结构渲染完成，即并不是页面上资源加载完成，而是dom结构渲染完成。html被解析之后渲染成dom，用JS可以获取这个dom对象（不一定能看到效果，或者所引入的css或者图片等资源都不一定加载完成） 虽然可以用JS操作其元素，但在某些场景下dom元素仍不存在，这里涉及到浏览器的渲染加载机制（可回顾旧知识：），如：图：得出的结果为null，是因为这里的js不是一个外链，会直接就去解析js并执行，后续的dom结构并没有渲染出来。 那么，如果我们把js放在body后面，则会输出一些结果：但如果还是需要将js放在head里，那么就需要：链接：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt; document.addEventListener(&apos;DOMContentLoaded&apos;,function()&#123; var btn = document.querySelector(&apos;#btn&apos;) console.log(btn) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 控制台打印输出：总结： 实践可知，可知为何使用document的onload事件，而不是用window上的onload事件。window上的onload必须要求所有页面资源加载完成，只是通过一个变量实现js操作，仍要按顺序去执行；而document则只需dom结构渲染完成，绑定DOMContentLoaded就可以执行onload事件，灵活方便。 onload的图片加载实践用到onload的两类事件：代码如下：1234console.log($(&apos;img&apos;).width) //0 $(&apos;img&apos;).onload = function()&#123; //211：通过这一步，输出图片宽度211 console.log(this.width) //window.loaded网络请求到达，加载，图片到达，触发，此时才能获取图片的真实大小 &#125; 0：图片宽度为0，是因为js立刻执行，但执行过程中有网络请求（有时间限制），网络请求还没到（即资源图片等还没来），图片暂时获取的是img标签，那么此时图片宽度为0 DOMContentLoaded：此时，通过DOMContentLoaded绑定事件，dom结构渲染完成，触发DOMContentLoaded事件，输出：DOMContentLoaded 八、自定义事件监听click事件，当用户监听的时候，就会有响应1234567891011121314151617var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125;&#125;//绑定的事件EventCenter.on(&apos;hello&apos;, function(e)&#123; console.log(e.detail)&#125;)//用户所执行的交互行为EventCenter.fire(&apos;hello&apos;, &apos;你好&apos;) 实现对象分析：对象EventCenter中有两个函数，对应的有两个属性：on、fire 事件方法分析：EventCenter.on，一个对象里有一个on方法，当EventCenter听到&#39;hello&#39;事件时，去执行function(e)这个事件监听函数，通过e.detail获取该事件的内容。此为绑定的事件概述 绑定好之后，在某些场景下，用户执行EventCenter.fire(&#39;hello&#39;,&#39;你好&#39;)，则会执行事件&#39;hello&#39;，后面加一些内容，如’你好’。与之对应的则是刚才的e.detail内容。 实践： 如做轮播和对应内容，可把它们作为两个不同的个体，只需要通过绑定一个下一步事件，和具体内容，便可指定对应内容该做的“下一步”的工作何时加载、触发、执行 例如： 链接：http://js.jirengu.com/vovig/1/edit?html,js,output123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125;&#125;/*组件一中的一个功能点*/document.querySelector(&apos;.box input&apos;).oninput = function()&#123; EventCenter.fire(&apos;box1input&apos;,this.value)&#125;//发送一个事件：&apos;box1input&apos;，用户输入的值：this.value//作用就是告诉别人我有这样一个绑定事件的消息/*组件二的一个功能点*/EventCenter.on(&apos;box1input&apos;,function(e)&#123; document.querySelector(&apos;.box2&apos;).innerText = e.detail&#125;)//函数表示：当EventCenter听到box1input这个事件的时候，则内部发生一些改变。//组件一中的消息是通过EventCenter作为媒介传递两个组件检的解绑]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>常见事件和使用</tag>
        <tag>自定义事件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：10-02事件对象和事件代理]]></title>
    <url>%2F2018%2F08%2F17%2F37-10.02%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、事件的IE兼容性在老版的IE浏览器中，不支持：addEventListener和removeEventListener两种事件绑定的方法;支持（可实现）：attachEvent和detachEvent 两种方法，同时接收两个相同参数 a、事件处理程序名称 b、事件处理程序方法 由于IE支持事件冒泡，所以添加的程序会被添加到冒泡阶段，使用attachEvent可以添加事件处理程序：123456789&lt;input id=&quot;btnClick&quot; type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;&lt;script&gt; var btnClick = document.getElementById(&apos;btnClick&apos;) var handler = function()&#123; alert(this.id)&#125; btnClick.attachEvent(&apos;onclick&apos;,handler);&lt;/script&gt; attachEvent只能在冒泡阶段监听事件，只有两个参数：(事件类型，事件处理函数) ie中的this：它所得到的并不是当前元素，而是window对象，返回值则为undefined 二、跨浏览器的事件处理程序了解不同的浏览器下处理事件处理程序的区别在添加事件处理程序事addEventListener和attachEvent主要有几个区别： 1、参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段） 2、第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 3、事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window，所以刚才例子才会返回undefined，而不是元素id 4、为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了)，所以添加多个的时候，不依赖执行顺序的还好，若是依赖于函数执行顺序，最好自己处理，不要指望浏览器 三、事件对象 如刚才例子中在控制台上打印出事件，事件内都是一些对象（带有属性和值），可以从这堆属性中观察到一些重要的参考（只是部分例举），如：12345altKey:false //表示在点击事件的时候，没有点alt键bubbles:true //表示这个事件是冒泡clientX:39clientY:18 //表示它的一个位置toElement:button#btn //说明当前传递的元素 介绍几个常用属性： stopPropagation()如图：阻止冒泡继续？在dom事件流中，分别会在捕获和冒泡阶段都绑定事件，先捕获后冒泡进行输出。假设我们现在不管捕获，只管冒泡，并给body绑定一个监听事件，当它听到事件做了一件事：一点stopPropagation()就停止冒泡，即点击div之后，body监听到消息，后面的页面元素渲染就不再处理。即将事件冒泡停止，不会再上传消息。捕获也亦然。 preventDefault()浏览器的默认事件如何阻止？某些元素拥有默认事件，为浏览器的默认行为。如a链接点击时则会跳转、如form表单中table=submit，当点击该按钮时，浏览器会把它所在的form表单做一次提交。假设想阻止其默认行为，则可以通过绑定事件：preventDefault()阻止其行为。之后再做一些校验或判断，用JS做当前页面跳转。即在跳转这一层级可以做些事：假设制定一个域名的a链接才能跳转（而页面则是用户可自行写链接）先阻止其默认时间，再获取当前herf的值、hostname（域名） 假设表单提交，用户校验，校验成功之后，就手动去做一些跳转 e.stopPropagation() 取消事件进一步捕获或冒泡事件冒泡和事件捕获的应用场景123456789101112131415161718192021222324252627282930313233//选中元素var container = document.querySelector(&apos;.container&apos;)var box = document.querySelector(&apos;.box&apos;)var target = document.querySelector(&apos;.target&apos;)//绑定事件container.addEventListener(&apos;click&apos;, function(e)&#123; console.log(&apos;container 捕获 click...&apos;)&#125;,true)box.addEventListener(&apos;click&apos;, function(e)&#123; console.log(&apos;box 捕获 click...&apos;)&#125;,true)target.addEventListener(&apos;click&apos;,function(e)&#123; console.log(&apos;target 捕获 click...&apos;)&#125;,true)container.addEventListener(&apos;click&apos;, function(e)&#123; console.log(&apos;container 冒泡 click...&apos;)&#125;,false)box.addEventListener(&apos;click&apos;, function(e)&#123; e.stopPropagation() console.log(&apos;box 冒泡 click...&apos;)&#125;,false)target.addEventListener(&apos;click&apos;,function(e)&#123; console.log(&apos;target 冒泡 click...&apos;)&#125;,false) 如图：多个阻止函数来阻止冒泡事件 e.preventDefault() 阻止事件默认行为链接：阻止事件默认行为刚开始是这样的：没有跳转，只有一直输出：代码：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;阻止默认事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://baidu.com&quot;&gt;baidu&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;&lt;script&gt; document.querySelector(&apos;a&apos;).onclick = function(e)&#123; e.preventDefault() console.log(this.href)&#125;&lt;/script&gt; 接着看图所示，添加一个if判断，再点击baidu链接，控制台只输出一次地址，页面则出现百度的网页：代码：1234567891011//html同上&lt;script&gt;document.querySelector(&apos;a&apos;).onclick = function(e)&#123; e.preventDefault() console.log(this.href) if(/baidu.com/.test(this.href))&#123; location.href = this.href &#125;&#125;//函数表示：如果这个链接是baidu.com,那就跳转&lt;/script&gt; 假如html代码中1&lt;a href=&quot;http://baidu.com&quot;&gt;baidu&lt;/a&gt; 改为：1&lt;a href=&quot;http://baid.com&quot;&gt;baidu&lt;/a&gt; 最后页面和控制台都不会有任何反应。而这就是e.preventDefault() 阻止事件默认行为 四、常用HTML事件及演示例子链接：缺常见事件使用演示链接 五、事件代理链接：事件代理的一些尝试首先，我们为两个box绑定两个事件，先绑定box1，如图：通过选择参数$(&#39;.box&#39;)作为box1的当前元素，所以再去绑定事件之后，则只会出现第一个box1文本内容。 但是，我们尝试地使用函数$$(selector)绑定两个元素的事件，再点击box1和box2没有任何输出，如图： 通过页面控制台检验：12345678$$(&apos;.box&apos;) --&gt; NodeList(2) [div.box, div.box]//1、确实出现了所选的两个元素，但是要确认有没有onclick 0: div.box 1: div.box length: 2 __proto__: NodeList //3、我们所看到NodeList，是一个类数组对象，里面的属性值并没有onclick和addEventListener$$(&apos;.box&apos;).onclick //2、于是测试之后undefined，即绑定事件只能针对单个去绑定事件 --&gt; undefined 那如何解决两个元素同时绑定事件呢？还是从控制台nodelist的对象中寻找可用的参数去解决，即有forEach遍历两个元素，实现两个都绑定了事件，即：123456789101112//html同上&lt;script&gt;function $$(selector)&#123; return document.querySelectorAll(selector)&#125;$$(&apos;.box&apos;).forEach(function(node)&#123; node.onclick = function()&#123; console.log(this.innerText) &#125;&#125;)&lt;/script&gt; 图：那么，我们有没有更简单的方法实现当前所有元素都绑定了事件？看html即可以知道，我们可以直接绑定父元素container，即123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;box2&lt;/div&gt; &lt;div class=&quot;hello&quot;&gt;hello&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;function $(selector)&#123; return document.querySelector(selector)&#125;function $$(selector)&#123; return document.querySelectorAll(selector)&#125;$(&apos;.container&apos;).onclick = function(e)&#123; if(e.target.classList.contains(&apos;box&apos;))&#123; console.log(e.target.innerText) &#125;&#125;//表示：如果我点击了一个元素（e.target），它的classList包含了&apos;box&apos;，//那么它就输出这个元素的文本内容。具有语义化&lt;/script&gt; 再想到更多的场景，如有一个按钮，如何绑定这个按钮实现这样一个需求：当点击这个按钮的时候，则会在父元素下再添加一个box。这个如何实现？如图：代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;box2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;box3&lt;/div&gt; &lt;div class=&quot;hello&quot;&gt;hello&lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;add&quot;&gt;add&lt;/button&gt; &lt;!--需求：当点击这个按钮的时候，则会在父元素下再添加一个box--&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;function $(selector)&#123; return document.querySelector(selector)&#125;function $$(selector)&#123; return document.querySelectorAll(selector)&#125;$(&apos;.container&apos;).onclick = function(e)&#123; if(e.target.classList.contains(&apos;box&apos;))&#123; console.log(e.target.innerText) &#125;&#125;//事件代理的核心所在//表示：如果我点击了一个元素（e.target），它的classList包含了&apos;box&apos;，那么它就输出这个元素的文本内容。具有语义化var i=4 //这是因为之前有box3了$(&apos;#add&apos;).onclick = function()&#123; var box = document.createElement(&apos;div&apos;)//创建一个box元素 box.classList.add(&apos;box&apos;)//创建的当前元素去添加一个class叫做box box.innerText =&apos;box&apos; + (i++)//表示每点击一次i就增加一个 $(&apos;.container&apos;).appendChild(box)//最后将box这个元素添加进.container里面&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件对象</tag>
        <tag>事件代理</tag>
        <tag>事件的IE兼容性</tag>
        <tag>跨浏览器的事件处理程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：10-01事件（流）和事件处理程序]]></title>
    <url>%2F2018%2F08%2F17%2F36-10.01%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%B5%81%EF%BC%89%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言：最近，很多事情的时间交叉点汇集到一起，时间明显越来越少了。因为要学做项目了，写博客的记录已经赶不上课程的学习进度，记录知识在博客真的是一个耗费时间和精力的事情啊，这其中还要查资料、弄懂知识点，而且也到了再一次梳理知识集中问老师的时候。赶着时间学习，会有一种赶着你跑的冲劲，加油吧。 一、事件dom操作，可以用JS在页面上操作元素。不过dom操作需要一个时机，即跟用户交互时，什么时候才能改变这个dom结构，那么此时就用到了事件。 用户在浏览器上的任何操作，都可能触发一个事件，如鼠标移动。滚动页面、点击、甚至鼠标放在页面上的某处等任何的页面操作都会触发一个事件。 二、事件流事件是如何产生和如何传播假设事件不传播，无任何事件传播机制，点到什么是什么。那么，当我们点击整个页面的dom，事件却不传播，那页面中的某层结构怎么知道点击了该事件，那又如何去触发事件？ 1、事件冒泡模型元素先监听到这个事件，往外传播 2、事件捕获模型document最先监听到这个事件 3、DOM事件流先捕获，再冒泡允许在某些地方监听事件，假设在某个元素两阶段都绑定一个事件监听器，看你是决定在左边捕获阶段监听，还是右边冒泡阶段监听，哪一边有响应，哪一边事件就被触发。即可以在任一阶段、任意时机监听事件 三、事件的使用方式1、事件处理程序也叫事件侦听器。当用户点击（或当某个事件触发的时候），我们所要做的事情。 2、如何绑定事件处理程序？ JavaScript指定事件处理程序 （1）对一个元素绑定一个事件函数：语法：12345678&lt;input id=&quot;btnClick&quot; type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btnClick = document.getElementById(&apos;btnClick&apos;);//声明一个变量，选择这个元素给它做个赋值，选择这个dom元素 btnClick.onclick = function showMessage() &#123; //元素.事件(),元素绑定一个事件，即onclick，该事件名可以改，如oniput、onfocus等（本身没有执行，只有当事件触触发，即用户交互时，才会被执行） alert(this.id);//this相当于btnClick这个元素，作为一个占位符存在 &#125;;&lt;/script&gt; 函数什么时候执行？看此例子：当用户点击触发事件时，就会将该事件的对应执行放进任务队列里，此时这个事件函数才会去被执行。由此可以明白两件事： 绑定这个函数事件则是同步 点击、执行函数事件的操作是异步 （2）对一个元素绑定多个事件函数看下面这个例子：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var btn = document.querySelector(&apos;#btn&apos;)//#事件01btn.onclick = function()&#123;console.log(this)console.log(this.innerText)&#125;//#事件02 btn.onclick = function()&#123; console.log(&apos;hello world&apos;)&#125;&lt;/script&gt; 总结： 这个时候，添加了#02事件函数，并点击按钮click me,发事件函数，输出&#39;hello world&#39;，直接覆盖#01事件函数的值。 DOM2事件处理程序（实现对一个元素绑定多个事件） （1）dom作为事件处理的一个基本标准，dom2级事件为dom事件的升级。（2）DOM2级事件定义用于处理指定和删除事件处理程序的操作： addEventListener removeEventListener （3）所有的DOM节点都包含这两个方法，并且它们都接受三个参数： A、事件类型 B、事件处理方法 C、布尔参数， 如果是true表示在捕获阶段调用事件处理程序，如果是false，则是在事件冒泡阶段处理 （4）绑定事件方法实例演示：addEventListener 绑定事件（直接执行一个函数） 12345678&lt;input id=&quot;btnClick&quot; type=&quot;button&quot; value=&quot;Click Here&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btnClick = document.getElementById(&apos;btnClick&apos;); btnClick.addEventListener(&apos;click&apos;, function() &#123; alert(this.id); //函数里的this代表当前的元素btnClick，所以我们可以通过this.id获取当前元素的id &#125;, false);&lt;/script&gt; 例子： 总结： 这里并不是给变量添加一个值，而是通过执行addEventListener 这样一个函数，函数可以执行多次，对同样事件可以做多个绑定做不同的事情，也不会产生覆盖。 区别: 1、JavaScript指定事件：btnClick.onclick =functionshowMessage(){alert(this.id);} 为属性添加一个值；DOM2事件处理程序:addEventListener 执行一个函数2、JavaScript指定事件的事件是：onclick，DOM2事件处理程序的事件是：click3、DOM2事件处理程序的dom节点最后还可以添加布尔值，表示处于冒泡阶段（false）还是捕获阶段（true）。默认情况下（无传进参数），为冒泡阶段（false）4、this：alert(this.id)函数里的this代表当前的元素btnClick，所以我们可以通过this.id获取当前元素的id 思考：事件到底是什么？此时我们可以通过下面例子来说明事件的一些问题： 例子链接： http://js.jirengu.com/hahid/1/edit?html,js12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//简单的绑定事件,可通过此方法进行绑定var btn = document.querySelector(&apos;#btn&apos;)btn.onclick = function (e)&#123; console.log(e)&#125;//通过这个函数可以用来查看这个事件。可以在里面传一个参数e//或者采用另一种绑定事件的方法：btn.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e)&#125;)&lt;/script&gt;//注：e，只是一个自定义的参数，可以随意改变参数名 点击click时，在控制台上打印出事件，事件内都是一些对象（带有属性和值），可以从这堆属性中观察到一些重要的参考（只是部分例举），如：12345altKey:false //表示在点击事件的时候，没有点alt键bubbles:true //表示这个事件是冒泡clientX:39clientY:18 //表示它的一个位置toElement:button#btn //说明当前传递的元素 这里可以通过（e.target）看一看到底点击了哪个元素，并不是我们通常意义下看到的例子中的当前元素btn，现在一般来说，绑定一个事件可以使用以下几个方法（续上面的例子）：12345678910&lt;script&gt;var btn = document.querySelector(&apos;#btn&apos;)btn.addEventListener(&apos;click&apos;,function(e)&#123; console.log(this)//或 console.log(btn)//或 console.log(e.target)&#125;)&lt;/script&gt; （5）如何解绑事件（一般情况下不做）removeEventListener 解绑事件。与addEventListener相对应，通过removeEventListener移除解绑事件，表现为点击时无反应 需要注意的是，removeEventListener解绑事件，不能使用匿名函数（无法获知要移除哪一个），正确如：1234567&lt;script type=&quot;text/javascript&quot;&gt; var btnClick = document.getElementById(&apos;btnClick&apos;); var handler=function() &#123; alert(this.id); &#125; btnClick.removeEventListener(&apos;click&apos;, handler, false);&lt;/script&gt; （6）事件整体实例展示A、冒泡阶段·实例展示12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt; &lt;div class=&quot;container&quot;&gt; container &lt;div class=&quot;box&quot;&gt; box &lt;div class=&quot;target&quot;&gt; hello &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//选中元素var container = document.querySelector(&apos;.container&apos;)var box = document.querySelector(&apos;.box&apos;)var target = document.querySelector(&apos;.target&apos;)//绑定事件container.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;container click...&apos;)&#125;)box.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;box click...&apos;)&#125;)target.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;target click...&apos;)&#125;)&lt;/script&gt; 默认情况下（无传进的参数），事件绑定是呈现冒泡阶段，执行结果展示： 执行的过程事实上是，点击这个事件的时候，一开始便是从container——box——hello，返回时，为冒泡阶段，从hello——box——container，绑定了事件，分别有了响应控制台分别打印出：123&quot;target click...&quot;&quot;box click...&quot;&quot;container click...&quot; 这一过程就像是从下到上的冒泡过程，冒泡过程中到哪个事件元素，触发，响应，则会执行对应事件函数 B、事件捕获阶段·实例展示1234567891011121314151617181920212223//html同上&lt;script&gt;//选中元素var container = document.querySelector(&apos;.container&apos;)var box = document.querySelector(&apos;.box&apos;)var target = document.querySelector(&apos;.target&apos;)//绑定事件,添加了参数truecontainer.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;container click...&apos;)&#125;,true)box.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;box click...&apos;)&#125;,true)target.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;target click...&apos;)&#125;,true)&lt;script&gt; 捕获阶段，点击事件hello，结果显示在刚进去的时候就绑定了事件，所以一开始事件元素就监听到，那么事件触发响应的过程就是hello——box——container，结果为：123&quot;container click...&quot;&quot;box click...&quot;&quot;target click...&quot; C、事件传播整体机制原理和实践·实例展示1234567891011121314151617181920212223242526272829303132333435//html同上&lt;script&gt;//选中元素var container = document.querySelector(&apos;.container&apos;)var box = document.querySelector(&apos;.box&apos;)var target = document.querySelector(&apos;.target&apos;)//绑定事件//捕获事件绑定container.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;container 捕获 click...&apos;)&#125;,true)box.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;box 捕获 click...&apos;)&#125;,true)target.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;target 捕获 click...&apos;)&#125;,true)//冒泡事件绑定container.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;container 冒泡 click...&apos;)&#125;,false)box.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;box 冒泡 click...&apos;)&#125;,false)target.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;target 冒泡 click...&apos;)&#125;,false)&lt;/script&gt; 如图所示：结果输出，说明是先进行捕获事件触发、响应，再到冒泡事件触发、响应，先进后出： 【不常用】HTML内联方式——onclick ，当用户点击的时候的事件 1&lt;input type=&quot;button&quot; value=&quot;Click Here&quot; onclick=&quot;alert(&apos;Clicked!&apos;);&quot; /&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件（流）</tag>
        <tag>事件处理程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：09 DOM元素]]></title>
    <url>%2F2018%2F08%2F17%2F35-09%20DOM%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、DOM1、定义DOM，即文档对象模型（Document Object Model ） 2、现象通过在页面——打开：检查元素——看见：元素为可折叠。可选中页面对应元素，事实上即选择了对象（即也选择了对象对应的属性或方法），相当于把页面文档对象化。事实上，就是用js手段调用操作该文档（即一个对象）。 二、Document对象，属性（或方法）在DOM中最常用的对象就是：document对象（页面——检查，即查看属性）、element对象 1、常用属性123456document.doctypedocument.titledocument.characterSetdocument.headdocument.bodydocument.images 2、document.readyStatereadyState属性 返回当前文档的状态，共有三种可能的值: loading：加载HTML代码阶段，尚未完成解析 interactive：加载外部资源阶段 complete：全部加载完成 图：可在代码中加上几张图片元素，再设置网络条件为慢3G，则出现： 3、 document.compatModecompatMode 属性 返回浏览器处理文档的模式，可能的值为 BackCompat：向后兼容模式，也就是没有添加DOCTYPE CSS1Compat：严格模式，添加了DOCTYPE 4、document.location用于获取一个url 可直接使用location，如：12document.location === location //truedocument.location === window.location //true 总结： document.location === location === window.locationlocation属性返回一个只读对象，提供了当前文档的URL信息，如：123456789101112// 假定当前网址为http://user:passwd@www.example.com:4097/path/a.html?x=111#part1document.location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;document.location.protocol // &quot;http:&quot;document.location.host // &quot;www.example.com:4097&quot;document.location.hostname // &quot;www.example.com&quot;document.location.port // &quot;4097&quot;document.location.pathname // &quot;/path/a.html&quot;document.location.search // &quot;?x=111&quot;document.location.hash // &quot;#part1&quot;document.location.user // &quot;user&quot;document.location.password // &quot;passed&quot; 其他location属性调用方法：123456789101112131415// 跳转到另一个网址document.location.assign(&apos;http://www.google.com&apos;)// 优先从服务器重新加载document.location.reload(true)// 优先从本地缓存重新加载（默认值）document.location.reload(false)// 跳转到另一个网址，但当前文档不保留在history对象中，// 即无法用后退按钮，回到当前文档document.location.assign(&apos;http://www.google.com&apos;)// 将location对象转为字符串，等价于document.location.hrefdocument.location.toString() 5、document.write()用document.write()方法时，即向当前文档写入内容，只要当前文档还没有用close方法关闭，它所写入的内容就会追加在已有内容的后面。1 如果页面已经渲染完成再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 如果在页面渲染过程中调用write方法，并不会调用open方法。-需要注意的是，虽然调用close方法之后，无法再用write方法写入内容，但这时当前页面的其他DOM节点还是会继续加载。-做测试时，无须使用document.write()方法 三、Element对象，属性（或方法）document对应的具体元素应如何选取（或操作）？element对象表示页面上的元素。使用JS选择页面上的元素（element），然后对其做操作。 那么，对页面元素的操作有哪些？ A、选择它：通过一些方法找到其具体元素（如用css的id，class名，选择器、邻居、赋值等） B、处理它：对拥有类型为元素节点、文本节点、注释节点的子节点进行删除、增加、查找、修改等操作 1、几个常用属性1234567891011nodeName：元素标签名，还有个类似的tagNamenodeType：元素类型className：类名id：元素idchildren：子元素列表（HTMLCollection）childNodes：子元素列表（NodeList）firstChild：第一个子元素lastChild：最后一个子元素nextSibling：下一个兄弟元素previousSibling：上一个兄弟元素parentNode、parentElement：父元素 2、查询元素（如何选中一个元素？）（1）getElementById()结合页面元素使用 +document.getElementByid() 如图：利用此方法选中该id的页面位置 （2）getElementsByClassName() 注：有sdocument.getElementByClassName() 页面元素中不止独一无二的id名，还有类选择器，当我们在页面控制台上通过getElementByClassName()时，可获取（或查询）到一个或多个类选择器，会出现如图现象：这看上去有点像数组，呈现形式相似、也可以用下标去进行访问。但通过list.去查看，并没有有关排序push、pop等的调用数组的方法，而是一种类数组的形式。 通过：12list.constructor--&gt; ƒ HTMLCollection()&#123; [native code] &#125; 我们可以获知，document.getElementsByClassName() 所调用的是html里类的集合，其类型为HTMLCollection()，是一种页面元素的集合。 （3）getElementsByName()document.getElementsByName()通过此方法可以获取页面元素中带有name属性的html元素。比如form、img、frame、embed和object，返回一个NodeList格式的对象，不会实时反映元素的变化。如： （4）假设,类选择器有嵌套的话，我们如何获取嵌套于内的元素？如图：A、（较为繁琐的） ES3写法：getElementsByName().getElementsByName() 语法：document.getElementsByName().getElementsByName() 例子：12document.getElementsByClassName(&apos;box&apos;)[0].getElementsByClassName(&apos;child&apos;)--&gt; HTMLCollection [div.child] 事实上，使用document.getElementsByName()做一个联集，即无论是document还是任何一个对象，都可以使用：对象.XXXX 去做一个联集对象去获取相对应的准确元素。 B、（较为简便的）ES5写法：querySelector() 注：可用于选择id元素使用 语法：document.querySelector() 例子：12document.querySelector(&apos;.box .child&apos;)--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt; 不过，它选择元素的时候，只能获取一个元素，如页面元素中有多个div，只会默认选择html元素中排在第一个的div元素。 如果需要在选择元素时，多种页面元素希望可以同时选中，则可以使用这样的写法：querySelectorAll() 注： 可用于选择class元素时使用 例子：1234567//比如：document.querySelectorAll(&apos;div&apos;)--&gt; NodeList(3) [div.box, div.child, div.box]document.querySelectorAll(&apos;.box&apos;)--&gt; NodeList(2) [div.box, div.box]document.querySelectorAll(&apos;#target&apos;)--&gt; NodeList [p#target] 在控制台测试时，我们可以直接使用$()和$$()直接代document.querySelector()和document.querySelectorAll()1234$(&apos;#target&apos;)--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;$$(&apos;#target&apos;)--&gt; [p#target] 可以自己写个方法，让$()和$$()可以在代码编辑器中直接使用，如下：123456789101112//写个方法：function $(selector)&#123; return document.querySelector(selector)&#125;--&gt; undefined//即下面就可以在编辑器大胆使用$() 和 $$()，举几个例子：$(&apos;#target&apos;)--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;$(&apos;.box&apos;)--&gt; &lt;div class=&quot;box&quot;&gt;…&lt;/div&gt;$(&apos;.box .child&apos;)--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt; （5）getElementsByTagName()document.getElementsByTagName() 此方法返回所有指定标签的元素（搜索范围包括本身），返回值是一个HTMLCollection对象，也就是说，搜索结果是一个动态集合，任何元素的变化都会实时反映在返回的集合中。如图： 3、创建元素（1）createElement() 创建一个新的元素放到页面上 用此方法创建并传入html的元素标签，创建一个虚拟的dom。该dom的节点存在内存里，并没有放在页面上，用户看不见。如：1234567891011document.createElement(&apos;div&apos;)--&gt; &lt;div&gt;&lt;/div&gt;//可赋值一个变量，之后可通过该变量轻松获取var div = document.createElement(&apos;div&apos;)--&gt; undefineddiv--&gt; &lt;div&gt;&lt;/div&gt;var div = document.createElement(&apos;img&apos;)--&gt; undefineddiv--&gt; &lt;img&gt; （2）createTextNode()光出现元素标签还不够，我们可通过createTextNode()去创建（或生成）一个文本，将文本的内容放入元素中，如：1234var text = document.createTextNode(&apos;wangxiaoqin&apos;)--&gt; undefinedtext--&gt; &quot;wangxiaoqin&quot; （3）createDocumentFragment()该方法用来生成一个存在于内存的dom片段，但不属于当前文档。即不会生成一个标签，虚拟生成，常用于生成复杂的dom结构，然后插入当前文档。 正因为它不属于当前文档，所以并不参与页面的渲染加载的过程，它的任何改动都不会引发网页的重新渲染。比直接修改当前文档的DOM有更好的性能表现。 4、修改元素（1）appendChild()在元素末尾添加元素。把一个dom对象放入在另外一个对象的内部作为它的孩子 如：1234var newDiv = document.createElement(&quot;div&quot;)var newContent = document.createTextNode(&quot;Hello&quot;)newDiv.appendChild(newContent)//括号内为新添加的“孩子”--&gt; &quot;hello&quot; 看一个实例：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//选择该容器ul，获取指定元素var navbarNode = document.querySelector(&apos;.navbar&apos;)for(var i=0;i&lt;5;i++)&#123;//以下循环5此 //创建一个子元素li var child = document.createElement(&apos;li&apos;) //创建一个文本，参数为字符串 var text = document.createTextNode(&apos;hello&apos;+i) //修改元素 child.appendChild(text) //然后再把li放在我们的navbarNode里 navbarNode.append(child)&#125;&lt;/script&gt; 如图： 另一种方法： 使用appendChild()123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//选择该容器ul，获取指定元素var navbarNode = document.querySelector(&apos;.navbar&apos;)//创建一个虚拟的片段，可看成是一个虚拟标签，到最后放在navbarNode，该虚拟标签消失var fragment =document.createDocumentFragment()for(var i=0;i&lt;5;i++)&#123;//以下循环5此 //创建一个子元素li var child = document.createElement(&apos;li&apos;) //创建一个文本，参数为字符串 var text = document.createTextNode(&apos;helloo&apos;+i) //修改元素 child.appendChild(text) //然后再把li放在我们的frgment这个虚拟片段里 fragment.appendChild(child)&#125;//再将这个片段放在navbarNode里navbarNode.appendChild(fragment)&lt;/script&gt; 如图：在控制台我们可以看到：再回看JS代码，则可以知道，1var fragment =document.createDocumentFragment() 这里创建的这个虚拟片段，我们可看成是一个虚拟标签，到最后放在navbarNode，该虚拟标签消失。并不影响实际页面元素的改动。 假设：我们在createDocumentFragment()里加上一个实际的块元素包裹li，那么则不符合页面的规则，如：控制台则如：这显然不符合规则 （2）insertBefore()在某个元素之前插入元素123var newDiv = document.createElement(&quot;div&quot;)var newContent = document.createTextNode(&quot;Hello&quot;)newDiv.insertBefore(newContent, newDiv.firstChild) （3）replaceChild()replaceChild()接受两个参数：要插入的元素和要替换的元素 1newDiv.replaceChild(newElement, oldElement) 5、删除元素removeChild() 用于删除元素1parentNode.removeChild(childNode) 6、clone元素克隆一个完成的dom节点。方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身1node.cloneNode(true) 四、属性的操作（即修改dom元素的属性的操作方法）1、getAttribute()（现有页面中有一个图片地址，所对应的是一个src的地址，如果更换图片，则需要修改src对应的值。（或获取一个img的src，或a链接的href））用于获取元素的属性值，如：1node.getAttribute(&apos;id&apos;) 2、createAttribute() 【一般用不到，一般不创建】用于创建（或获取）属性名，如1attribute = document.createAttribute(name)//参数name，是属性的名称 3、setAttribute()用于设置属性和值12var node = document.getElementById(&quot;div1&quot;);node.setAttribute(&quot;my_attrib&quot;, &quot;newVal&quot;); //括号中为“属性名+值” 4、removeAttribute()用于删除对应属性1node.removeAttribute(&apos;id&apos;) 页面范例展示涉及到的点： （1）查找、修改、获取、删除a链接的属性（这里为id）12345678910111213var link = document.querySelector(&apos;a&apos;)link &lt;a href=&quot;#&quot;&gt;wanxgiaoqin&lt;/a&gt;//可以创建 a链接的id属性值link.setAttribute(&apos;id&apos;,&apos;login&apos;)//以此类推，可以修改它的idlink.setAttribute(&apos;id&apos;,&apos;logout&apos;)//可以获取（或添加）它的idlink.getAttribute(&apos;id&apos;)//可以删除它的idlink.removeAttribute(&apos;id&apos;) 图： （2）创建一个样式放在页面上，如何操作？ 如：使用js让我们的页面上引入一个新的js，如jquery。可先在Bootstrap 中文网开源项目免费CDN加速服务上找一个jquery的地址 分析：用js引用一个jQuery，那么需要有一个scirpt的标签，用src来指向jQuery地址123456789101112131415161718192021//创建一个script标签var script = document.createElement(&apos;script&apos;)--&gt; undefinedscript &lt;script&gt;&lt;/script &gt; //设置元素的属性和值script .setAttribute(&apos;src&apos;,&apos;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&apos;)--&gt; undefined//验证一下script--&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; //通过.body.appendChild(script)将整个标签属性值放置到页面document.body.appendChild(script)--&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; //使用jquery$--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125;jQuery--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125; 5、innerHTML VS innerText（1）innerHTML假设获取了一个dom元素，想知道页面中的html元素是什么，或者放入很多东西（不通过创建dom节点的方式appendChild进去）页面的一些菜单栏设置，通过后台要数据，后台交还一个数组或json数据（包括菜单的所有信息），如何将菜单渲染到页面上？通过字符串操作遍历对象（或数组）去拼装html字符串，拼接后一次性将html放置在空的节点下，则页面看到了东西 几个操作：Ajax获取数据——数据到来之后拼接html字符串（遍历、相加）——通过innerHtml方法将包含菜单信息的html字符串放在页面上1234567891011121314151617//数组的值渲染做成一个菜单var navbarDate =[1,2,3]//写一个空字符串，去拼接字符串的htmlvar html =&apos; &apos;//遍历这个数组navbarDate.forEach(function(item)&#123; html +=&apos;&lt;li&gt;&apos;+item+&apos;&lt;/li&gt;&apos; //将数组三个数拼在一起&#125;)--&gt; undefinedhtml--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot; //无需换行，只需要拼接处html字符串即可//可将生成的html字符串放在.navbardocument.querySelector(&apos;.navbar&apos;).innnerHTML = html--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot; document.querySelector(&apos;.navbar&apos;)--&gt; &lt;div class=&quot;navbar&quot;&gt;...&lt;/div&gt; 图： （2）innerText看看所设置的元素标签下文本是什么（或设置它的文本） 注： 没有必要再创建什么元素标签，只需要设置一个空标签，然后设置它的innerText 续上面的例子：12345document.querySelector(&apos;.navbar&apos;).innerText //作html去执行--&gt;&quot;1 2 3 &quot; 假如代码是这样：1document.querySelector(&apos;.navbar&apos;).innerText = html //呈现给用户 则将展示文本设置在页面上，如图： 五、常见的使用方式1、修改样式可修改元素的style属性，修改结果直接反映到页面元素（不过，由于CSS权重的关系，虽然控制台修改dom节点上的style属性与页面上的一一对应，但如果权重比不够，修改的结果也不一定生效）如：123//dom元素的style属性上的 XXX与页面上一一对应document.querySelector(&apos;p&apos;).style.color = &apos;red&apos; //选中对应元素，和修改对象+属性document.querySelector(&apos;.box&apos;).style.backgroundColor = &apos;#ccc&apos; 2、获取样式 getComputedStyle不是获取元素的style属性，而是元素计算后的样式（包括其他地方做的设置、浏览器默认样式、继承样式等综合后的结果）。即123var node = document.querySelector(&apos;p&apos;)var color = window.getComputedStyle(node).color //可直接使用，它是处在win的一个全局变量属性console.log(color) 如在控制台想要获取页面dom元素的字体大小,如：12345getComputedStyle(document.querySelector(&apos;#hello&apos;)) //获取的是相对应的对象，通过对象获取对应的style对应的属性getComputedStyle(document.querySelector(&apos;#hello&apos;))[&apos;font-size&apos;]//即获取字体大小//等同于getComputedStyle(document.querySelector(&apos;#hello&apos;)).fontSize 3、class操作当使用样式操作时，涉及到一些样式的切换，可以直接去修改它的style，但这样比较细，且复杂。假设当我们在页面点击一个按钮时，整体发生一个很大的变化（包括字体大小、出现的边框、背景色、背景图片，甚至动画效果），如果都是用style来操作，或导致代码冗长难修改，我们可以将这些样式放在一个css的class里面，如active。正常情况下是没有这些class，当我们点击某个元素的时候，即鼠标放上去时，给这个元素添加一个class1234567var nodeBox = document.querySelector(&apos;.box&apos;)console.log( nodeBox.classList ) //通过选择元素nodeBox去看看classList里拥有哪些class， //即得到一个类数组对象.通过下标的方式获取classnodeBox.classList.add(&apos;active&apos;) //新增 classnodeBox.classList.remove(&apos;active&apos;) //删除 classnodeBox.classList.toggle(&apos;active&apos;) //新增/删除切换node.classList.contains(&apos;active&apos;) // 判断是否拥有 class 如图：class操作，不用担心class的数量有多少，无需担心同名、正则，只需要采用这种原生JS的API就能操作页面dom元素 4、页面宽高的计算（1）element.clientHeight VS element.clientWidth获取元素窗口的高度、宽度 （2）element.offsetHeight VS element.offsetWidth获取（包含边框+内边距+窗口整体）的高度、宽度获取两种的宽高，得到的结果看具体情况，有些时候是相同，有些时候是不同，如图： （3）element.scrollHeight元素滚动内容的总长度，也分实际情况假设页面上有一处包含内容的div块级，页面若为可滚动的，表示内容长度超出它容器的高度，而容器高度已为固定宽高，此时scrollHeight＞clientHeight若页面若无滚动条、父容器高度没有固定，则scrollHeight=clientHeight=offsetHeight （4）element.scrollTop获取元素滚动的高度，即滚动时滚动了一定的值1document.body.scrollTop （5）window.innerHeight窗口的高度1window.innerHeigh 实例操作：http://js.jirengu.com/fuser/1/edit?html,css 以下问题跟之后的解决懒加载有密切联系 问题1：如何去判断一个元素是否出现在窗口的视野中 问题2：如何判断页面滚动到底部 元素到顶点的值=滚动的值 元素滚动的距离+窗口的高度=这个元素到顶点的距离]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM元素</tag>
        <tag>DOM操作</tag>
        <tag>Element对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：08 setTimeout和任务队列]]></title>
    <url>%2F2018%2F08%2F17%2F34-08%20setTimeout%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言：之前写过一次被不小心删掉了，幸好思路和参考资料还在，所以赶快写下来。里面涉及了一点点dom事件的操作（但不影响学习）。 一、什么是定时器JS提供定时执行代码功能，叫做定时器（timer），主要由etTimeout()和setInterval()这两个函数来完成。setTimeout()和setInterval()是windows的两个全局属性。 二、setTimeout()setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。1var timerId = setTimeout(func|code, delay)//括号里代表（函数|代码字符串，延迟的时间毫秒数） 先写一个函数，在通过setTimeout调用函数，如：12345function f()&#123; console.log(2)&#125;setTimeout(f,1000) //表示在1s之后执行这个函数 或者1setTimeout(function ()&#123;console.log(2)&#125;,1000)//通过使用并调用执行该匿名函数 如： 使用setTimeout，连续几次之后，发现一个现象，返回了类似于有序的编号整数。这是由于setTimeout本身执行的时候，里面的函数返回值可认为返回的是一个定时器的id（或编号），当我们执行setTimeout，浏览器则会创建一个延时器（即一个对象），该延时器的返回则是一个编号。那么，这样的话，我们可以通过编号找到相对应的定时器续上面例子，如：12345678910var timer = setTimeout(function()&#123; console.log(&apos;wangxiaoqin&apos;)&#125;,10000)--&gt; undefinedtimer--&gt; 419 wangxiaoqin //若不做任何操作，1s后返回这个字符串clearTimeout(timer) //表示还未执行，该定时器就被取消操作clearTimeout(422) //表示提前取消编号为XXX的定时器 三、setInterval()用法与setTimeout一样，区别在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。即间隔执行任务。 1、如每隔1s执行一次1234var i = 1var timer = setInterval(function() &#123; console.log(i++);&#125;, 1000) 2、可用来做一个时钟：1234var i = 1var timer = setInterval(function()&#123; console.log(new Date());&#125;,1000) 四、clearTimeout()，clearInterval()setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。12345var id1 = setTimeout(f,1000);var id2 = setInterval(f,1000);clearTimeout(id1);clearInterval(id2); 五、从setTimeout(f,0)引发的关于JS运行环境的探究我们先看这样一个例子：123456setTimeout(function() &#123; console.log(1); &#125;,0); console.log(2)--&gt;2 1 //0s后，返回 为什么会先返回2，再返回1呢？（先留着疑问）123456789101112var isOk = true //第1：首先声明变量isOk，默认为truesetTimeout(function()&#123; console.log(1) isOk = false&#125;,1000) //异步回调：需要1秒之后，才能将 isOk 设为 false（1s后才执行，所以暂不执行） while(isOk)&#123; console.log(2) &#125; //第2：先进行while循环判断，isOk是否为true，如果是，那么就是返回console(2)的结果//第4：当过了1s后，代码执行，isOK = false，就会停止执行 是不是稍微有点明白？简单的例子里其实涉及到了JS运行中的很多方面，让我们详细看看 关键词：JS运行环境、事件循环、异步回调 1、单线程模型 这里截取阮一峰老师的JavaScript的教程中的单线程描述 单线程模型指的是，JavaScript只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。 JavaScript 只在一个线程上运行，不代表JavaScript引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。 JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。为了避免复杂性，JavaScript一开始就是单线程，已成为这门语言的核心特征，将来也不会改变。 2、线程涉及到单、多线程，这里截取李佳怡专栏文章中关于线程的描述 （1）定义浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器通常由以下常驻线程组成：GUI渲染线程，javascript引擎线程，浏览器事件触发线程，定时触发器线程，异步 http 请求线程。 （2）常驻线程 GUI 渲染线程：负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”。即 GUI 渲染线程与 JS 引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 javascript 引擎线程：也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。 浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待 JS 引擎处理。 定时触发器线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 javaScript 引擎是单线程的,如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。 异步 http 请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。 3、了解一下JS的V8运行环境主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。注：假设这段话暂时看不明白，暂时放掉，先了解下面的其他知识，完毕之后再回看这段话，就能明白。 说说图中的几个关键名词 （1）堆（heap）对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。 （2）栈（stack）函数调用形成了一个栈帧。 而通过使用js 调用栈（call stack）则能更清晰地了解单线程的执行过程。 js 调用栈（call stack）：函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数，这种数据结构的关键在于【后进先出】，即 LIFO（last-in，first-out）。 第一个例子：12345678910111213141516171819202122232425262728293031function multiply(a,b)&#123; return a*b&#125;function square(n)&#123; return multiply(n,n)&#125;function printSquare(n)&#123; var squared = square(n); console.log(squared);&#125;printSquare(4)//一个将两个数字相乘的函数multiply，一个调用了前者的平方函数square,//一个打印函数printSquare，它调用了square，然后将结果用console.log打印出来//然后最后我们调用了printSquare//运行//调用栈（callback），基本上是一个记录当前程序所在位置的数据结构。如果当前进入了某个函数，//这个函数就会被放在栈里面。如果当前离开了某个函数，这个函数就会被弹出栈外，这是栈所做的事。//如果你运行这个文件，将会有一个类似main的函数，指代文件本身，首先，把它放进栈中。//接着，我们从上到下查看了声明的函数，看到了最后是printSquare，知道了它被调用了，//那么我们把它推进栈里；它调用了square，所以也把square推进栈里；square也调用了mulitiply，//同样把mulitiply推进栈中，最后，我们得到了mulitiply的返回值//那么这之后，我们把multiply弹出栈，然后square也得到了返回值，再把square弹出栈，//最后到了printSquare，它调用了console.log，到这里已经没有返回值。我们到了函数的最后部分，//然后我们完成了。 第二个例子：123456789function f(b) &#123; var a = 12; return a + b + 35;&#125;function g(x) &#123; var m = 4; return f(m * x);&#125;g(21); 调用 g 函数 的时候，创建了第一个 堆( Heap ) 栈(stack) 帧 ，包含了 g 的参数和局部变量。当g调用f的时候，第二个堆栈帧就被创建、并置于第一个 堆栈帧 之上，包含了 f 的参数和局部变量。当 f 返回时，最上层的 堆栈帧 就出栈了（剩下g函数调用的堆栈帧）。当g返回的时候，栈就空了。 第三个例子:1234567function test() &#123; setTimeout(function() &#123; alert(1) &#125;,1000); alert(2);&#125;test(); 在执行函数 test 的时候，test先入栈，如果不给alert(1)加setTimeout，那么 alert(1)第2个入栈，最后是alert(2)。但现在给alert(1)加上 setTimeout后，alert(1)就被加入到了一个新的堆栈中等待，并1s后执行，因此实际的执行结果就是先 alert(2)，再 alert(1)。 （3）队列（queue）一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都有一个为了处理这个消息相关联的函数。 任务队列（消息队列）：任务（消息）队列是一个先进先出的队列，它里面存放着各种任务（消息） A、同步任务VS异步任务123456console.log(&apos;Hi&apos;)setTimeout(function()&#123; console.log(&apos;There&apos;)&#125;,1000)console.log(&apos;wangxiaoqin&apos;) 同步函数：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。如： 1console.log(&apos;Hi’); /*函数返回时，就看到了预期的效果：在控制台打印了一个字符串*/ 异步函数：即如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。如： 12setTimeout(fn, 1000);/*setTimeout是异步过程的发起函数，fn是回调函数*/ 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。 异步任务：主线程发起一个异步请求（即执行异步函数），相应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到任务（消息）队列，主线程通过事件循环过程去取任务（消息），然后执行一定的动作(调用回调函数)。看此图可视化描述： B、事件循环（Event loop）事件循环，指主线程重复从任务（消息）队列中取任务（消息）、执行的过程。取一个任务（消息）并执行的过程叫做一次循环。即:123while (queue.waitForMessage()) &#123; queue.processNextMessage();&#125; //如果当前没有任何消息queue.waitForMessage 会等待同步消息到达 事件循环中有事件两个字的原因：任务（消息）队列中的每条消息实际上都对应着一个事件——dom事件。如：1234var button = document.getElement(&apos;#btn&apos;);button.addEventListener(&apos;click&apos;,function(e) &#123; console.log();&#125;)； 从异步过程的角度看，addEventListener 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。那么添加的这个任务（消息）事实上就是任务注册异步任务时添加的回调函数。如果 一个异步函数没有回调，那么它就不会放到任务（消息）队列里。 总结：主线程在执行完当前循环中的所有代码后，就会到任务（消息）队列取出一条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，工作线程就没必要通知主线程，从而也没必要往消息队列放消息。如图： 了解一下工作线程（即异步 http 请求线程，即 Ajax 线程）是如何工作： 4、再来看setTimeout(f,0)所带来的零延迟与事件循环、任务队列的联系setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。 什么意思呢？ setTimeout的作用是，将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么不会立刻执行。这里则涉及到了零延迟。 零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。也就是说，setTimeout()只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout()指定的时间执行。123456setTimeout(function() &#123; console.log(1); &#125;,0); console.log(2)--&gt;2 1 //0s后，返回 现在我们知道为什么返回结果是2，1。因为只有在执行完主线程的所有代码之后，主线程空了，才会去任务队列中取任务执行回调函数，去执行回调函数。总结： setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到主线程把同步任务和”任务队列”现有的事件都处理完，才会得到执行。12345for(var i=0; i&lt;10; i++)&#123; setTimeout(function()&#123;console.log(i) &#125;, 1000)&#125; 执行结果为： 相当于for(var i=0; i&lt;10; i++)这个同步代码执行完之后，i的值变为10 。此时（1s后），执行回调函数，在同步任务中创建了10个定时器均在1s中之后执行，则返回了10 由此看来，在某种程度上，我们可以利用setTimeout(fn,0)的特性，修正浏览器的任务顺序。 参考、学习并感谢： 1.MDN：并发模型与事件循环 2.阮一峰JavaScript参考教程：异步操作概述 3.李佳怡专栏：【 js 基础 】 setTimeout(fn, 0)的作用]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步加载</tag>
        <tag>setTimeout</tag>
        <tag>任务队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：07 正则表达式]]></title>
    <url>%2F2018%2F08%2F17%2F33-07%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、意义用来判断用户输入是否符合某些特定规则，如检测判断用户所填信息是否为正确的手机号？正确的邮箱地址？以及在很多文本编辑器中，则更常用来检索、替换那些符合某个模式的文本。 二、定义JS中的特定对象，用来指定某些规则，对字符串进行匹配，是否符合规则，或者将其结果拿出来检测是否匹配该结果。 三、如何创建正则表达式通过内置对象RegExp去支持正则表达式。如果我们想匹配字符串中&lt;%xxx%&gt;两个百分号分割的字符串可以这么写。创建正则表达式对象有两种方法： 1、构造函数方法var reg=new RegExp(&#39;&lt;%[^%&gt;]+%&gt;&#39;,&#39;g&#39;); 注： 正则表达式使用new RegExp方法，传递的是字符串，而正则表达式里还有一些参数，表示匹配之后需要遵循什么规则 2.字面量方法var reg=/&lt;%[^%&gt;]%&gt;/g;注： g：global，全文搜索，不添加的话搜索到第一个结果停止搜索 i：ingore case，忽略大小写，默认大小写敏感 m：multiple lines，多行搜索 四、正则表达式如何表达123456789101112131415var reg = /hello/ig //可看成reg创建了一个正则表达式的对象--&gt; undefinedreg--&gt; /hello/gi //对象，是控制台对一个对象特有的表达//事实上，reg不是一个字符串，而是一个对象，如下typeof reg--&gt;&quot;object&quot;//如何表示一个字符串var str = &apos;/hello/ig&apos;--&gt; undefinedstr--&gt; &quot;/hello/ig&quot;typeof str--&gt; &quot;string&quot; 五、正则表达式的其他概念正则表达式让人望而却步的重要原因是转义字符太多，导致组合出来的也非常多 自我总结：正则表达式的匹配字符，在预设的字符串中通过正则的匹配字符进行检索，找出匹配该正则字符符合的参数/元素 1、元字符即正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符( [ { \ ^ $ | ) ? * + .比如我们返回一个带有元字符的正则表达式，需要：1234var reg = &apos;/\[h\]ello/ig&apos;--&gt; undefinedreg--&gt; &quot;/[h]ello/ig&quot; 不是每个元字符都有特定的意义，在不同组合中元字符有不同意义： 2、字符类 匹配正则表达式表示一个字符串，匹配的是一个字符串中相应的字符,我们可以使用元字符[ ]构建一个简单的类，用来匹配某一类，如匹配一个手机号：1234var reg =/[a-z]/ig/*或者*/var reg =/[abc01234]/ig//[a-z] 或[0-9]表示一个字符，- 表示一个范围和区间 匹配一个数字（或大小写字母）var reg =/[0-A9-c5-Bn-Z]/ig 3、取反 匹配var reg =/[^abc01234]/ig^表示只要不是中括号里的参数中的任何一个，则都被选中 4、预定义类 匹配即有没有符号代替数字或者非数字？如我们希望匹配一个可以是ab+数字+任意字符的字符串，就可以这样写了 /ab\d./var reg = /ab\d./ 图： 5、边界 匹配（1）区分一下^作为取反和边界匹配的差别 如：取反匹配的表示 1234//取反：匹配的是除了hello这个字符串之外的所有元素字符串，str.match(/[^hello]/g) --&gt; (47) [&quot; &quot;, &quot;w&quot;, &quot;r&quot;, &quot;d&quot;, &quot; &quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;&quot;, &quot; &quot;, &quot;j&quot;, &quot;i&quot;, &quot;r&quot;, &quot;n&quot;, &quot;g&quot;, &quot;u&quot;, &quot; &quot;, &quot;↵&quot;, &quot; &quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;x&quot;, &quot;i&quot;, &quot;a&quot;, &quot;q&quot;, &quot;i&quot;, &quot;n&quot;, &quot; &quot;, &quot;↵&quot;, &quot; &quot;, &quot;n&quot;, &quot;i&quot;, &quot;a&quot;, &quot;s&quot;, &quot;i&quot;, &quot;j&quot;, &quot;i&quot;] 如：边界匹配的表示 12345//边界：匹配的是以hello开头的字符串str.match(/^hello/g)--&gt; [&quot;hello&quot;]//即我们会匹配这个hello，不过要通过此来验证该hello是否位于字符串的开头 或1234var str = &apos;hello world hello 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie&apos;--&gt; undefinedstr.match(/^hello/g)--&gt; [&quot;hello&quot;] （2）匹配以XXX结尾12str.match(/hello$/g)--&gt; null //未匹配上 或者1234var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/hello3$/g)--&gt; [&quot;hello3&quot;] 或者123456var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/^hello\d/g)--&gt; [&quot;hello1&quot;]str.match(/hello\d/g)--&gt; (3) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello3&quot;] （3）单词边界 匹配1234var str = &apos;hello1 world hello2 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d\b/g)--&gt; (3) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello3&quot;] 或者1234var str = &apos;hello1 whello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d\b/g)--&gt; (4) [&quot;hello1&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;] //以此可看出单词边界的一个标准，前后均有空格或者以下情况 或者: -也为单词边界12345var str = &apos;hello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d/g)//注：这里右侧少了一个\b的边界匹配，返回如下：--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;] 或者：\t也为单词边界1234var str = &apos;\thello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d\b/g)--&gt;(5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;] \r 也为单词边界1234var str = &apos;\rhello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d\b/g)--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;] \n1234var str = &apos;\nhello1 hello9-Ahello5orld hello2 12-hello8-A345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie hello3&apos;--&gt; undefinedstr.match(/\bhello\d\b/g)--&gt; (5) [&quot;hello1&quot;, &quot;hello9&quot;, &quot;hello2&quot;, &quot;hello8&quot;, &quot;hello3&quot;] 如何判断一个字符串中是否有某个单词（元素/参数）？（相当于一个class中是否包含某元素？），假设：1var str = &apos;header3 clearfix active header-fixed&apos; 如如何求header这个单词？❌错误解法1234var str = &apos;header3 clearfix active header-fixed&apos;--&gt;undefinedstr.match(/\bheader\b/g)--&gt; [&quot;header&quot;] //系统默认第四个单词中的header ✅正确解法: | 可以匹配空白字符 本身也可以作为开头12345678var str = &apos;header3 clearfix active header-fixed&apos;--&gt;undefinedstr.match(/(^|\s)header($|\s)/g)--&gt; null //没有匹配到任何东西var str = &apos;header3 clearfix active header-fixed header&apos;undefinedstr.match(/(^|\s)header($|\s)/g)--&gt; [&quot; header&quot;] //从上一步，知道匹配到最后一个单词header 6、量词 匹配看一个字符串是否为url，该如何匹配1234567891011121314151617var str = &apos;http://wangxiaoqin.com&apos;--&gt; undefinedvar str2 = &apos;https://wangxiaoqin.com&apos;--&gt;undefinedstr.match(/https?:\/\/.+/g) //s 这个字母后加 ? 表示出现零次或一次（最多出现一次）不管有没有出现都行 //. 任意字符 + 多次--&gt; [&quot;http://wangxiaoqin.com&quot;]str2.match(/https?:\/\/.+/g)--&gt; [&quot;https://wangxiaoqin.com&quot;]//s出现多次，？无效 *有效 其他匹配字符var str3 = &apos;httpssssss://wangxiaoqin.com&apos;--&gt; undefinedstr3.match(/https?:\/\/.+/g)--&gt; nullstr3.match(/https*:\/\/.+/g)--&gt; [&quot;httpssssss://wangxiaoqin.com&quot;] 7、实践（1）实践1：如何更精准地判断url？ 固定元素 http://、https://、//12345678str.match(/^(https?:)?\/\/.+/) //(https?:)? ()里的表示可有可无--&gt; (2) [&quot;http://wangxiaoqin.com&quot;, &quot;http:&quot;, index: 0, input: &quot;http://wangxiaoqin.com&quot;, groups: undefined]str2.match(/^(https?:)?\/\/.+/)--&gt; (2) [&quot;https://wangxiaoqin.com&quot;, &quot;https:&quot;, index: 0, input: &quot;https://wangxiaoqin.com&quot;, groups: undefined]var str4 = &apos;//wangxiaoqin.com&apos;--&gt; undefinedstr4.match(/^(https?:)?\/\/.+/)--&gt; (2) [&quot;//wangxiaoqin.com&quot;, undefined, index: 0, input: &quot;//wangxiaoqin.com&quot;, groups: undefined] （2）实践2：如何判断用户的输入是手机号？ 假设：12345678var str1 =&apos;15011112222&apos;--&gt;undefinedvar str2 =&apos;aaadd15011112222&apos;--&gt; undefinedvar str3 =&apos;150111111222222555555&apos;--&gt; undefinedvar str4 =&apos;150aaadd11112222&apos;--&gt; undefined 分析：手机号只有11位、数字开头/结尾、 中国手机号以1开头12345//接上面代码继续str1.match(/1[3578]\d&#123;9&#125;/g)--&gt; [&quot;15011112222&quot;] // ✅准确无误地完全匹配上str2.match(/1[3578]\d&#123;9&#125;/g)--&gt; [&quot;15011112222&quot;] //虽然也返回正则所规定的，但只是部分匹配 如何接解决？分析：手机号前后都没东西，也就是要以数字1作为开头，结尾也要匹配数字字符1234567891011121314151617//接上面代码str2.match(/^1[3578]\d&#123;9&#125;/g)--&gt; nullstr1.match(/^1[3578]\d&#123;9&#125;/g)--&gt;[&quot;15011112222&quot;] ✅str3.match(/^1[3578]\d&#123;9&#125;/g)--&gt; [&quot;15011111122&quot;] //虽然也返回正则所规定的，也是以1为开头的，但没有结尾//$ 结尾匹配上该字符str1.match(/^1[3578]\d&#123;9&#125;$/g)--&gt; [&quot;15011112222&quot;]str2.match(/^1[3578]\d&#123;9&#125;$/g)--&gt; nullstr3.match(/^1[3578]\d&#123;9&#125;$/g)--&gt; nullstr4.match(/^1[3578]\d&#123;9&#125;$/g)--&gt; null 图： 8、如何具象使用正则？（1）先利用字符串的搜索去把正则给应用起来12var str = &apos;hello world 12345678 \t \r jirengu \n wangxiaoqin \n nihaoshijie&apos;--&gt; undefined 结果如： （2）接着回忆，利用字符串的搜索功能搜出某个字的起始下标（所传递的是一个字符串）12str.search(&apos;world&apos;) --&gt; 6 //这里可看出str输出的字符串，空格跳过 这里，可以使用正则表达式进行检索123str.match(&apos;world&apos;)str.match(/\d/)//只匹配到一次，1，拿到就结束 如图：123//匹配所有的数字字符str.match(/\d/g)--&gt;(8) [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;] 如图： 六、贪婪模式与非贪婪模式1、贪婪模式在贪婪（默认）模式下，正则引擎【尽可能多】地重复匹配字符先看这个代码：1234var str = &apos;a &quot;witch&quot; and her &quot;boom&quot; is one&apos;--&gt; undefinedstr.match(/&quot;.*&quot;/g)--&gt; [&quot;&quot;witch&quot; and her &quot;boom&quot;&quot;] 按照我们的逻辑来看，本来我们想要匹配的是&quot;witch&quot;和&quot;boom&quot;两个字符串，但是结果却出乎我们的意料，是&quot;witch&quot;and her &quot;boom&quot;这样一个整体的字符串。这样的字符串则是因为正则表达式的贪婪模式起的效果。 正则引擎演示如下： 正则的贪婪模式采用了查找算法的形式进行检索匹配字符。正则引擎从字符串的第0位开始检索：（在此为若愚老师打call，他讲正则引擎工作讲得真的很不错😂） 2、非贪婪模式与贪婪模式相反，可通过在代表数量的标示符后放置?（表示尽可能地少匹配） 来开启非贪婪模式。如：?、+?甚至是??非贪婪模式下，正则引擎尽可能少地重复匹配字符演示如下：1234var str = &apos;a &quot;witch&quot; and her &quot;boom&quot; is one&apos;--&gt; undefinedstr.match(/&quot;.*?&quot;/g) --&gt; (2) [&quot;&quot;witch&quot;&quot;, &quot;&quot;boom&quot;&quot;] 图： 七、分组使用量词的时候匹配多个字符，而不是像上面例子只是匹配一个首先，假设写成 hunger{10}的话匹配的是hunge＋r出现10次1/hunger&#123;10&#125;/ //hunge＋r出现10次 把hunger作为一个整体呢？使用()就可以达到此目的，我们称为分组1/(hugner)&#123;10&#125;/ 字符或|在正则引擎中是怎么处理的呢1234567891011121314var str = &apos;helloworld&apos;--&gt; undefinedstr.match(/hello|sworld/) \ //有个疑问，是(hello)|(sworld),还是hell(o|s)world //匹配返回的有可能是hello或者hells--&gt;[&quot;hello&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined]验证之后，等同于str.match(/(hello)|(sworld)/)--&gt; (3) [&quot;hello&quot;, &quot;hello&quot;, undefined, index: 0, input: &quot;helloworld&quot;, groups: undefined]str.match(/hello|sworld/g)--&gt; [&quot;hello&quot;]//而事实上，匹配helloworld这个字符串，字符 | 则需要将左右两边相邻的字母用()包裹起来 str.match(/hell(o|s)world/g)--&gt; [&quot;helloworld&quot;] 所以1(hello|world)&#123;20&#125; //表示hello或者world都匹配出现20次 分组的作用1234567str--&gt; &quot;helloworld&quot;str.match(/(he)l(lo)/)--&gt; (3) [&quot;hello&quot;, &quot;he&quot;, &quot;lo&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined]VSstr.match(/hello/)--&gt;[&quot;hello&quot;, index: 0, input: &quot;helloworld&quot;, groups: undefined] 分组的价值实践：（同时运用了非贪婪模式的 ？让返回完全匹配 ）123456var str =&apos;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&apos;--&gt; undefinedstr.match(/href=&quot;(https?:\/\/.+?)&quot;/)--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;, &quot;http://wangxiaoqin.com&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;, groups: undefined]str.match(/href=&quot;(https?:\/\/.+?)&quot;/)[1]--&gt;&quot;http://wangxiaoqin.com&quot; 非贪婪模式 VS贪婪模式 1234567891011var str =&apos;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&apos;--&gt; undefinedstr.match(/href=&quot;(https?:\/\/.+?)&quot;/)--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;, &quot;http://wangxiaoqin.com&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, groups: undefined]str.match(/href=&quot;(https?:\/\/.+?)&quot;/g)--&gt; [&quot;href=&quot;http://wangxiaoqin.com&quot;&quot;]str.match(/href=&quot;(https?:\/\/.+)&quot;/)--&gt; (2) [&quot;href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, &quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;, index: 3, input: &quot;&lt;a href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;, groups: undefined]str.match(/href=&quot;(https?:\/\/.+)&quot;/g)--&gt; [&quot;href=&quot;http://wangxiaoqin.com&quot;&gt;&quot;hello&quot;&quot;] 八、前瞻12345var str=hunger(?=Byron)str.exec(&apos;goodByron123&apos;); //[&apos;good&apos;]str.exec(&apos;goodCasper123&apos;); //nullstr.exec(&apos;goodCasper123&apos;);//null 九、正则表达式的相关用法1、reg.test(str)测试字符串参数中是否存正则表达式模式，如果存在则返回true，否则返回false123456var reg = /\d+\.\d&#123;1,2&#125;$/g;reg.test(&apos;123.45&apos;); //truereg.test(&apos;0.2&apos;); //truereg.test(&apos;a.34&apos;); //falsereg.test(&apos;34.5678&apos;); //false 实践价值：测试一个手机号是否存在？1234var reg = /^1[3578]\d&#123;9&#125;$/g //正则的手机号检索标准--&gt; undefinedreg.test(&apos;18320158956&apos;)--&gt; true 2、reg.exec(str)用于正则表达式模式在字符串中运行查找，持续去运行。如果exec()找到了匹配的文本，则返回一个结果数组,否则返回 null如：1234567891011121314var str =&apos;123 456 789&apos;var reg =/\d&#123;3&#125;/ //未添加g，则匹配一次就结束reg.exec(str)[&quot;123&quot;, index: 0, input: &quot;123 456 789&quot;, groups: undefined]/* 进行g的全局匹配 */var str =&apos;123 456 789&apos;var reg =/\d&#123;3&#125;/greg.exec(str)--&gt; [&quot;123&quot;, index: 0, input: &quot;123 456 789&quot;, groups: undefined]reg.exec(str)--&gt; [&quot;456&quot;, index: 4, input: &quot;123 456 789&quot;, groups: undefined]reg.exec(str)--&gt; [&quot;789&quot;, index: 8, input: &quot;123 456 789&quot;, groups: undefined] 实践价值：如找出相对应的邮箱，手机号码等12345678910//代码如下： var str =&apos;123 456 789&apos; var reg =/\d&#123;3&#125;/gwhile(result=reg.exec(str))&#123; console.log(result[0])&#125;--&gt; 123 456 789 3、str.split(reg)使用split方法把字符串分割为字符数组123456789101112var str = &apos;h e llo wan g xi ao qi n&apos;undefined//以前str.split(&apos;&apos;)--&gt; (29) [&quot;h&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;e&quot;, &quot; &quot;, &quot; &quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot; &quot;, &quot;g&quot;, &quot; &quot;, &quot;x&quot;, &quot;i&quot;, &quot; &quot;, &quot;a&quot;, &quot;o&quot;, &quot; &quot;, &quot;q&quot;, &quot;i&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;n&quot;]str.split(&apos; &apos;)--&gt; (14) [&quot;h&quot;, &quot;&quot;, &quot;&quot;, &quot;e&quot;, &quot;&quot;, &quot;llo&quot;, &quot;wan&quot;, &quot;g&quot;, &quot;xi&quot;, &quot;ao&quot;, &quot;qi&quot;, &quot;&quot;, &quot;&quot;, &quot;n&quot;]//现在：用正则表达式做一个检索分类str.split(/\s/)--&gt; (14) [&quot;h&quot;, &quot;&quot;, &quot;&quot;, &quot;e&quot;, &quot;&quot;, &quot;llo&quot;, &quot;wan&quot;, &quot;g&quot;, &quot;xi&quot;, &quot;ao&quot;, &quot;qi&quot;, &quot;&quot;, &quot;&quot;, &quot;n&quot;]str.split(/\s*/)--&gt; (16) [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;x&quot;, &quot;i&quot;, &quot;a&quot;, &quot;o&quot;, &quot;q&quot;, &quot;i&quot;, &quot;n&quot;]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
        <tag>正则匹配</tag>
        <tag>贪婪模式和非贪婪模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：06-5 Math/Math]]></title>
    <url>%2F2018%2F08%2F17%2F32-06.5%20Math%3AMath%2F</url>
    <content type="text"><![CDATA[一、字符串1、单双引号（实际无区别）特别场景下，单引号更严格。如：&quot;It&#39;s a long journey&quot; 2、转义字符就是在内部不能转化的单、双引号前面加上反斜杠，用来转义，成为一个完整的字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var str = &apos;he\&apos;llo&apos;--&gt; undefinedstr--&gt; &quot;he&apos;llo&quot;//展示长度str.length--&gt; 6//展示斜杠var str = &quot;\\ccc&quot;--&gt; undefinedstr--&gt; &quot;\ccc&quot;//展示换行//例子1：var longString = &quot;Long \ //注：注意不要多出空格，会报错long \long \string&quot;;--&gt; undefinedlongString--&gt; &quot;Long long long string&quot;----------------------------------var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;;--&gt; undefinedlongString--&gt; &quot;Long long long string&quot;//例子2：var a = &apos;hel \\lo&apos;--&gt; undefineda&quot;hel lo&quot;---------------------------------var a = &apos;hel\\lo&apos;--&gt; undefineda--&gt; &quot;hello&quot;//例子3：ES6用法`helloworld`--&gt; &quot; hello world &quot; 3、字符串常见用法（1）长度计算、连接1234567891011121314151617181920212223//计算var str = &quot;hello&quot;--&gt; undefinedstr.length--&gt; 5str[0]--&gt; &quot;h&quot;str[str.length - 1]--&gt; &quot;o&quot;str.charAt(0) //截取字符串的首字母--&gt; &quot;h&quot;str.charCodeAt(0) //获取Ascii 码--&gt; 104//连接var str2 = &quot;world&quot; --&gt; undefinedvar str1 = &quot;hello &quot; //在测试时，发现字符串里空格，字符串内部相应地会出现间隙--&gt; undefinedvar str3 = str1 + str2--&gt; undefinedstr3--&gt; &quot;hello world&quot; （2）字符串截取123456var str = &quot;hello world&quot;--&gt; undefinedstr.substr(1, 3) --&gt; &quot;ell&quot; //第一个是开始位置， 第二个是长度 ellstr.substring(1, 3)--&gt; &quot;el&quot; //第一个是开始位置，第二个是结束位置，长度为第二个－第一个 el （3）字符串查找123456789101112var str = &quot;hello my world&quot;;--&gt; undefinedstr.search(&apos;my&apos;)--&gt; 6str.replace(&apos;my&apos;, &apos;your&apos;)--&gt; &quot;hello your world&quot;str.match(&apos;my&apos;)--&gt; [&quot;my&quot;, index: 6, input: &quot;hello my world&quot;, groups: undefined]//查找位数:ES6中的用法str.indexOf(&apos;el&apos;)--&gt; 1 （4）字符串的大小写123456var str = &quot;Hello&quot;;--&gt; undefinedstr.toUpperCase()--&gt; &quot;HELLO&quot; str.toLowerCase()--&gt; &quot;hello&quot; （5）字符串的拼接123456var color = &apos;red&apos;--&gt; undefinedstr = &apos;衣服的颜色是&apos; + color--&gt; &quot;衣服的颜色是red&quot;str2 = `今天的颜色很$&#123;color&#125;`--&gt; &quot;今天的颜色很red&quot; 二、Math（JS内置对象）1、概念看了一下概念，看懂了不懂怎么说，就是用Math提供一种数学计算方法：如图： 2、Math的常用属性1234567891011Math.E // 2.718281828459045Math.LN2 // 0.6931471805599453Math.LN10 // 2.302585092994046Math.LOG2E // 1.4426950408889634Math.LOG10E // 0.4342944819032518Math.PI // 3.141592653589793Math.SQRT1_2 // 0.7071067811865476Math.SQRT2 // 1.4142135623730951如：Math.PI*3*3--&gt; 28.274333882308138 3.日常使用Math建议理解透每个属性用法，自己做题默念用法规则，在控制台验证自己的结果 （1）round 用于四舍五入语法：Math.round() 对于负值的运算结果与正值不太一样，主要集中于.5的处理上如：1234Math.round(-4.6) //-5Math.round(-4.5) //-4Math.round(-1.5) //-1Math.round(-0.5) //-0 而正值1234Math.round(0.5) //1Math.round(1.5) //2Math.round(4.5) //5Math.round(4.8) //5 （2）abs 返回参数值的绝对值1Math.abs() （3）max/min 返回最大参数/最小参数12Math.max()Math.min() 一些例子：123Math.max(4, -1, &apos;s&apos;) //NaNMath.max.apply(null,[-2,-9,2,6]) //6Math.min.apply(null,[-2,-9,2,6]) // -9 （4）floor/ceilA、floor 返回小于参数值的最大整数 不等于 取整如：123456Math.floor(3.8) //3Math.floor(3.5) //3Math.floor(3.2) // 3Math.floor(-3.2) // -4 Math.floor(-3.5) //-4Math.floor(-3.8) //-4 B、ceil 返回大于参数值的最小整数123456Math.ceil(3.8) //4Math.ceil(3.5) //4Math.ceil(3.2) // 4Math.ceil(-3.2) //-3 Math.ceil(-3.5) //-3Math.ceil(-3.8) //-3 （3）pow/sqrt pow 用于求平方,如： 12Math.pow(2, 2) // 4Math.pow(2, 3) // 8 sqrt 用于求参数的平方根（即参数包含在这种√￣中的值），如： 12Math.sqrt(4) // 2 相当于√4￣=2Math.sqrt(-4) // NaN （4）log/exp log 用于返回以e为底的自然对数值 普及一下对数函数：如果ax=N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。Math.log(Math.E)// 1 exp 用于返回常数e的参数次方12Math.exp(1) // 2.718281828459045 //10÷eMath.exp(3) // 20.085536923187668 【重点】（5）random 用于求随机数，返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。如你输入Math.random()，任何时候都会生成按照以上规则组成的随机数 实践0：返回给定范围内的随机数123function getRandomArbitrary(min, max) &#123; return Math.random() * (max - min) + min;&#125; 实践1： 均为随机 获取一个0-100的整数 获取一个0-5之间的整数 获取一个1-6之间的整数 获取一个10-20之间的整数 实践2: 获取一个随机的字符串12345678910111213function randomStr(len)&#123; var str = &apos;&apos; //第3步 var dict = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&apos; //第4步 for(var i= 0; i&lt;len; i++)&#123; //用来执行次数 var index = Math.floor(Math.random()*dict.length)//通过Math.floor来取整 //用来获取随机长度的整数值 str += dict[index] &#125; //第5步 return str//第6步 &#125;//第1步：定义一个随机字符串长度，空var str = randomStr(32)console.log(str) //第2步：定义str具体值（注：这个随机字符串包括大小写字母数字等等） 图：可以在控制台算一下所声明的 dict随机字符串有多少位123456var dict = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&apos;--&gt; undefineddict.length--&gt; 63//基本需要的是下标为0-62的随机参数 实践3： 获取一个随机IP 写一个函数，生成一个随机IP地址，一个合法的IP地址0.0.0.0~255.255.255.255 123456789101112131415161718192021222324252627282930function getRandIP()&#123; var ip = [] for(var i = 0;i&lt;4;i++)&#123; //i&lt;4是由于下标位数 ip = ip+Math.floor(Math.random()*256)+&quot;.&quot; &#125;return ip &#125;var ip = getRandIP()console.log(ip) // 输出ip地址或function getRandIP()&#123; var temp = 0; ip = &apos;&apos;; for (var i = 0; i &lt; 4; i++) &#123; temp = parseInt(Math.random() * 256); if (i &lt; 3) &#123; ip = ip + temp + &apos;.&apos;; &#125; else &#123; ip = ip + temp &#125; &#125; return ip;&#125;var ip = getRandIP()console.log(ip) //输出ip地址 实践4： 获取一个随机颜色字符串 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~#ffffff1234567891011function getRandColor()&#123; var str =&apos;#&apos; var dict =&apos;0123456789abcdef&apos; for(var i= 1;i&lt;6 ;i++)&#123; var index = Math.floor(Math.random()*dict.length) str += dict[index] //str = str+dict[index]&#125; return str&#125;var color = getRandColor()console.log(color) 三、Date（JS的内置对象）1、定义：是JavaScript提供日期和时间的操作接口 2、Date的几个静态方法：（1）Date.now() ——获取时间毫秒数如：12Date.now()--&gt; 1528904474005 //根据实际时间得出的毫秒数也不一样 now方法返回的毫秒数，具体指的是距离1970年1月1日00：00：00的毫秒数或 Date.parse()注：如果解析失败，返回NaN如：12Date.parse(2011-11-11)--&gt; 599616000000 （2）new Date()A、通过new date方法，获取一个时间对象12new Date(2020,8,14) --&gt; Mon Sep 14 2020 00:00:00 GMT+0800 (CST) 通过字符串所生成的时间对象（且没有传递时分秒），获取的则是日期，而对于处于东八区的我们则是8点1234str =&apos;2017-08-01&apos;--&gt; &quot;2017-08-01&quot;new Date(str)--&gt; Tue Aug 01 2017 08:00:00 GMT+0800 (CST) 若1234str =&apos;2017-08-01 00:00:00&apos;--&gt; &quot;2017-08-01 00:00:00&quot;new Date(str)--&gt; Tue Aug 01 2017 00:00:00 GMT+0800 (CST) B、声明一个变量d，d则是一个日期对象，返回的则是一个字符串，如：123456var d = new Date()--&gt; undefinedd--&gt; Thu Jun 14 2018 00:08:31 GMT+0800 (CST) //字符串，实际时间有所不同typeof d--&gt; &quot;object&quot; //验证为一个对象 通过变量d，一个对象，获取一些必要信息，如：12345678910111213141516d.getDate()--&gt; 14d.getFullYear()--&gt; 2018d.getMonth()--&gt; 5d.getDay()--&gt; 4d.getHours()--&gt; 0d.getMinutes()--&gt; 8d.getSeconds()--&gt; 31d.getMilliseconds()--&gt; 438 3、实践：（1）实践1：100天前是几月几号？ 注：当前时间为：2018.6.19 周二 时间大概：15：24：35（时间误差不到3-5mins）12345678var curTime = Date.now() //计算当前时间的时间毫秒数--&gt; undefinednew Date(curTime-100*24*60*60*1000)--&gt; Sun Mar 11 2018 15:23:02 GMT+0800 (中国标准时间) //获取100天以前的具体日期new Date(curTime-100*24*60*60*1000).getMonth()--&gt; 2new Date(curTime-100*24*60*60*1000).getDate()--&gt; 11 （2）实践2：复杂函数的执行时间如何计算？123456var start = Date.now()--&gt; undefinedvar end =Date.now()--&gt; undefinedend - start--&gt; 5196 【重点】（3）实践3： 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串（即输出打印出时间戳）。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串： 刚刚（ t 距当前时间不到1分钟时间间隔） 3分钟前 (t距当前时间大于等于1分钟，小于1小时) 8小时前 (t 距离当前时间大于等于1小时，小于24小时) 3天前 (t 距离当前时间大于等于24小时，小于30天) 2个月前 (t 距离当前时间大于等于30天小于12个月) 8年前 (t 距离当前时间大于等于12个月) 12345678910111213141516171819202122232425262728function friendlyDate (time) &#123; var t = new Date().getTime(); var d = (t-time)/1000; switch(true)&#123; case d &lt; 60: console.log(&apos;刚刚&apos;); break; case d &gt;=60 &amp;&amp; d&lt;60*60: console.log(Math.floor(d/60)+&apos;分钟前&apos;); break; case d &gt;=3600 &amp;&amp; d&lt;3600*24: console.log(Math.floor(d/3600)+&quot;小时前&quot;); break; case d &gt;=3600*24 &amp;&amp; d&lt;3600*24*30: console.log(Math.floor(d/3600/24)+&quot;天前&quot;); break; case d &gt;=3600*24*30 &amp;&amp; d&lt;3600*24*30*12: console.log(Math.floor(d/3600/24/30)+&quot;月前&quot;); break; default: console.log(Math.floor(d/3600/24/30/12)+&quot;年前&quot;); break; &#125;&#125;var str = friendlyDate(Date.now()-1000*60);console.log(str);var str2 = friendlyDate(&apos;1483941245793&apos;);console.log(str2);]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Math</tag>
        <tag>字符串常见用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：06-4 ES5 数组拓展]]></title>
    <url>%2F2018%2F08%2F17%2F31-06.4%20ES5%20%E6%95%B0%E7%BB%84%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[一、针对Array对象做了大幅拓展1、Array.isArray(obj)用于判断一个变量（或对象）是否为数组，如：12345Array.isArray([])// true Array.isArray(&#123;&#125;)// false 2、.indexOf(element) / .lastIndexOf(element)用于如何判断在一个数组中找到所看到的一个值、数字，或变量是否存在（1）ES3的做法：12345678910111213 var arr = [3, 4, &apos;hello&apos; ,&apos;wangxiaoqin&apos;] // undefined function hasWord(arr,item)&#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === item) return true &#125; return false &#125; // undefined hasWord(arr,&apos;wangxiaoqin&apos;) // true hasWord(arr,&apos;helloo&apos;) // false （2）ES5的拓展做法123456var arr = [3, 4, &apos;hello&apos; ,&apos;wangxiaoqin&apos;] // undefinedarr.indexOf(&apos;wangxiaoqin&apos;) // 3 arr.indexOf(&apos;wanxiaoqin&apos;) // -1 //写了一个不存在的，直接输出-1 总结：那么，依此可以得出，-1也可以作为判断某对象是否存在于该数组 3、.forEach(element,index,arrary)遍历一个数组，可以使用for循环；也可以数组自带的.forEach1234567891011var arr = [3, 4, &apos;hello&apos; ,&apos;wangxiaoqin&apos;] // undefinedarr --&gt; (4) [3, 4, &quot;hello&quot;, &quot;wangxiaoqin&quot;] arr.forEach(function()&#123; console.log(arguments) &#125;) --&gt;Arguments(3) [3, 0, Array(4), Arguments(3) [4, 1, Array(4), Arguments(3) [&quot;hello&quot;, 2, Array(4), Arguments(3) [&quot;wangxiaoqin&quot;, 3, Array(4), 图：接着,可以使用.forEach遍历该数组12345678arr.forEach(function(value,index)&#123; //value指数组中的元素，index指数组中的下标 console.log(&apos;&apos;+value+value) &#125;) --&gt;33 44 hellohello wangxiaoqinwangxiaoqin //undefined 4、.every(function(element, index, array))用于满足该数组中函数设定的某个条件，函数返回的是一个布尔值满足条件： every是所有函数的每个回调函数都返回true的时候才会返回true，当遇到false的时候终止执行，返回false some函数是“存在”有一个回调函数返回true的时候终止执行并返回true，否则返回false如：1234[3,4,-1,0,5].every(function(val)&#123; return val&gt;0?true:false //使用三目运算符 === if...else &#125;) // false .some(function(element,index,array))只要有一个符合，那就返回true；反之，则.. 5、.map(function(element))对数组中每一元素进行处理，函数返回值组成一个新数组返回，新数组索引结构和原数组一致，原数组保持不变。123456var arr2 = [1, 2, 3, 4, 5, 6].map(function(val)&#123; return val*val &#125;) // undefinedarr2 // (6) [1, 4, 9, 16, 25, 36] 6、12345数组的过滤。**注：** 产生新数组，原数组保持不变,如：var arr=[3, 5, 6, -1, -2, -3]// undefinedarr.filter(function(val){ return val&gt;0 })// (3) [3, 5, 6] //产生新数组arr// (6) [3, 5, 6, -1, -2, -3] //原数组不变 / 所以，我们需要为新数组赋新变量 /var arr2 = arr.filter(function(val){ return val&gt;0 })// undefinedarr2// (3) [3, 5, 6] / 如需过滤出里面的负数 /var arr3 = arr.filter(function(val){ return val &lt;0 })// undefinedarr3// (3) [-1, -2, -3]1再如： var students = [ { name:’ad’, age:10 }, { name:’bb’, age:20 }, { name:’ca’, age:8 }, { name:’ce’, age:5 },] / 假设过滤出数组里年纪大于18岁的 /var age18 = students.filter(function(students){ return students.age &gt; 18 }) console.log(age18) --&gt; [[object Object] { age: 20, name: &quot;bb&quot;hui } ] / 假设过滤出数组里姓名里带有“c” / var namehasc = students.filter(function(students){ return students.name.indexOf(‘c’)&gt;-1 }) console.log(namehasc) –&gt;[[object Object] { age: 8, name: “ca” }, [object Object] { age: 5, name: “ce” }]1234以此，可以通过过滤可进行排序、查找、单独的处理### 7、`.reduce(function(v1, v2), value)`两元素（或参数）执行操作，数组元素返回组合成一个值，遍历数组，继续和数组中 其他元素组合，最终得出结果。代码如下： var arr = [3, 4, 5]–&gt; undefinedarr.reduce(function(v1,v2){ return v1 + v2 }) –&gt; 12 //7+5arr.reduce(function(v1,v2){ return v1 v2 })–&gt; 60 //125 / 使用初始值 .reduce(function(v1, v2), value) value为初始值 /arr.reduce(function(v1,v2){ return v1 + v2 },100) –&gt; 112 //100(v1)+3(v2)+4+5//103(v1)+4(v2)+5 以此类推12345678# 二、学习### 1、手写reduce功能A、先补充一些基本JS知识，假设：想要克隆一个与`arr`完全一样的`arr2`，但二者互不相干，如何处理?通过使用concat方法，一个数组arr拼接另一个数组，然后得到一个新的数组`arr2`。即通过concat获得一个新数组，拼接的原数组保持不变。实现一个**深拷贝**。**注：[ ]空数组也是一个数组** arr = [1,2,3]// [1, 2, 3]arr2 = arr.concat([])// [1, 2, 3]arr2// [1, 2, 3] / 测试一下是否二者有关联 / arr2[0] = 100// 100 arr// [1, 2, 3]arr2// [100, 2, 3]12B、手写一个reduce功能 function reduce(arr, fn, initValue){ var arr2 = arr //===[3, 4, 5, 6] while(arr2.length &gt; 1) }//第2：如何是实现reduce？计划通过处理arr2 = [3, 4, 5, 6]的v1,v2, 通过function（v1,v2）{return v1+v2}处理，依次循环得出结果 var arr = [3, 4, 5, 6] var result = reduce(arr, function(v1,v2){ return v1+v2 //第1：通过此遍历arr数组 },10)1取消初始值去做： function reduce(arr, fn){ var arr2 = arr //===[3, 4, 5, 6] while(arr2.length &gt; 1){ console.log(arr2) arr2.splice(0,2,fn(arr2[0],arr2[1])) } return arr2[0] } //第3：while(arr2.length &gt; 1) 相当于设置一个条件：当这个数组有两个以上的值时，//第4：arr2 === arr用fn函数进行处理，v1+v2相加替换成一个结果， 使用splice(位数，个数,替换的结果),依次类推得出arr2 === arr的结果 var arr = [3, 4, 5, 6] //[7,5,6] //[12,6] //[18] var result = reduce(arr, function(v1,v2){ return v1+v2 }) console.log(result) //输出结果 --&gt;[3, 4, 5, 6] [7, 5, 6] [12, 6] 18 12345678图：![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94608a6e?w=600&amp;h=375&amp;f=jpeg&amp;s=31303)但是，这里有个问题，就是`arr2===arr`，却没有实现二者互不相关。如何处理？如图：![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a9487c395?w=600&amp;h=250&amp;f=jpeg&amp;s=22572)可以通过: 原始数组`.concat([])`组合成一个新数组，且原数组与之无关。如图：![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94983a00?w=600&amp;h=288&amp;f=jpeg&amp;s=26717)添加初始值之后，该如何做呢？ function reduce(arr, fn,initValue){ var arr2 = arr.concat([]) //===[3, 4, 5, 6] if(initValue !== undefined){ //这里注意 === 会出现报错 arr2.unshift(initValue) }//不等于undefined，表示用户传递了这个initValue参数 while(arr2.length &gt; 1){ console.log(arr2) arr2.splice(0,2,fn(arr2[0],arr2[1])) } return arr2[0] } var arr = [3, 4, 5, 6] var result = reduce(arr, function(v1,v2){ return v1 + v2 },10) console.log(result) //输出值： –&gt; [10, 3, 4, 5, 6] [13, 4, 5, 6] [17, 5, 6] [22, 6] 28123图：![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94b9cf5e?w=600&amp;h=348&amp;f=jpeg&amp;s=30881)或者减少代码量，采用三目运算符的方法来设置初始值： function reduce(arr, fn,initValue){ var arr2 = (initValue !== undefined?[]:[initValue]).concat(arr) while(arr2.length &gt; 1){ console.log(arr2) arr2.splice(0,2,fn(arr2[0],arr2[1])) } return arr2[0] } var arr = [3, 4, 5, 6] var result = reduce(arr, function(v1,v2){ return v1 + v2 },10) console.log(result) //输出值 –&gt; [3, 4, 5, 6] [7, 5, 6] [12, 6] 181234567图：![image](https://user-gold-cdn.xitu.io/2018/8/15/1653d54a94b5b19f?w=600&amp;h=283&amp;f=jpeg&amp;s=23154)### 2、将一个数组拍平对一个无限次嵌套的数组进行拍平，如何处理？例子1：这道题也可以作为一个初级JS的思考，每次不会做的话，先从这道题的基本思考方式来看 var arr = [3, [‘4,5’,7,[1]], [2,10] ] function flat(){ } //重点解决这一块的逻辑，即最终返回一个新的数组 var arr2 = flat(arr) console.log(arr2) var arr = [3, [‘4,5’,7,[1]], [2,10] ] function flat(arr){ var arr2 = [] arr.forEach(function(val){ if(Array.isArray(val)){ arr2 =arr2.concat(flat(val)) }else{ arr2.push(val) } }) return arr2//不是数组的话就返回 } / flat(arr)就是将一个数组拍平，变成一个普通数组，对arr里进行判断， 如果不是个数组（如3），则放在 var arr2 = []里的空数组里， 如果是数组的，即 [‘4,5’,7,[1]]，则把其放在这个arr.forEach(function(val){})数组里执行，则 重点解决函数这一块的逻辑 :1、定义一个要返回的数组arr22、遍历原始数组arr,且用函数遍历arr的每一项2.1 if判断是否为数组，采用Array.isArray判断。 若是数组，要处理嵌套数组，再次调用函数，将嵌套函数“拍平”，用递归法一一验证，最后得出结果2.2 else如果不是数组，直接push在arr=[]里 / var arr2 = flat(arr) console.log(arr2) //输出结果–&gt; [3, “4,5”, 7, 1, 2, 10]123例子2：实现一个flatten函数，将一个嵌套多层的数组arry（数组）（嵌套可以是任何层数）转换成只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。如： flatten（[1,[2],[3,[[4]]]）=&gt; [1,2,3,4]1234567891011121314151617181920212223242526272829```var arr = [3,[2,-4,[5,7]],-3,[&apos;aa&apos;,[[&apos;bb&apos;]]]] var arr2 = flatten2(arr) console.log(arr2) /* 方法1： */ function flatten(arr)&#123; var newArr = [] function _flat(arr)&#123; arr.forEach(val=&gt;&#123; //对数组的每一项进行一个遍历 val=&gt;，为匿名函数 if(Array.isArray(val))&#123; _flat(val) &#125;else&#123; newArr.push(val) &#125; &#125;) &#125; _flat(arr) return newArr &#125; /* 方法2： */ function flatten2(arr)&#123; return arr.reduce(function(initArr,currentArr)&#123; return initArr.concat(Array.isArray(currentArr)?flatten2(currentArr):currentArr) &#125;,[]) &#125; /*不是数组的话，就concat；如果是数组，则通过再次调用flatten2(Arr)拍平当前数组flatten2(currentArr) */]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES5</tag>
        <tag>数组拓展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：06-3 [Array]]]></title>
    <url>%2F2018%2F08%2F17%2F30-06.3%20%5BArray%5D%2F</url>
    <content type="text"><![CDATA[一、数组基本使用1、如何去声明一个数组1var arr = [ 值 ] 值里面可以是数据类型中的任何一个，如数字、字符串、对象、函数、数组等任何如：1var arr = [3，4，5] 题外话： 数组正（fu）规（za）的写法12Array(3,4,5) //(3) [3, 4, 5] 图： 2、length（表示数组的个数）语法：1arr.length （1）如何获取数组的最后一位具体数值？1arr[arr.length-1] 如：12345arr = [4,5,6] //(3)[4,5,6] arr[arr.length-1] //6 （2）用arr.length=0来清空数组，变成空数组1arr.length=0 --&gt;0 arr --&gt;[] （3）length如何进行截断（截断一词，是我自己想的，很形象了😂）假设：123456789101112131415var arr = [4,5,6] //undefinedarr// (3) [4, 5, 6] arr[100]=100 //100 arr.length //101 arr[3] // undefinedarr[99] //undefinedarr[100] //100` 然后，我们通过设置length进行数组截断1234arr.length = 2 //2 arr //(2) [4, 5] 3、下标使用语法：1arr[下标位数] （1）用下标访问数组的每一个元素：12345678910arr = [4,5,6] //(3)[4,5,6] arr[0] // 4 /* 或 */arr[1] // 5/* 或 */arr[2] // 6 （2）用下标去赋值,假设123arr[2] =100 arr // (3) [3, 4, 100] 或12345//为不存在位数赋值 arr[3]=101//101 arr //(4) [3, 4, 100, 101] 或者1234arr[100]=10 //10 arr // (101) [3, 4, 100, 101, empty × 96, 10] 图： 4、使用for循环遍历length，得出数组里具体的值1234567arr =[4,5,6] //(3) [4, 5, 6] for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]) &#125; //4 5 6 二、数组的一些操作1、栈方法：在数组里最后一位进行新增、删除操作这是数组中的一种栈方法，能够让我们使用堆栈那样先入后出使用数组（1）新增（于最后一位）：push语法：1arr.push() 如：1234arr.push(&apos;wangxiaoqin&apos;) // 4 //返回值输出位数 arr //(4) [4, 5, 6, &quot;wangxiaoqin&quot;] （2）去除（掉最后一位）：pop语法：1arr.pop() 如：12345678arr.push(&apos;wangxiaoqin&apos;) // 4 //返回值输出位数 arr //(4) [4, 5, 6, &quot;wangxiaoqin&quot;] arr.pop() //或console.log(arr.pop())，对应变量是一个结果（或方法） //&quot;wangxiaoqin&quot; arr //(3) [4, 5, 6] 2、队列方法：数组里第一位新增、删除这是数组中的一种队列方法，先入先出的队列法使用数组 （1）新增（于第一位）：unshift语法：1arr.unshift() 如：1234arr.unshift(&apos;wangxiaoqin&apos;) //4 arr //(4) [&quot;wangxiaoqin&quot;, 4, 5, 6] （2）删除（掉第一位）：shift语法：1arr.shift() 如：12345678arr.unshift(&apos;wangxiaoqin&apos;) //4 arr //(4) [&quot;wangxiaoqin&quot;, 4, 5, 6] arr.shift() //&quot;wangxiaoqin&quot; arr//(3) [4, 5, 6] 3、在数组的任意位置新增、删除（1）splice:删除、新增、替换、修改 A、语法：arr.splice (star位数,length/替换值,具体值) B、用处： 用于一次性解决数组添加、删除（二者结合可达到替换效果） C、三个参数： 开始索引 删除元素的位移如：指定前两个参数，可以使用splice删除数组元素，同样会带来索引调整及length调整 12345678var arr = [1,2,3,4,5] // undefinedarr.splice(1,3)//从下标1开始（包括下标1的值2），删除3个，所以数组元素为2，3，4 均被删除 //(3) [2, 3, 4] //所输出的a.splice所执行的结果，是一个新数组为[2, 3, 4] arr.length //2arr //(2) [1, 5] //同时arr本身剩下[1,5] 插入（替换）新元素（可以多写几个） 如：插入和替换，如果从第几个位开始做替换，替换的数组元素个数为0，即把0个元素替换成我需要的数组元素，则是使用splice插入法12345678var arr =[1,2,3,4,5] --&gt; undefinedarr.splice(1,0,9,99,999) //从下标1开始，即数组元素2前面，替换（其实就是插入）9，99，999三个数组元素 // [] arr.length // 8 arr// (8) [1, 9, 99, 999, 2, 3, 4, 5] 注： 这样的插入法，是连续性的，不在同一脚本同一时刻进行不同位数的插入。执行数组插入（替换）是一次完成，数组本身长度发生变化 实例： 如怎么去掉数组里的负数值，先看一个错误示范：12345678910var arr =[3, 4, -3, -2, -1, 5] --&gt; undefined for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;0)&#123; //数组里的具体值 arr.splice(i,1) //此时执行完下标为2的-3值，得出新数组[3, 4, -2, -1, 5] //继续执行i++,此时i=3,此时数组元素-1下标为3，直接跳过数组元素-2的下标 &#125; &#125; // [-1] arr // (4) [3, 4, -2, 5] 正确示范：1234567891011 var arr =[3, 4, -3, -2, -1, 5] // undefined for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;0)&#123; arr.splice(i,1) i -- //通过退回下标，可执行忽略的那个位数上的数组元素 &#125; &#125; //undefined arr //(3) [3, 4, 5] splice方法返回一个由删除元素组成的新数组，没有删除则返回空数组，则原数组发生改变,如：12345678var arr = [3,4,5] // undefinedarr//(3) [3, 4, 5] arr.splice(1,2) //从下标为1的元素开始，拿出来2个元素作为一个数组返回，原数组发生改变 //(2) [4, 5] arr //[3] //原数组发生改变 12345678arr.push(8,9,10) --&gt; 6 arr --&gt; (6) [4, 5, 6, 8, 9, 10] arr.splice(2,0,1,2,3) //从下标为2的位置（元素6）前开始，删除0个，新增两个元素(在6前面新增8,9,10) --&gt; [] arr --&gt; (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] （2）slice语法：arr.splice(star,end) 如：123456arr // (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] arr.slice(2,3)/*从arr下标为2开始，到下标为3结束(不包括3)，做为新数组，原数组不变 */ // [1] arr // (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] 4、join（加入一个任意字符串（甚至空字符串））1arr.join() //灵活应对 如：123456789var arr = [3,4,5] // undefinedarr// (3) [3, 4, 5] arr.join(&apos;-&apos;) // &quot;3-4-5&quot; /* 或 */arr.join(&apos;.&apos;) // &quot;3.4.5&quot; 5、reverse（数组里的值进行倒序（本身发生变化））倒序法，会修改原数组 语法：arr.reverse() 如：123456var arr=[3,4,5,6,7,8] // undefinedarr// (6) [3, 4, 5, 6, 7, 8] arr.reverse() // (6) [8, 7, 6, 5, 4, 3] 假如，当数组索引（下标）不是连续或以0 开始，结果需要注意：1234567891011121314var a = [1,2,3,4,5] // undefineda =[] // [] a[2]=2 // 2 a[3]=3 // 3 a[7]=4 // 4 a[8]=5 // 5 a.reverse() // (9) [5, 4, empty × 3, 3, 2, empty × 2] 6、concat（合成两个数组）如：12345678910var a = [1, 2, 3, 4, 5] --&gt;undefined var b = [6, 7, 8, 9] --&gt;undefineda.concat(b) // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9] //返回一个新数组，由于原数组保持不变，所以需要为这个数组赋值一个新变量 a// (5) [1, 2, 3, 4, 5] //原数组保持不变 b // (4) [6, 7, 8, 9] //原数组保持不变 7、sort（对数组进行排序）排序法，是一种内部的排序。可排序数字、字符串 语法：a.sort() 如： 对数字 1234var a=[5,4,3,2,1] // undefineda.sort() // (5) [1, 2, 3, 4, 5] 对字符串 1234var a=[5,&quot;a&quot;, &quot;c&quot;, &quot;h&quot;, &quot;z&quot;] // undefineda.sort() // (5) [5, &quot;a&quot;, &quot;c&quot;, &quot;h&quot;, &quot;z&quot;] 但是假如，这样排序，结果则不是按顺序排序1234var a=[7,8,9,10,11] // undefineda.sort() // (5)[10, 11, 7, 8, 9] 不加参数用sort排序法直接排序，它会将数组里的元素当成字符串去排序。按照字母表排序，7就比10大，这时候我们可以在sort内部传入自定义排序函数（比较函数）：123456789101112131415161718192021222324252627282930var a=[7,8,9,10,11] --&gt;undefineda.sort() // (5) [10, 11, 7, 8, 9] a.sort(function(v1,v2)&#123; return v1-v2 &#125;) // (5) [7, 8, 9, 10, 11]/*或者*/var friends = [&#123;age:3,name:&apos;dog&apos;&#125;,&#123;age:2,name:&apos;cat&apos;&#125;,&#123;age:4,name:&apos;bird&apos;&#125;] --&gt;undefinedfriends.sort(function(v1,v2)&#123; return v1.age -v2.age &#125;) // --&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] --&gt;0: &#123;age: 2, name: &quot;cat&quot;&#125; 1: &#123;age: 3, name: &quot;dog&quot;&#125; 2: &#123;age: 4, name: &quot;bird&quot;&#125; length: 3__proto__: Array(0) friends //--&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] friends.sort(function(v1,v2)&#123; return v1.name &gt; v2.name &#125;) //--&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] --&gt; 0: &#123;age: 4, name: &quot;bird&quot;&#125; 1: &#123;age: 2, name: &quot;cat&quot;&#125; 2: &#123;age: 3, name: &quot;dog&quot;&#125; length: 3__proto__: Array(0) 三、如何创建一个数组1、通过构造函数数组，作为一个特殊对象，通过传统的newArray创建数组 2、通过使用字面量如：1234var arr= [5] // undefineda.length // 1 注：使用带初始化参数的方式创建数组的时候，最好最后不要带多余的,，在不同的浏览器下对此处理方式不一样，如1234var a1 = [1,2,3,]//该脚本在现代浏览器上运行结果和我们设想一样，长度是3，但是在低版本IE下确实长度为4的数，而最后一条数据是undefined,就会造成误会 。 console.log(a1.length) console.log(a1) 四、数组的索引、长度数组也是对象，我们可以使用索引的奥秘在于，数组会把索引值转换为对应字符串（如 1=&gt;“1”）作为对象属性名如：1234567var arr =[1,2,3,4] arr[0] // 1 var i = 1 console.log(arr[i]) // 2console.log(arr[++i]) // 3 题外话： 不过在做这道题的时候，我发现一旦没有深刻理解操作符和运行机制的话，会导致结果不同，如：由于i++是后置，运行时按照：先拿i的值——再进行++操作；++i则是前置，运行时按照：先++操作再拿i的值。所以，运行机制上 五、数组的两三话1、数组的底层数据结构数组 === 特殊的对象（注：对象，由属性和属性值构成）。通过数组和对象的研究可以看出，数组可看成在对象的基础上做了一层的封装，然后自身又增加了一些方法。如：123456arr = [4,5,6] //--&gt;(3) [4, 5, 6] //--&gt;0: 4 //展开之后数组的底层数据结构 1: 5 2: 6 length: 3 __proto__: Array(0) 再如：123456obj = &#123;1:4,2:5,3:6,length:3&#125; //&#123;1: 4, 2: 5, 3: 6, length: 3&#125;//数组底层的数据结构构成obj[1] // 4obj.length // 3 2、数组的一些用法（1）关于数组里的属性和值的一些奇怪的写法12345678910111213arr [-10] = &apos;aaa&apos; --&gt; &quot;aaa&quot; arr [-10] --&gt; &quot;aaa&quot; arr //--&gt;(3) [4, 5, 6, -10: &quot;aaa&quot;] (3) [4, 5, 6, -10: &quot;aaa&quot;] --&gt; 0: 4 1: 5 2: 6 -10: &quot;aaa&quot; //这是一个很奇怪的属性和值， length: 3 __proto__: Array(0) （2）关于数组中删除的问题 A、首先，删除数组元素，可以直接使用delete，如1234567891011var arr = [3,4,5] //undefinedarr // (3) [3, 4, 5] delete arr[2]//通过最后的输出，则能知道数组里的是位数属性 //true arr// (3) [3, 4, empty] console.log(arr[2]) // undefined undefined B、以此，我们可以联想到，如果a[2]被赋值为undefined，情况也和delete之后的undefined类似，不会改变数组长度，也不会改变其他数据的index和value对应关系。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
        <tag>数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：06-2{ "JSON" }]]></title>
    <url>%2F2018%2F08%2F17%2F29-06.2%7B%20%22JSON%22%20%7D%2F</url>
    <content type="text"><![CDATA[一、定义JSON，用于数据交换的文本格式（解析之后得到一个相应的对象），是一种数据格式,如：12345&#123; &quot;name&quot;:&quot;wangxiaoqin&quot;, &quot;age&quot;:3 &#125; // &#123;name: &quot;wangxiaoqin&quot;, age: 3&#125; 二、Json对值得类型和格式有严格规定 复合类型的值：数组、对象（不能是函数、正则表达式对象、日期对象） 简单类型的值：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, Infinity和undefined） 字符串必须使用双引号（不能使用单引号） 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面不能加逗号 1、合格的 JSON 值注：合格的 JSON 值：空数组[ ] 、 空对象{} 、null1234[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] &#123; &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 &#125; &#123;&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] &#125; [ &#123; &quot;name&quot;: &quot;张三&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;&#125; ] 2、不合格的JSON值123456789101112&#123;name: &quot;张三&quot;, &apos;age&apos;: 32 &#125; // 属性名必须使用双引号 [32, 64, 128, 0xFFF] //不能使用十六进制值 0xFFF &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined&#125; //不能使用undefined &#123;&quot;name&quot;: &quot;张三&quot;, &quot;birthday&quot;: new Date(&apos;Fri, 26 Aug 2011 07:13:10 GMT&apos;), &quot;getName&quot;: function() &#123; return this.name; &#125; &#125; //不能使用函数和日期对象 三、如何JS中处理JSON格式数据1、把一个符合JSON格式规则的字符串解析成对象——JSON.parse()123456789var str = &apos;&#123;&quot;name&quot;:&quot;wangxiaoqin&quot;,&quot;age&quot;:3&#125;&apos; JSON.parse(str) //&#123;name: &quot;wangxiaoqin&quot;, age: 3&#125; /*调用单独属性*/ JSON.parse(str).age // 3 JSON.parse(str).name //&quot;wangxiaoqin&quot; 如图： 题外话： 深拷贝的另一种写法 利用JSON.parse()实现一个简单数据的深拷贝 ，对象转字符串123456789101112131415var obj = &#123; name: &apos;hunger&apos;, age: 3, friends: [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;] &#125;//定义一个对象 /* 将对象解析成字符串 */ JSON.stringify(obj) //&quot;&#123;&quot;name&quot;:&quot;hunger&quot;,&quot;age&quot;:3,&quot;friends&quot;:[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]&#125;&quot; /* 再把字符串解析成对象 */ JSON.parse(JSON.stringify(obj)) //&#123;name: &quot;hunger&quot;, age: 3, friends: Array(3)&#125; //深拷贝：相当于重组对象，外观一样，内核已变 2、把一个JS对象解析成字符串——JSON.stringify()1234567obj = &#123;a:1, b:2&#125;//&#123;a: 1, b: 2&#125; JSON.stringify(obj) //&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot;/* 解析为字符串值符合JSON格式 */ 如图： 四、Javascript对象和JSON的关系 javascript对象的字面量写法只是长的像 JSON 格式数据（JS属于模仿JSON），二者属于不同的范畴 JavaScript 对象中很多类型(函数、正则、Date) ，JSON 格式的规范并不支持 JavaScript 对象的字面量写法更宽松（如可不为属性名引号）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：06-1{对象}]]></title>
    <url>%2F2018%2F08%2F17%2F28-06.1%7B%E5%AF%B9%E8%B1%A1%7D%2F</url>
    <content type="text"><![CDATA[一、对象1、定义： 本质上是一种无序的数据集合，由若干个“键值对”（又称为：成员）（key-value）构成。其中，键值对，包括键名（key，即成员的名称）、键值（value，即成员的值）。 2、先前我们对对象的定义：123456object() // &#123;&#125; ⏬ var obj = object() obj //&#123;&#125; 再让我们看看，{}+键值对所定义的对象，让我们再看一个例子：123var obj = &#123; p: &apos;Hello World&apos; &#125;; 这样看来，相当于1object() === &#123;&#125; 例子中，{}定义了一个对象，且被赋值给变量obj。这个对象内部包含一个键值对，P为“键名”，字符串hello world为“键值”，即：{键名：键值}，包含多对键值对，每个键值对之间用逗号分隔，如：1var o = &#123; p1: &apos;Hello&apos;, p2: &apos;World&apos; &#125;; 是不是知道对象是什么了？事实上，{key：value}这种写法，在JS中我们把它称为JS的对象字面量（也是数组字面量写法）。让我们继续。。。 二、基本使用首先要定义一个对象 1、对象的一般写法：12345678 var company = &#123; name:&apos;wangxiaoqin&apos; &#125; --&gt;undefined/* 调用属性name，输出值：&quot;wangxiaoqin&quot; */ company //&#123;name: &quot;wangxiaoqin&quot;&#125; 或者12345678910111213141516var company = &#123; name: &apos;世界你好&apos;, age: 3, sayHello: function()&#123; console.log(&apos;hello world&apos;) &#125; &#125; // undefined/* 分别调用各属性和值 */company.name// &quot;世界你好&quot; company.age // 3 company.sayHello() //hello world 如图： 2、对象里属性值的获取写法：方法一：1234console.log(company.name)//变量名.属性名 以此来调用值``` 方法二： console.log(company[‘name’])//变量名[‘字符串’]1错误写法： company[name] // undefined1### 3、新增属性，直接赋值 company.addr = ‘杭州市’//“杭州市” / 验证：调用变量，输出：{属性：值} /company//{name: “世界你好”, age: 3, sayHello: ƒ, addr: “杭州市”}1或者 company[‘business’] = ‘学习课程’//“学习课程” company// {name: “世界你好”, age: 3, sayHello: ƒ, addr: “杭州市”, business: “学习课程”}123### 4、遍历对象里的属性和值使用： for(var 属性名 in 声明的变量）{ console.log(key) console.log（company[key]） }//key进行遍历时，每一次循环这个变量key，都能调用key里的属性12效果如下： for(var key in company){ console.log(key) }// name// age// sayHello// addr// business// undefined12而单个的属性名如何调用: company[key] === company[‘name’]1234# 三、具体使用### 1、键名：（1）键名是字符串（加不加引号都可以） var o = { ‘p’: ‘Hello World’};12（2）键名是数值，会被自动转为字符串 var o ={ 1: ‘a’, 3.2: ‘b’, 1e2: true, 1e-2: true, .234: true, 0xFF: true}; o// Object {// 1: “a”,// 3.2: “b”,// 100: true,// 0.01: true,// 0.234: true,// 255: true// }12（3）键名不符合标识符条件：第一个字符为数字、含空格和运算符等，必须加上引号（否则报错），如： var o = { &apos;1p&apos;: &quot;Hello World&quot;, &apos;h w&apos;: &quot;Hello World&quot;, &apos;p+q&apos;: &quot;Hello World&quot; }; 123### 2、键名 === 属性如果属性值为函数 `===`方法，能像函数那样调用 var o = { p: function (x) { return 2 * x; } }; //p为函数 o.p(1) // 21234### 3、多个对象的属性，用逗号分隔（随意加不加）### 4、属性可以动态创建（不一定在对象声明时就指定）如：对`obj`对象的`foo`属性赋值，结果就在运行时创建了`foo`属性。 var obj = {}; obj.foo = 123; obj.foo// 12312345### 5、引用（1）对象的引用：A、不同的变量名指向同一个对象，那么它们（变量名）都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 var o1 = {}; var o2 = o1; o1.a = 1;o2.a // 1 o2.b = 2;o1.b // 21B、取消某一个变量对于原对象的引用，不会影响到另一个变量。 var o1 = {}; var o2 = o1; o1 = 1;o2 // {}12345（2）传值引用：不同变量名不对同一对象引用，第（1）种的引用只限于对象，对原始类型的数据则使用传值引用当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 var x = 1; var y = x; x = 2; y // 112### 6、表达式 ？语句？ { foo: 123 }1作为语句，可能是一个代码区块，里面有一个标签`foo`，指向表达式`123`。` === `如果行首是大括号，一律解释为语句（即代码块），如： / 假如没有赋值，js引擎默认为块语句 / { foo:123 } ==={ label：123}–&gt;{foo: 123} -&gt;foo: 123 -&gt;proto: Object1作为表达式，可能是一个包含foo属性的对象`===`,如果要解释为表达式（即对象），必须在大括号前加上圆括号，如： ({ foo:123}) //123123**题外话：关于eval**（1）将字符串当做JS语句去执行 eval(‘console.log(123)’)// 123123（2）`字符串 === 对象`：没有`圆括号 ===块语句===代码块` VS `圆括号===表达式===对象` eval(‘{foo: 123}’)// 123 eval(‘({foo: 123})’) // {foo: 123}1234###7、检测变量是否声明（或被定义）可以在全局作用域中这样检测：（1）没有声明 ‘abc’ in window// false12（2）有声明 var hello //undefined ‘hello’ in window// true1234### 8、查看所有属性查看对象本身的所有属性，可用`Object.key`或使用`for...in`循环遍历。（1）方法一：`Object.keys` var o = { key1: 1, key2: 2 }; Object.keys(o); //(2) [“key1”, “key2”]12（2）方法二：`for...in循环遍历` var o = { key1: 1, key2: 2 }; for(var keys in o){ console.log(keys) }// VM4390:6 key1// VM4390:6 key21234567### 9、delete命令（1）删除一个存在的属性：两种情况：**A、只能删除属性** var o = {p: 1}; Object.keys(o)// [“p”]delete o.p -&gt;o.pObject.keys(o)// []1234**B、不能删除var命令声明的变量**var声明的全局变量都是顶层对象的属性，而且默认不得删除。 var p = 1;delete p // falsedelete window.p // false12（2）删除一个不存在的属性delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的，只能保证读取这个属性肯定得到`undefined`。 var o = {};delete o.p // true`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
        <tag>表达式和语句</tag>
        <tag>键名和键对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：05引用类型和深浅拷贝]]></title>
    <url>%2F2018%2F08%2F17%2F27-05%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[一、基本类型VS引用类型注： 这里的内存，为虚拟内存 1、引用类型： 定义：保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象 包括：对象、数组、函数、正则 假设变量中有一个函数，函数内东西特别多（或者有一个对象，对象里的数据特别大），这里可选堆的空白处存放函数、对象的数据（随机选择未使用的空白堆，随意变大变小），放在堆中的均为引用类型 2、基本类型（值类型）： 定义：指的是保存在栈内存中的简单字段（成块排列，栈，允许放进去拿出来） 包括：数值(number)、布尔值(boolean)、null、undefined、string(在赋值传递中会以引用类型的方式来处理) 栈里面仍存有变量，只不过存放的不是数据，而是大数据地址，比如这个地址为0x0011,栈内存放的东西，均为可控、较小容量。从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上。 3、实例一：基本类型12345678910111213141516171819 var a var b var obj var obj2 a = 1; b = 2; var obj = &#123; name: &apos;xiaoqin&apos;, sex: &apos;male&apos;, age: 30, friend: &#123; name: &apos;hello&apos;, age: 100 &#125; &#125; var newObj = &#123;&#125; b = a; console.log(b) //返回1 如图： （1）基本类型的值被赋值给另一个变量，其实就是分配内存空间一开始，a的值为 1 ，当使用a 来初始化b时，b值此时为1。但b中的1与a中的是完全独立的，该值只是a中的值的一个副本。说明在栈里变量再次变化，但这个两个变量可以参加任何操作而相互不受影响。 总结：一个变量赋值给另一个变量时，其实是分配了一块新的内存空间。按照以上操作，基本类型在赋值操作后，事实上就a分配了一块新内存空间给b，两个变量是相互不受影响。 （2）基本类型的比较是值的比较 只有在它们的值相等的时候它们才相等。 当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。123var a = 1;var b = true;console.log(a == b);//true （3）基本类型的变量其实就是存放在栈区。结合以上，栈区指内存里的栈内存，但是栈区里包括了变量名和变量值。 4、实例二：（续上面的例子）引用类型（1）引用类型的值是可变的可为引用类型添加属性和方法，也可以删除其属性和方法。看一下这个例子：一个为引用类型的变量赋值给另一个为引用类型的变量12345 var obj2 = obj //控制台测试一下二者的值 obj// &#123;name: &quot;ruoyu&quot;, sex: &quot;male&quot;, age: 30, friend: &#123;…&#125;&#125; obj2 // &#123;name: &quot;ruoyu&quot;, sex: &quot;male&quot;, age: 30, friend: &#123;…&#125;&#125; 值是一样的。因为var obj2=obj，即通过obj的值（一个对象）赋值给obj2，那么obj2的值就是赋值后原本obj对应属性和值。作为一个引用类型，它被放在堆中。所以寻找obj2则在堆里找到，只是换了另一个名字为obj2 如图： 总结：原本在栈中的对象分别指向了同一个堆，那么存放在堆中即为对象的内存地址。引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。 （2）引用类型的比较是引用的比较A、我们先看一下基本类型值的比较：1234var obj3 = &apos;&#123;name: &apos;hello&apos;&#125;&apos;; var obj4 = &apos;&#123;name: &apos;hello&apos;&#125;&apos;; console.log( obj3 == obj4 ); // true 总结：可以得出基本类型的比较：当两个比较值的类型相同(如字符串)的时候，相当于是用 === ，所以输出是true。 B、再来看一下引用类型值的比较：1234var obj3 = &#123;name: &apos;hello&apos;&#125;var obj4 = &#123;name: &apos;hello&apos;&#125; obj3 === obj4 //返回false，说明二者并不相等 为什么是false？不相等呢？放在栈中的变量 obj3、obj4，声明前置均为undefined，当两者均被被声明值的时候，是两个对象，引用类型是引用访问，相当于在堆中分别开辟了两个空间，堆中会有对应的属性+值，此时这两个对象在堆中存的便是堆的地址。obj4与obj3一样都开辟了新的堆空间，但是存放的地址也不一样。判断obj3是否与obj4相等，看了分析之后，便知道堆存放的地址并不同，二者也就不相等 如图： （3）引用类型的值是同时保存在栈内存和堆内存中的对象123456function sum()&#123; console.log(&apos;sum...&apos;) &#125; var sum2 = sum; sum2() //返回sum... 二者是相等的 我们可以就此分析，函数function sum(),分别有变量sum和函数对象代码（为引用类型，已放在堆中）。之后sum赋值给sum2，即sum2事实上使用的是赋值后sum所指代堆的内存地址,即后续sum和sum2共用了堆里的代码（变量的内存地址就像指针一样，通过JS自身引擎找到这个堆），一堆东西起了两个不同的名字 如图： 总结： js不同于其他语言，其不允许直接访问内存中的位置，即不能直接操作对象的内存空间，实际上，是操作对象的引用，所以引用类型的值是按引用访问的。 准确地说，引用类型的存储需内存的栈区（栈区是指内存里的栈内存）和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，然后，栈区内存地址也可以说是该对象在堆内存的地址。 二、引用类型的实际应用1、函数的参数传递第1个例子：123456789101112131415161718192021function inc(n)&#123; n++; &#125; var a = 10; inc(a) console.log(a) //返回10 /*等同于*/ function inc()&#123; var n = arguments[0] n++ &#125; //在函数的一开始将var a = 10赋值进var n = arguments[0]， //n=arguments[0]=10,此时与n++为11并没有返回，所以与a并无关系 var a = 10 inc(a) console.log(a) //返回10 ✨第2个例子：123456789101112131415 function incObj(obj)&#123; //var obj = o //0x0001 obj.n++ &#125; var o = &#123;n: 10&#125; //o = 0x0001 对其做声明，为一个对象 incObj(o) console.log(o) //等同于 function incObj()&#123; var obj =arguments[0] obj.n++ &#125; //incObj(o) 相当于function incObj()&#123;var obj =arguments[0]；obj.n++&#125;， //可知道obj=arguments[0]=o,相当于设obj为临时变量，而o= 0x0001 var o = &#123;n: 10&#125; incObj(o) console.log(o) 如图： 总结：引用类型的本质，变量所存的是这个对象的内存地址指向堆，当去做赋值时是把这个地址进行一个赋值；当去访问的时候是通过这个地址去访问这个对象 ✨第3个例子：12345678910function squireArr( arr )&#123; //var arr = 0x0011 for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i] * arr[i]; &#125; &#125; var arr = [2,1,3,6] squireArr(arr) console.log(arr) //(4) [4, 1, 9, 36] 即把function squireArr(arr){}中的数组squireArr(arr)里的每一项变为原来的平方，即参数arr为数组里的值，用for循环进行操作，外界调用时，只需调用一次squireArr(arr)，事实上数组squireArr(arr)操作就是对arr的操作 ✨第4个例子：12345678910111213 function squireArr2( arr )&#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; newArr[i] = arr[i] * arr[i]; &#125; return newArr; &#125; var arr2 = squireArr2(arr) console.log(arr2) //返回(4) [16, 1, 81, 1296] arr // (4) [4, 1, 9, 36] arr2 --&gt; (4) [16, 1, 81, 1296] 2、对象的深浅拷贝针对这个例子:123456789101112 var obj; var obj2; var obj = &#123; name: &apos;ruoyu&apos;, sex: &apos;male&apos;, age: 30, friend: &#123; name: &apos;hello&apos;, age: 100 &#125; &#125; var obj2 = obj; 想要创造一个新的b，那么就需要遍历原始a的每一项属性+值，用来获取成为新个体的b所需的东西，并一一对b进行改造，即从一无所有，改造成与a相似的新个体，此为克隆。 如果在遍历的时候，b这个新个体只是遍历a的前半部分或者局部，那么这称之为浅拷贝，如：123456789function shallowCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var i in oldObj) &#123; if(oldObj.hasOwnProperty(i)) &#123; newObj[i] = oldObj[i]; &#125; &#125; return newObj; &#125; 而如果b是遍历原始a的每一项属性和值，但是b又是一个独立个体，与a不相关，当修改b的时候，a仍然不会发生变化，而这叫做深拷贝，如：1234567891011function deepCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj) &#123; if(typeof oldObj[key] === &apos;object&apos;) &#123; newObj[key] = deepCopy(oldObj[key]); &#125;else&#123; newObj[key] = oldObj[key]; &#125; &#125; return newObj; &#125; json——string——对象]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>引用类型</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：04作用域和作用域链]]></title>
    <url>%2F2018%2F08%2F17%2F26-04%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前言：在记录作用域和作用域链知识，我一度陷入了错误理解的边缘😂，它也是之后理解闭包知识非常重要的前置知识。查了资料，做了习题，问了老师验证了自己的理解，终于输出了一些我自己的理解。部分知识的表述有引用如有不妥之处，请老司机拍砖😂~ 参考资料：lce_shou《深入理解闭包之前置知识→作用域与词法作用域》 一、什么是作用域1、先看一段简单代码:123456function fn() &#123; var a = &apos;miya&apos;; console.log(a); // 输出&quot;miya&quot; &#125; fn(); 在fn函数执行的时候，输出一个a变量，那么这个a变量是哪里来?有看到函数第一行有定义a变量的代码var a = &#39;miya&#39; 2、继续看另外一段代码：1234var b = &apos;programmer&apos;; function fn() &#123; console.log(b); // 输出&quot;programmer&quot; &#125; fn(); 同样，在输出b的时候，自己函数内部没有找到变量b，那么就在外层的全局中查找，找到了就停止查找并输出了。 3、那么，可以注意到以上两段代码都有查找变量。第一段代码是在函数中找到a变量，第二段代码是在全局中找到b变量。当然也要注意：javascript中{}`并没有带来块级作用域，如：123456&#123; var a=1 &#125; console.log(a) //1/*即使这样的定义，同样能输出：1*/ javascript的作用域是通过函数来形成，也就是说一个函数内定义的变量，函数外是不可以访问，如：123456function fn()&#123; var a =1; &#125; //js编译器从此函数作用域出来之后，外界的变量函数或者声明变量均与之无关 fn(); console.log(a); /*&quot;ReferenceError: a is not defined&quot;说明在全局作用域中变量未被声明*/ 接下来，我们在函数、全局，两个概念名分别都加上作用域三个字，是不是又打开一个新世界了？ 关注细节的就知道，作用域，本质是一套规则，用于确定在何处以及如何查找变量（标识符）的规则。关键点在于：查找变量（标识符）。接下来让我们继续探索作用域链。 二、作用域链1、还是看刚才这段代码12345var b = &apos;programmer&apos;; function fn() &#123; console.log(b); // 输出&quot;programmer&quot; &#125; fn(); 一般来说，我们在查找b变量时，先在函数作用域中查找，没有找到，再去全局作用域中查找，你会注意到，这是一个往外层查找的过程，即顺着一条链条从下往上查找变量，这条链条，我们就称之为作用域链。 2、全局作用域，我们先从js页面中同时存在变量fn和变量a所处的位置来看在页面里所写的代码都是出于一个全局作用域下。全局作用域，相当于页面上有一个含有声明变量a或者函数fn的window对象，所声明的全局变量都是window对象下对应的一个属性。 还没有接触到ES6的let、const之前，只有函数作用域和全局作用域，函数作用域肯定是在全局作用域里面的，而函数作用域中又可以继续嵌套函数作用域，如： 三、从面试题解构作用域和作用域链1、解密原理： 每当执行完一块作用域里的函数后，它就进入一个新的作用域下（一般从下往上找） 当你使用一个变量或者给一个变量去赋值时，变量是从当前的作用域找，再从上层作用域（指当前这个函数所声明的作用域里）上找 2、具体如何运用解密原理（0）测试：1var name = &apos;iceman&apos; 这段小小的js代码有其编译过程，经历了下面的步骤：A、编译器在当前作用域中声明一个变量nameB、运行时引擎在作用域中查找该变量，找到了变量name并为其赋值下面这道题则证明以上说法：12console.log(name); // undefined var name = &apos;miya&apos;; 在name 1234编译器工作，是在代码执行前从上到下进行编译，当遇到某个用var声明变量时，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量。查找的规则：是从当前作用域开始找，如果没找到再到父级作用域中找，一层层往外找，如果在全局作用域如果还没找到的话，就会报错了： ReferenceError: 某变量 is not defined12（1）第1题： var a = 1function fn1(){ function fn2(){ console.log(a) } function fn3(){ var a = 4 fn2() } var a = 2 return fn3}var fn = fn1()fn() //输出多少 //a=2//执行fn2函数，fn2找不到变量a,接着往上在找到创建当前fn2所在的作用域fn1中找到a=212（2）第2题： var a = 1function fn1(){ function fn3(){ var a = 4 fn2() } var a = 2 return fn3}function fn2(){ console.log(a)}var fn = fn1()fn() //输出多少 //a=1//最后执行fn2函数，fn2找不到变量a,接着往上在找到创建当前fn2所在的全局作用域中找到a=112（3）【重点】第3题： var a = 1 function fn1(){ function fn3(){ function fn2(){ console.log(a) } var a fn2() a = 4 } var a = 2 return fn3}var fn = fn1()fn() //输出多少 //undefined//函数fn2在执行的过程中，先从自己内部找变量找不到，再从创建当前函数所在的作用域fn去找,注意此时变量声明前置，a已声明但未初始化为undefined123456789事实上，我发现上一节函数中立刻执行的函数表达式本质上也可以感受一下局部作用域和全局作用域的区别。（4）再深入看几道网上的经典题，感受一下已经模糊的智商~😂（其实也还好啦~并没有对智商多大的撞击）在作用域链中查找过程的伪代码：**第1道题：** var x = 10bar()function foo() { console.log(x)}function bar(){ var x = 30 foo()} /第2行，bar（）调用bar函数第6行，bar函数里面调用foo函数第3行，foo函数从自己的局部环境里找x，结果没找到第1行，foo函数从上一级环境里找x，即从全局环境里找x，找到了var x=10。foo（）的输出结果为10。 /123第2道题： var x = 10;bar()function bar(){ var x = 30; function foo(){ console.log(x) } foo();}/第2行，bar（）调用bar函数第3行，bar函数里面是foo函数foo函数在自己的局部环境里寻找x，没找到foo函数到自己的上一级环境，即bar函数的局部环境里找x，找到var x=30所以第2行的bar（）输出为30 /12第3道题： var x = 10;bar()function bar(){ var x = 30; (function (){ console.log(x) })()}/第2行，bar（）调用bar函数第三行，bar函数里的function（）在自己的局部环境里寻找x，但没找到function（）在上级环境即bar的局部环境里寻找x，找到var x=30，于是显示结果为30 /`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域</tag>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：03-02 声明提前和立即执行函数]]></title>
    <url>%2F2018%2F08%2F17%2F25-03.02%20%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、声明提前1、变量声明提前——变量提升可参照这里的描述：#hello，JS：01数据类型、运算符、运算符优先级1234//先输出a,再声明var a=3 console.log(a) //undefined var a=3 再如：123console.log(a)//undefined console.log(b) //报错 var a=3 为什么console.log(a)输出undefined，而console.log(b) 则会报错呢？出现这样的情况是为什么？实际上JS引擎在一行行执行代码的时候，有一些默认的运行我们并不知道，即：123var a //undefined,变量a已经前置声明，则结果为undefined console.log（a） //undefined console.log（b） //报错，没有变量b，引用失败 a=3 最后是：变量的声明前置的完整运行：12345var a //undefined,已经前置声明为undefined console.log(a) //undefined a=3 console.log(a) --&gt; undefined 3 2、函数的声明前置先看这段代码：1234sum(5,3) //放在任何的地方，但是只是一个函数值，并没有打印这个函数出来function sum(a,b)&#123; return a+b&#125; 设置两种看两种执行结果： 看代码，不是没有任何的变量声明？为什么就可以使用函数输出结果？这是因为函数所执行的JS引擎默认操作与变量声明前置机制是类似。相当于：包含变量数据的function函数前置，即以上代码等同于12345function sum(a,b)&#123; return a+b &#125; sum(5,3) //直接返回8 3、函数表达式的声明前置还是先看代码：12345fn()var fn = function()&#123; console.log(&apos;fn...&apos;)&#125;//报错，直接说fn不是一个函数 这里，function函数是一个变量，相当于把一个数字赋值给fn，而这个function函数表达式，事实上也是有一个声明前置的，即：12345var fn //undefined fn() //此为函数，会执行，但是如果是undefined(),这种是不成立，即报错 fn = function()&#123; console.log(&apos;fn...&apos;) &#125; 那么原始代码是怎么执行的？原始代码：12345678fn() sum(3,4) var fn = function()&#123; console.log(&apos;fn...&apos;) &#125; function sum(a,b)&#123; return a+b &#125; 对于浏览器来说它做了什么：一个声明前置：包括变量声明前置和函数声明前置12345678var fn //变量声明前置 function sum(a,b)&#123; return a+b &#125; //函数声明前置 fn() sum(3,4) fn = function()&#123; console.log(&apos;fn...&apos;) &#125; 二、立刻执行的函数表达式注：关于js的语法规则如何体现？ 1、先看下面这个代码12 (function()&#123; console.log(&apos;wangxiaoqin&apos;) &#125;)() --&gt;&quot;wangxiaoqin&quot; 先暂且不管它的结果如何产生。先了解一下JS的语法规则 按照这样写，为何只有function(){}单独作为一个变量时，通过模仿语句a( );，function(){}();这个语句则会操作会报错，这是为什么？ 对于JS引擎来说不认为是一个表达式，很像一个函数声明，再加一个括号，即会报错。那么如何让这个语句正常赋值？直接将整个函数声明加一个括号，即：1(function()&#123;&#125;)() 由于作为运算符，括号和括号里的内容组合为一个表达式。加上括号之后，会让JS引擎认为它是一个表达式（或引用类型），那么就符合了JS的语法规则。 总结：当在一个函数声明后加了圆括号（也是一种运算符）后运行的话，会报错。因为这被认为是语法错误。在JS中，以function开头会被认为是语句，而语句不应该以圆括号结尾。所以此时可以选用的解决办法是把整个语句用圆括号包起来。 2、那么刚才列举的代码：123456789(function()&#123; console.log(&apos;wangxiaoqin&apos;) &#125;)() --&gt;&quot;wangxiaoqin&quot; //即函数表达式，立刻去执行它 //等同于 var fn = function()&#123; &#125; fn() 这类型的函数表达式有什么用？这里涉及了函数中所对应的作用域的概念，假设我们在这类函数里添加一个变量123456 (function()&#123; var a =3 console.log(&apos;wangxiaoqin&apos;) &#125;)() console.log(a)//运行，后台报错，a是没有被定义的。 //因为a变量是不被看到的，因为a在function函数的这个作用域里，与外界无关 3、立刻执行函数的好处：1var fn=function()&#123;&#125; 相当于1fn()===(函数表达式)() 作为一种运算符，用这种局部作用域的方式将函数引用包裹起来，形成一个立即执行的表达式，好处在于：12345678910A、函数不必再另外命名，避免污染全局，不会在复杂页面协作中造成错乱；B、实现一个作用域隔离，封装外部无法读取的私有变量;C、避免命名冲突，符合js语法规则，并立刻执行。# 三、命名冲突当在同一个作用域内定义了名字相同的变量和方法的话，会根据前置顺序产生覆盖 var fn = 3; function fn(){}console.log(fn); // 31相当于 var fn function fn(){} //覆盖上面的 fn = 3 //重新赋值 console.log(fn) //为函数1当函数执行有命名冲突的时候，可以认为在还是内部一开始有隐藏的声明变量这个操作 function fn(fn){ console.log(fn); var fn = 3; console.log(fn); }fn(10) //10 3 //等同于有一个默认的var fn = arguments[0]的操作 function fn(){ var fn = arguments[0] //1、将它先声明前置，再赋值，再输出 console.log(fn); var fn = 3; //2、再赋值 console.log(fn); } fn(10) //10 3`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>声明提前</tag>
        <tag>立即执行函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：03-01函数]]></title>
    <url>%2F2018%2F08%2F17%2F24-03.01%E5%87%BD%E6%95%B0md%2F</url>
    <content type="text"><![CDATA[总结：数字+undefined===Nan一、函数的使用1、什么是语句：先看这几个概念表达式：12a=1 a+btypeof 语句：代表一定功能的表达式的组合1a+b; 2、但是特定功能需要几条语句实现，太复杂123statement1; statement2; statement3; 那么，可以将语句打包成一个函数，然后调用这个函数即可，如：1function doSomething()&#123; statement1; statement2; statement3; &#125; 调用这个函数。调用函数通过函数名称( )的形式调用1doSomething(); //需要的时候就调用 实例：12345678function sum()&#123; console.log(&apos;hello&apos;) console.log(&apos;wangxiaoqin&apos;) &#125; sum() //返回//&quot;hello&quot; //&quot;wangxiaoqin&quot;` 二、声明函数ECMAScript规定三种声明函数方式 1、函数声明123456//使用function关键字可以声明一个函数 //printName() 即函数名称() ，可调用 function printName()&#123; console.log(&apos;世界&apos;)； &#125; printName()； 2、函数表达式12345678/* 通过var 进行一个声明变量，这里的 变量 等同于 函数表达式*/ var printName = function()&#123; console.log(&apos;饥人谷&apos;) &#125;； printName() //等同于 var printName = 3； 函数声明VS函数表达式 3、构造函数（不常用）通过构造函数，使用new来创建一个函数对象1var printName = new Function(&quot;console.log(&apos;Byron&apos;);&quot;); 三、参数1、只使用定义函数较为僵化，可通过参数方式让函数调用、复用。举例说明： 123456789101112131415161718192021222324 function printName(name)&#123; //括号中的name为函数的参数 console.log(name) &#125; printName(&apos;hunger&apos;) printName(&apos;valley) //等同于在函数设置变量 function printName()&#123; //括号为空括号 var name = arguments[0] console.log(name); &#125; printName(&apos;hunger&apos;); //假设没有传递参数 function printName()&#123; //括号为空括号 var name = arguments[0] console.log(name); &#125; printName(); //arguments[0] 为undefined，name=undefined ,那么结果为undefined //函数在定义的时候可以写多个参数 function printPersonInfo(name, age, sex)&#123; console.log(name) console.log(age) console.log(sex) &#125; 2、Arguments传参数通过函数内部的arguments对象获取到该函数的所有传入参数（按顺序传入），通过1console.log(arguments) //输出每一个参数的值 即：12function printPersonInfo(name, age, sex)&#123; console.log(name) console.log(age) console.log(sex) console.log(arguments) 即：console.log(arguments[0]===name) console.log(arguments.length) console.log(arguments[1] === age) &#125; 3、实例例1： 例2： 例3：1234567891011function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小明&apos;, 2, &apos;男&apos;); getInfo(&apos;小小明&apos;, 3); getInfo(&apos;男&apos;); 即：1234567891011121314151617181920function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小明&apos;, 2, &apos;男&apos;); 传递的参数：最终获得的值name:小明 //函数内部对参数无赋值，所以选择输入的值。 age: 2 //理由同上 sex: 男 //理由同上 0:valley //console.log(arguments)表示输出每一个参数的值。 于是先读取getInfo函数自己的局部环境，读取到了valley。于是显示valley。 1: 2 //先读取getInfo函数自己的局部环境，没读取到值。于是向上找，找到了输入的值2。 3: 男 //理由同上 name: valley //在getInfo函数的局部环境里向上读取，在上方发现了name赋值，所以显示valley。 12345678910111213141516function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小小明&apos;, 3); name: 小小明 //函数内部对参数无赋值，所以选择输入的值。 age: 3 //理由同上。 sex: undefined //第三个参数没有输入，所以显示undefined。 0: valley //console.log(arguments)表示输出每一个参数的值。于是先读取getInfo函数自己的局部环境， //读取到了valley。于是显示valley。 1: 3 //函数内部对参数无赋值，所以选择输入的值。 name: valley //在函数局部环境内向上读取发现已经对name赋值，所以显示valley。 1234567891011121314function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); \ &#125; getInfo(&apos;男&apos;); name: 男 //在自己的局部环境的上方没有读取到值，所以向上一级读取，显示为男。age:undefined //整个环境内都没有赋值，所以显示为undefined sex:undefined //整个环境内都没有赋值，所以显示为undefined 0: valley //console.log(arguments)表示输出每一个参数的值。于是先读取getInfo函数自己的局部环境， 读取到了valley。于是显示valley。name:valley //在函数局部环境内向上读取发现已经对name赋值，所以显示valley。 题外话：函数是有参数的，在声明函数的时候可以在定义的函数旁加一个参数，当你要执行的时候，需要调用带有该参数的函数，如果没有传递这个参数的话，相当于这个带有参数的函数结果就为：undefined如：1234567function printName()&#123; var name = arguments[0] console.log(name); &#125; printName() --&gt;输出：undefined 图： 5、函数返回值函数，即把一段语句包装起来，调用函数的参数的时候，就会执行这些语句，更多的是得到一些结果。就像表达式给一个结果，希望函数执行后给一个反馈，我们可以通过return来实现如:12345function sum(a,b,c)&#123; console.log(a+b) //只是把计算的结果展示在控制台，无其他事（用户若不打开控制台无意义） return a+b &#125; var result = sum(4,6) console.log(result) //返回10 假设：没有return，会出现什么结果呢？ 以上结果以说明，console.log(a+b)，输出10，只是把计算结果呈现在控制台，表示它做了这件事情，只不过没有把结果返回。但是console.log(a+b)本身也是一个函数，整个函数本质上执行的结果为undefined，调用result，结果也是undefined ❌错误写法：1234567function sum(a,b,c)&#123; return console.log(a+b) &#125; var result = sum(4,6) console.log(result) //返回10 //undefined 但是有这样的写法：12345678910111213141516171819202122232425 function fn(score)&#123; if(score&lt;0) return console.log(score) &#125; fn(-3) //等同于 function fn(score)&#123; if(score&lt;0) &#123; return undefined &#125; console.log(score) &#125; fn(-3) //等同于 function fn(score)&#123; if(score&lt;0) &#123; &#125; else&#123; console.log(score) &#125; &#125; fn(-3) 四、重载1、什么是函数重载重载是很多面向对象语言实现多态的手段之一，在静态语言中确定一个函数的手段是靠方法签名——函数名+参数列表，也就是说相同名字的函数参数个数不同或者顺序不同都被认为是不同的函数，称为函数重载。 2、JS没有函数重载在JavaScript中没有函数重载的概念，函数通过名字确定唯一性，参数不同也被认为是相同的函数，后面的覆盖前面。函数调用没必要把所有参数都传入，只要你函数体内做好处理就行，但前提是传的参数永远被当做前几个传递不同的参数，做不同的事情，根据函数中参数类型和个数去进行逻辑判断。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：02流程控制判断]]></title>
    <url>%2F2018%2F08%2F17%2F23-02%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[一、if语句if语句是编程语言最常用的语句， 1、语法：12345if(condition)&#123; //true statement &#125;else &#123; //false statement &#125; 其中condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值，如果表达式为真，执行第一个代码块内语句；如果为假，执行第二个代码块内语句 if语句可以单独使用，也可以和多个else连续使用123456789101112/* 满足这些条件做对应的事情*/ if(a &gt; 2)&#123; // statement &#125; if( a == 1)&#123; &#125;else if(a == 2)&#123; &#125;else if(a == 3 )&#123; &#125;else&#123; &#125; 2、例子:1234567var a = 1 if(a === 1)&#123; console.log(&apos;ok&apos;) &#125;else&#123; console.log(&apos;not ok&apos;) &#125; ---&gt;&quot;ok&quot; 二、switch语句注： JavaScript switch语句虽然参考的C语言的写法，但是有特殊性 switch和case可以使用任意表达式，不一定是常量 switch语句进行比较的时候是全等于（===）操作，不会发生类型转换 1、语法：12345678910switch(expresstion)&#123; case value1: //该条件：（满足）这个值 statement; //则执行该语句 break; //强制输出 case value2: statement; break; default: statement; &#125; 2、例子：123456789var score =prompt(&apos;请输入分数&apos;) switch (score)&#123; case 100: console.log(&apos;100分&apos;) break; case 99: consolelog(&apos;99分&apos;) break; default: console.log(&apos;其他分数&apos;) &#125; --&gt;可弹出一个表单输入框输入分数 题外话：break，如果表达式等于case的值，对应的语句就会执行，break关键字会使程序跳出switch语句，很多编程规范强调必须添加break，不添加不会有语法错误，程序会多次判断case，进入相应流程。 当没有一个值符合case或者没有break，流程则进入default子句，很多规范也强调必须添加default部分 break VS continuebreak关键字在switch语句中已经见过，这两个关键字多用在循环语句中 break 用于强制退出循环体，执行循环后面的语句 continue 用于退出本次循环，执行下次循环 例子： break 12345for(var i = 1; i&lt; 10; //第一步 i++ //第三步（2）（如果不符合函数：i % 4 === 0，继续循环）)&#123; if(i % 4 === 0)&#123; break; &#125;//第二步 console.log(i); //第三步（1）（如果符合函数：i % 4 === 0，输出相应值，；如果不符合， 输出当值，继续执行第三步（2）） &#125; continue 12345for(var i = 1; i&lt; 10; i++)&#123; if(i % 4 === 0)&#123; continue; //如果符合函数条件：i % 4 === 0，那么则直接退出本循环，不输出（跳过） 此次结果，继续执行i&lt; 10这个条件的循环 &#125; console.log(i); &#125; 三、循环语句：while和do-while1、while循环 先条件判断，后执行 while 语句，属于前测试循环语句，也就是在循环体内的代码被执行之前，就会对条件求值，不符合的话就不会执行（1）语法：123while(expression)&#123; statement; &#125; （2）例子：1234var i = 10; while(i &gt; 0)&#123; console.log(i); i--; &#125; 2、do-while循环 先执行，后条件判断 do-while是后测试循环语句，在出口条件判断之前就会执行一次代码语法：123 do&#123; statement;&#125;while(expression); 例子：12345var i = 4; do&#123; console.log(i); i--; &#125;while(i &gt; 5); --&gt;4 3、for循环（1）for语句，前测试循环语句。具备在执行循环代码以前初始化变量和定义循环后要执行代码的能力，改造一下while语句A、语法：123for(var i = 10; i &gt; 0;//第一步 i-- //第三步)&#123; console.log(i);//第二步 &#125; （2）for-in语句for-in是一种迭代语句，用于枚举对象的属性A、语法：123 for(property in object)&#123; statement &#125; B、例子：123for(var prop in window)&#123; console.log(prop); &#125; 因为ECMAScript规定对象中的属性没有顺序，所以for-in遍历出来的属性的顺序也不是固定的（虽然大部分浏览器是按属性名称排序，我们不能依赖这个） 四、label语句label语句是很多熟练的jser都会忽略的知识，我们可以为代码添加标签，方便后续使用。label语句单独使用的时候没有什么作用几乎，经常和其它语句结合使用。 1、语法：1labelname: statement; 2、例子：1234567var a = 1, b = 2, c = 3, d = 4, e = 5, f = 6; a:b:c:d:e:f:7;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>判断语句</tag>
        <tag>流程控制判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：01数据类型、运算符、运算符优先级]]></title>
    <url>%2F2018%2F08%2F16%2F22-01%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%3A%E8%BF%90%E7%AE%97%E7%AC%A6%3A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言：最近在学习javascript中数据类型、运算符，以及运算符优先级等相关基础知识，相对简单、基础但也很重要。加上老师的推荐看了阮一峰老师所写的《javascript教程》。从中刷新了过往认知的概念和固有的规则，明白了javascript的出现会打破以往的惯性思维。在这里1+1不再一定等于2，你常见的算数符号也不是你通常认为的那种作用，一个数字可以是表达式，同时一个表达式也是一个值。。。所以学习这样一种新知识，你要学会先接受，然后敢于去打破自身的思维惯性，之后才能勇于迎接更多挑战。 自我总结：值===数据类型——转化为：数值（number）/字符串（string）/布尔值（boolean）/undefined/null/对象（object）——转为Nan或者数字（其中：（1）数字+undefined===Nan （2）null===(undefined===Nan ) ——判断布尔值true or false 一、基本语法1、调试打开chrome开发工具：右键——检查——console（esc键调取另一个console） Win F12 Mac Command + Option + I 2、语句（1）语句 VS 表达式A、区别： 语句，主要为了进行某种任务而进行的操作，一般情况下不需要返回值； 表达式，为了得到返回值的计算式，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式 B、例子： 赋值语句：var a = 1 + 3; //先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a 表达式：1 + 3 （2）分号分号前面可以没有任何内容，JavaScript引擎将其视为空语句。;;;A、语句，以分号结尾。一个分号就表示一个语句结束。多个语句可以写在一行内。不需要加分号，换行默认上一行为语句。123456var a = 1 + 3 ; var b = &apos;abc&apos;; /*或*/var a = 3 var b = 4 var c = a+b B、表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。下面两行语句有返回值，但是没有任何意义，因为只是返回一个单纯的值，没有任何其他操作。121 + 3; //语句，但无任何意义 &apos;abc&apos;; 如图： 3、变量（1）定义最前面的var是变量声明命令。它表示通知解释引擎，要创建一个变量a（相当于申请了1个内存放在变量a这里）。变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。如：var a = 1; （2）变量提升A、定义：变量提升（hoisting），即JavaScript引擎的工作方式是：先解析代码获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有变量的声明语句，都会被提升到代码的头部，如：1234567891011//假设 var a = 1/*这里会产生一个变量提升*/var a ;a =1;/* 或*/a = 3var a/* 控制台显示并不会报错，只要有var变量命令的声明，默认情况下就会自动提升到最前面，之后再作赋值*/ 总结： 变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。 B、说说变量提升的几种场景第1种场景：1console.log(a); var a = 1; 代码首先使用console.log方法，在控制台显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为有var存在，即也存在变量提升，引擎中真正运行的是下面这段代码：1var a; console.log(a); a = 1; 最后的结果是显示undefined，表示变量a已声明，且位于最前面，但还未赋值。注： 这种变量提升的技巧很重要，与之后函数作用，复杂函数执行时所出现的一些情况都可解释 第2种场景：console.log(b); b = 1;语句将会报错，提示“ReferenceError:b is not defined”，即变量b未声明，这是因为b不是用var命令声明的，JavaScript引擎不会将其提升，而只是视为对顶层对象的b属性的赋值。 4、标识符（1）定义：标识符（identifier），用来识别具体对象的一个名称。最常见标识符：变量名、函数名。注： JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 （2）标识符命名规则A、第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。B、第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。C、一些命名实例： 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript有一些保留字，不能用作标识符： arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield 三个词具有特别含义，也不应该用作标识符： 123InfinityNaNundefined 5、注释：123456789// 这是单行注释/* 这是 多行 注释*///历史上JavaScript兼容HTML代码的注释，所以&lt;!--和--&gt;也被视为单行注释。x = 1; &lt;!-- x = 2;--&gt; x = 3; 6、区块（1）定义 JavaScript使用大括号，将多个相关的语句组合在一起，称为区块（block）。（2）与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。即区块中的变量与区块外的变量，属于同一个作用域。如：1234&#123; var a = 1;&#125;a // 1 二、数据类型1、定义JS语言的每一个值，都属于某一种数据类型。 2、值所属的数据类型分类JavaScript 的数据类型，共有6种： 注： ES6 又新增了第七种 Symbol 类型的值（1）数值（number）：值为整数和小数（比如1和3.14）（2）字符串（string）：值为字符组成的文本（比如&quot;Hello World&quot;）（3）布尔值（boolean）：值判定为true（真）和false（假）两个特定值 注： 用于询问的便可用boolean进行变量命名,如：var isBoy = true （4）undefined：值判定为未处理，未定义或不存在。目前未定义所以此处暂时没有任何值，但之后可以去放东西。注： 一个变量没有赋值，只能是undefined，不会是null （5）null：值为表示经过处理之后的无值，即此处的值就是“无”的状态。 （6）对象（object）：或称“引用类型”，各种值组成的集合。对象=属性+值对象又可以分成三个子类型： 狭义的对象（object） 数组（array） 函数（function） 3、typeof 运算符（用来确定值所属的数据类型）（1）三种运算符用来确定数据类型运算符，用于连接简单表达式，组成一个复杂的表达式（即通过一个关键字，后面加一个变量或值，得出一个结果） JavaScript有三种方法，可以确定一个值到底属于什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 （2）作用用typeof可以判断一个变量或可以返回一个值为哪种数据类型，如：※数值、字符串、布尔值分别返回number、string、boolean。1234//数值、字符串、布尔值分别返回number、string、boolean。typeof 123// &quot;number&quot;typeof &apos;123&apos;// &quot;string&quot;typeof false// &quot;boolean&quot; ※函数返回function。12345function f()&#123;&#125;typeof f// &quot;function&quot; ※ undefined返回 undefined12typeof undefined// &quot;undefined&quot; ※ 利用这一点，typeof用来检查一个没有声明的变量，而不报错。如代码中变量v没有用var命令声明，直接使用就会报错；但放在typeof后面就不报错了，而是返回undefined。12345v// ReferenceError: v is not defined typeof v// &quot;undefined&quot; ※实际编程中，变量v要用var命令声明，这个特点通常用在判断语句。12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; ※除此以外，其他情况都返回object。12345//除此以外，其他情况都返回objecttypeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot;typeof null // &quot;object&quot; 实际操作中： 如何判断一个变量是否为函数？ 4、布尔值（1）作用布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。（2）下列运算符会返回布尔值A、两元逻辑运算符：&amp;&amp;(And)，||(Or)B、前置逻辑运算符：!(Not)C、相等运算符：===，!==，==，!=D、比较运算符：&gt;，&gt;=，&lt;，&lt;=如：4&gt;3--&gt;true （3）如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六种值被转为false，其他值都视为true。 undefined –&gt;false null –&gt;false false –&gt;false +0，-0，NaN –&gt; false【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含&quot; &quot;空白字符串）为true】 A、关于&quot;&quot;或&#39;&#39;（空字符串）布尔值往往用于程序流程的控制，如：12345if (&apos;&apos;) &#123; console.log(true);&#125;/* 没有任何输出*//*上面代码的if命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出*/ B、空数组（[]）和空对象（{}）对应的布尔值，都是true。如：123456789if ([]) &#123; console.log(true);&#125;// trueif (&#123;&#125;) &#123; console.log(true);&#125;// true 三、数据类型转换解密 总结：js的数据类型如何判断，即任何表达式先转字符串再转数字 1、if判断（1）js如何转换判断从面试题说说if的数据类型：1234567891011121314151617181920212223242526272829303132// 题目1：如下代码输出什么?if (&quot;hello&quot;) &#123; console.log(&quot;hello&quot;)&#125; //true// 题目2：如下代码输出什么?if (&quot;&quot;) &#123; console.log(&apos;empty&apos;)&#125;//空字符串，代表里面什么都没有 //false// 题目3：如下代码输出什么?if (&quot; &quot;) &#123; console.log(&apos;blank&apos;)&#125;//空白字符串，仍然代表一个值，只不过是空值 //true// 题目4：如下代码输出什么?if ([0]) &#123; console.log(&apos;array&apos;)//对象 true&#125;if（[]）&#123; console.log(&apos;hahah&apos;)&#125; //特殊对象 true// 题目5：如下代码输出什么?if(&apos;0.00&apos;)&#123; console.log(&apos;0.00&apos;)&#125; //字符串（除空字符串外）trueif（+0.00）&#123; console.log(&apos;hahah&apos;)&#125; //false （2）判断原理：对于if（）里括号的表达式（如以下），会被强制转换为布尔类型 undefined –&gt; false null –&gt;false false` –&gt;false +0，-0 ，NaN –&gt;false 【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含” “空白字符串）为true】 2、==判断（1）js处理 ==的表达式 判断1234567891011121314151617181920212223242526&quot;&quot; == 0 //题目1 &quot;&quot;空字符串===false===0 0==0 //true&quot; &quot; == 0 //题目2 Number(&apos; &apos;)--&gt;0===false 0==0 //true&quot;&quot; == true //题目3 0===1 //false&quot;&quot; == false //题目4 0===0 //true&quot; &quot; == true //题目5 false===0 0==1 //false!&quot; &quot; == true //题目6 &quot; &quot;空白字符串===true !0===false===0 0不等于true //false!&quot; &quot; == false //题目7 false==false //true*&quot;hello&quot; == true //题目8 字母字符串===Nan Nan不等于1 //fasle*&quot;hello&quot; == false //题目9 字母字符串===Nan Nan不等于0 //fasle&quot;0&quot; == true //题目10 &quot;0&quot;（数字字符串）===0不等于1 //false&quot;0&quot; == false //题目11 &quot;0&quot;（数字字符串）===0===0 //true&quot;00&quot; == false //题目12 &quot;00&quot;（数字字符串）===00===0 //true&quot;0.00&quot; == false //题目13 &quot;0.00&quot;（数字字符串）===0===0 //trueundefined == null //题目14 undefined===Nan===null //true&#123;&#125; == true //题目15 &#123;&#125;===object（没有字符串）不等于true //fasle[] == true //题目16 []（空数组）===object（没有字符串）不等于true //faslevar obj = &#123; a: 0, valueOf: function()&#123;return 1&#125; &#125; obj == &quot;[object Object]&quot; //题目17 //falseobj == 1 //题目18 //trueobj == true //题目19 //true （2）判断原理两图对照，就能判断表达式的数据类型： 四、运算符1、作用：运算符，主要用于连接简单表达式，组成一个复杂的表达式如typeof，为运算符。即typeof 100 === &#39;numeber&#39; 是一个值为字符串&#39;numeber&#39;的表达式再如： 3 ： 表达式 3+4：表达式+ :为运算符 （1+2）*5：表达式。+和* : 均为运算符 2、判断参考标准：（1）有些操作符对不同的数据类型有不同的含义，比如+,在两个操作数都是数字的时候，会做加法运算 （2）两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串,做字符串拼接 （3）在参数有对象的情况下会调用其valueOf或toString的函数（两者同时使用，注意优先级） （4）在只有一个字符串参数的时候会尝试将其转换为数字 注： 如果字符串无法转换成数字，那么则转换失败，通常结果为：Nan （5）在只有一个数字参数的时候返回其正数值12345678console.log(2+4); //6 加法运算console.log(&quot;2&quot;+&quot;4&quot;); //&quot;24&quot;为字符串 字符串的拼接console.log(2+&quot;4&quot;); //&quot;24&quot; 一个数字+字符串，会把数字转化成字符串，然后再进行拼接，不是一个连读的数字24，而是2和4的分开读console.log(2+new Date());//&quot;2Mon Jan 20 2014 17:15:01 GMT+0800 (China Standard Time)&quot;/* 一个数字+一个对象，会调用这个对象的valueOf或toString这个方法*/console.log(+&quot;4&quot;);//4 3、常见类型： 算数表达式 比较表达式 逻辑表达式 赋值表达式 单目运算符 关键字作为运算符，如typeof、delete、instanceof等 （1）算数表达式A、加法运算符（Addition）：x + yB、减法运算符（Subtraction）：x - yC、乘法运算符（Multiplication）：x * yD、除法运算符（Division）：x / y加减乘除的运算，这里会尽可能将字符串转化成数字，如果转换不了数字，则会得出Nan这个结果 E、余数运算符（Remainder）：x % y 用于循环语句 F、自增运算符（Increment）：x ++或者++x x++,由简单表达式（x）和运算符（++）组成一个复杂的表达式，一个表达式本身整体，就是一个值，那么x++的值就是x的原始值; x++，作为表达式的结果是是它自己本身，同一作用域中的下一个变量，则是x++内部又自增了1，即x=x+1 注： x++：是自增前x的原始值 ++x：是自增后下一个x变量的值如： 而++ e则是自增后的那个值，图1所示，自增+1的e ===10，那么++e === 11 自减运算符（Decrement）：--x或者 x--同上可得 求负运算符（Negate）：-x 数值运算符（Convert to number）：+x （2）赋值运算符1234567891011x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y （3）比较运算符比较运算符比较两个值，然后返回一个布尔值（实际上是ture或false），表示是否满足比较条件。JavaScript提供了8个比较运算符。A、= 赋值= 为赋值运算符，连接两个简单的表达式构成复杂的表达式，如x=y即为表达式，若将其看成一个整体，即会输出一个值，这个值则为最终赋的值，如： B、== 相等这里的相等是，近似相等，后台得到的值则是ture或者false如数字和字符串的比较，后台会将字符串做一个类型转换： C、===严格相等这里的相等则更严格，值和类型的严格相等 题外话： === VS == ===叫做严格运算符 == 叫做相等运算符 关于这两者的区别我在知乎上看到一篇文章：Javascript 中 == 和 === 区别是什么？ a、严格运算符的运算规则如下：(1)不同类型值如果两个值的类型不同，直接返回false。(2)同一类的原始类型值同一类型的原始类型的值(数值、字符串、布尔值)比较时，值相同就返回true，值不同就返回false。(3)同一类的复合类型值两个复合类型(对象、数组、函数)的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。(4)undefined和nullundefined 和 null与自身严格相等。12null === null //trueundefined === undefined // true b、相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如~下:(1)原始类型的值原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值，所以题主的问题中会有第二个string输出。(2)对象与原始类型值比较对象(这里指广义的对象，包括数值和函数)与原始类型的值比较时，对象转化成原始类型的值，再进行比较。(3)undefined和 nullundefined和null与其他类型的值比较时，结果都为false, 它们互相比较时结果为true。(4)相等运算符的缺点相等运算符隐藏的类型转换，会带来- -些违反直觉的结果。123456789== &apos;0&apos; // false0 == // true0 == // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; //truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true 这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。 1234567891011121314151617 var a = undefined;if(!a)&#123; console.log(&quot;1&quot;); &#125;//1 var a = undefined;if(a == null)&#123; console.log(&quot;1&quot;); &#125; //1 var a = undefined;if(a === null)&#123; console.log(&quot;1&quot;); &#125; // 无输出 也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。D、 != 不相等E 、!== 严格不相等F、 &lt; 小于G、 &lt;= 小于或等于H、 &gt; 大于I 、 &gt;= 大于或等于 （5）布尔运算符A、! 取反运算符B、&amp;&amp; 且运算符表达式&amp;&amp;表达式 会自动地转化成ture或者false 进行比较。或判断一个东西是否存在，是否满足条件C、|| 或运算符初始化赋值的时候可用 题外话：&amp;&amp; 且 运算符 VS ||或 运算符a、且——&amp;&amp; ：用于判断一个东西是否存在，或是否满足条件（有false就判断）如果第一个为true，第二个也为true，最终值就是第二个值；如：var a = “hello”，那么a&amp;&amp;console.log（a）就能进行判断，第二个值的最终结果为true 如果第一个为true，再看第二个是否为false，那最终的值就是为第一个值； 如果第一个为false，那就不用再判断第二个，就是第一个值总结： 如果是false就不用再看了；如果有true，再看第二个 b、或——||: 用于初始化值如果第一个为true，后面就不用再管；如果第一个为false，再看第二个总结： 如果是true，就不会再管了；如果有false，再看第二个。只要一项为真，那就不用管,如：第二个cc为undefined，转化为Boolean类型为false，||中还会看第二个，0为true，那么结果就为0。将0赋值给第一个cc，那么cc则有了初始值。假如cc=100，再执行cc=cc||0，那么cc仍然等于100，转换为boolean类型为true，那么则不需要在看第二个数如果cc之前没有声明的话，得到的是一个默认值；如果cc之前声明过，值还保持不变。 D、condition? true case : false case三元条件运算符题外话： 三目运算符 Condition？true case：false case这里有一个条件判断，如果条件判断为真的话，那么整个表达式的结果就是true case执行的结果；如果条件判断为假的话，那么整个表达式的结果就是false case执行的结果，当然，false case还是会再做一些执行，如：123456if (a &gt; 10) &#123; b = a&#125; else &#123; b = a - 2&#125; 答：b = a&gt;10? a : a-2 （5）位运算符必要时看看二进制转换对照表也行：二进制转换对照表 A、或运算（or）：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。B、与运算（and）：符号为&amp;，表示两个二进制位都为1，则结果为1，否则为0。C、否运算（not）：符号为～，表示将一个二进制位变成相反值。D、异或运算（xor）：符号为ˆ，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。E、左移运算（left shift）：符号为&lt;&lt;F、右移运算（right shift）：符号为&gt;&gt;J、带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; （6）其它运算符（考虑优先级）A、小括号在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。B、voidvoid运算符的作用是执行一个表达式，然后返回undefined。C、逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。如： 五、运算符优先级和结合性1、定义结合性是指多个具有同样优先级的运算符表达式中的运算顺序 2、实践——理论：（1）有的运算符是左结合的，即运算从左到右执行，下面两个运算是一样的12w = x + y + z;w = (x + y) + z; （2）有的运算符是右结合的1234w = x = y = z;w = (x = (y = z));w = a: b: c ? d : e? f : g;w = a? b : (c? d: (e? f : g)); 如： 最高：typeof 最低：， 3、理论——实践 几个优先级从高到低： typrof （） ++ -- ！ +-*% &amp;&amp; || = （1）typeof的优先级相当的高，比加减乘除都优先，所以虽然是操作符，但在复杂表达式的时候我们还是习惯加括号，如：123typeof 2*3;//NaNtypeof (2*3);//&quot;number&quot;typeof 2+3;// &quot;number3&quot; 题外话： NanN（即not and number）定义：是一个数字类型，不过它不是一个有效的数，表示为错误数字。通过number函数可以把一个数字的字符创转化成数字，不过无法将一个字母的字符串转化成数字，得出结果为NaN。当NaN===NaN—&gt;false，一个数字与自己不相等，作为一个数字，二者对等与否对方均无从得知，没有突出一个数字的识别性。如： （2）++、--是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;//, 忽略第一个操作数，返回第二个操作数 L(往左运算）a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 （3）赋值运算符的优先级相当的低a = b == c; //等同于a = (b==c) （4）逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除!2*0; //0, 等价于(!2)*0 （5）一个关于逻辑运算符的有意思地方是其“短路”功能，会结合表达式计算值来判断1231 &amp;&amp; 3;1 &amp;&amp; &quot;foo&quot; || 0;1 || &quot;foo&quot; &amp;&amp; 0 如：]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
        <tag>运算符</tag>
        <tag>运算符优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello，JS：00了解JS（包括白屏和fouc）]]></title>
    <url>%2F2018%2F08%2F16%2F21-00%E4%BA%86%E8%A7%A3JS%EF%BC%88%E5%8C%85%E6%8B%AC%E7%99%BD%E5%B1%8F%E5%92%8Cfouc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：开始学javascript了，其实觉得CSS还有很多没学透，也没学完，:-( o(TωT)o ╭(╯^╰)╮哭唧唧啊~所以CSS学好并不简单呐，需要大量地试错练习啊！！！过后，我还是会继续配合大量实际项目去更新CSS知识。学习js，我是听着老师的课，再结合阮一峰js教程一起看，同样是适合前端新手使用的js手册，通俗易懂。 一、网页的构成 网页 = Html+CSS+JavaScript Html: 网页元素内容 CSS: 控制网页样式 JavaScript：操作网页内容，实现功能或者效果 浏览器端（web应用）、服务端（nodejs）。。。 二、JavaScirpt 发展历史 参考：阮一峰js标准教程 1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版。 1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape网景公司的注册商标，微软不能用），首先内置于IE 3.0。 1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织ECMA（European Computer Manufacturers Association），希望JavaScript能够成为国际标准，以此抵抗微软。 1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。基本上，JavaScript这个名字的原意是“很像Java的脚本语言”。在JavaScript语言中，函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与Java语法最大的两点区别。JavaScript语法要比Java自由得多。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6； 2006年，jQuery函数库诞生，作者为John Resig。jQuery为操作网页DOM结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让JavaScript语言的应用难度大大降低，推动了这种语言的流行。 2009年，Node.js项目诞生，创始人为Ryan Dahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。 2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScipt程序，都可以不经修改地在TypeScript中运行。同时，TypeScript添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成JavaScript运行。 2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发。 2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。 三、JS引入使用12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;标题&lt;/title&gt; /*这里引入css代码*/ &lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; /*一般来说，这里引入js代码*/ &lt;script src=&quot;index.js&quot;&gt;/*空*/&lt;/script&gt; 或 &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; *四、浏览器渲染机制你所看到的浏览器网页，浏览器是经历了什么你才能看到？ 解析 HTML 标签, 构建 DOM 树 ⏬ 解析 CSS 标签, 构建 CSSOM 树 ⏬ 把 DOM 和 CSSOM 组合成 渲染树 (render tree) ⏬ 在渲染树的基础上进行布局, 计算每个节点的几何结构 ⏬ 把每个节点绘制到屏幕上 (painting) 当发一个请求到服务器之后，服务器会把页面上的html发给浏览器，浏览器收到之后则会解析该html标签，解析的过程中遇到了类似需要加载的样式，如link，则会再次发送请求到服务器。这样一来，如此循环，标签属性的请求不断被发出到服务器，资源不断被获取资源获取之后，如何被用户看见？ 首先，先对html标签进行解析。解析成一个dom树（即类似于树状结构，dom，即文档、模型）同时，也对css样式进行解析，同时也解析成cssom树，将css样式（默认+添加）汇聚一起形成css树——dom树元素和css树元素结合起来获得一个对象，该对象所拥有的元素和具体位置都有其相互关系，对应节点和对应数据形成一个渲染树——执行layout（布局）计算它的位置和样式——绘制——排列形成页面 五、浏览器引起的Repaint 和 Reflow问题1、Repaint问题：重新绘制。将css样式改变的话，其他元素并未改变，只需要重新绘制某一处就行。 2、Reflow问题：重新回流，重新计算。即自身位置发生变化，给其他元素带来了影响，要重新进行计算。 从一个外网中截取出来的关于Repaint 和 Reflow分辨片段： Anything that changes input information used to construct the rendering tree can cause a repaint or a reflow, for example:Adding, removing, updating DOM nodesHiding a DOM node with display: none (reflow and repaint) or visibility: hidden(repaint only, because no geometry changes)Moving, animating a DOM node on the pageAdding a stylesheet, tweaking style propertiesUser action such as resizing the window, changing the font size, or (oh, OMG, no!) scrollin Let’s see a few examples: 1234567891011121314var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; // another reflow and a repaintbstyle.color = &quot;blue&quot;; // repaint only, no dimensions changedbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint/* new DOM element - reflow, repaint */document.body.appendChild(document.createTextNode(&apos;dude!&apos;)); 六、白屏和FOUC1、即指影响浏览器页面加载顺序的两种场景 白屏：特指一种场景，打开页面是一片白色，突然页面出现，样式正确。那么一片白色的时间，则称之为白屏。 FOUC (Flash of UnstyledContent)：无样式内容闪烁，网速情况差，打开页面时仍有样式，之后样式时有时无，甚至一开始并无出现样式，突然样式恢复。（常出现在firefox浏览器）此类现象，在不同浏览器进行的资源加载和页面渲染时，所采用的不同的处理方式，并不是bug。 2、写一个server，验证白屏和fouc效果在index.html中12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;fouc &amp; 白屏&lt;/title&gt; &lt;!--在下面模拟一个延时装置--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt; //设置这个工具，当请求该文件时，服务器会延迟请求10s再去加载这个资源，以此可以模拟一个网速特别慢的情况 &lt;link rel=&quot;stylesheet&quot; href=&quot;a.css?t=3&quot;&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;饥人谷&lt;/p&gt;&lt;!-- &lt;script src=&quot;A.js?t=5&quot;&gt;&lt;/script&gt; --&gt; &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/15/1653c442f35af77c?w=211&amp;h=200&amp;f=png&amp;s=8004&quot; alt=&quot;&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;c.css?t=6&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;http://a.jrg.com:8080/B.js?t=4&quot; &gt;&lt;/script&gt; &lt;script src=&quot;http://b.jrg.com:8080/A.js?t=8&quot; &gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; （1）关于白屏，需要注意的是，浏览器对于样式和js的处理，即CSS和JS放置顺序。推荐：将样式放在 head里面,将JS放在body内部下方。如上面代码所示，html页面里引入了两个css：a.css和b.css。b.css引用了c.ss（@import&quot;./c.css?t=5&quot;;）b.css中加入了一个10s的延时文件（&lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt;），加载这个10s的css样式文件，浏览器是如何完成加载工作，有两种方式：第1种： html解析完成，此时10s延时的css文件先不管，先展示body里所展示的内容，等css文件全加载后再去计算样式，再去重新渲染一次；第2种： 即使html的dom树已经解析、渲染都完成，对未加载完成的样式都必须等待，即css样式要全部加载、获取，img资源加载完成，此时底部JS立刻执行，才一次性展示出页面。例子中展示这种方法，即为白屏很久的原因。 （2）不同浏览器的不同处理机制所出现的场景不同A、白屏场景（常出现在chrome）：打开一个国外网站，使用国外服务器，嵌在css的字体使用的是谷歌字体，运行特别慢，等了好久突然出现页面样式效果。这是因为页面需要等待css样式加载所有完成，甚至出现404加载失败，最后才展示出页面。那么那段加载时间，等待了几秒左右的白色一片的页面，就是白屏B、Fouc场景（常出现在Firefox）：一开始的时候，先让你看见样式，如字的小号样式，样式加载完后看到所规定字号的大字。对用户来说，同样的样式，突然从小变大，则这个场景就是Fouc（无样式内容闪烁）。总结： 不管是css样式，还是js文件，只要加长延时，都会造成白屏 （3）CSS 和 JS 最佳放置顺序 使用 link 标签将样式表放在顶部 将JS放在底部（3.1）场景：假设JS文件页面顶部： JS脚本会阻塞后面内容的呈现 JS脚本会阻塞其后组件（如图片）的下载 JS加载时间过长，css需等待，则会出现一段时间白屏 场景说明：引入一个JS文件在顶部，设置一个延时时间。 加载顺序：css—js—img—全部获取到展现页面效果此时，img和css加载时会并发加载，即如一个域名下同时加载两个文件（并发是有限度的），加载在顶部的js时，会禁用并发img和css，并阻止其他内容下载和渲染。 js并不影响css加载，但是会影响css样式的一个计算。当js加载时，css已经获取到（不过此时页面还是一片空白），直到js获取立即执行后，图片立刻出现，页面才展示效果。所以js文件放入页面顶部head里，也会导致白屏现象出现 （3.2）JS加载特点总结A、优先加载js文件，加载后js立刻去执行，展示页面（CSS样式则是全部加载完，然后一次性展示出页面）注： css放前面，优先加载； 若放后面，其他资源则会阻碍css加载，那么时机就太晚。 B、由于渲染线程和js脚本线程是互斥的，白屏是渲染进程被阻塞的原因，当碰到script标签的时候，会先执行js脚本，然后再渲染。 （放顶部时）JS加载时机过晚导致一系列问题，脚本会阻塞后面内容的呈现、脚本会阻塞其后组件的下载（主要指img资源下载）、白屏等。 （放底部）则可以先让其他先加载完成，JS立刻执行的特点可以“扫尾”最后的页面效果 C、JS脚本操作页面上的html+css元素，（放顶部时）JS先执行，元素都未加载到（即不存在），未出现在文档流中【加载，这里指资源加载和资源是否出现在文档流中】，所以也不能操作相应JS功能，此时后台将会报错。D、（放顶部时）其他JS若作为一种框架语言，则能提前形成一个初步的框架有效构成页面结构。 七、JS脚本的异步加载1、一个问题？即一个放在head的js文件，如下：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;原本放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载呢？ 2、解决方法：async和defer（1）作用：没有 defer 或async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。也就是说，使用defer或async后能够改变这种加载、执行的时机。常应用在引用了广告和统计的页面中，不会影响、堵塞，更不会影响到到页面其他元素 （2）asyncHTML5里为script标签里新增了async属性，用于异步加载脚本：不保证顺序（独立的个体）&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;浏览器解析到HTML里的该行script标签，发现指定为async，会异步下载解析执行脚本（即加载后续文档元素的过程将和script.js的加载并行进行）。 页面的DOM结构里假设&lt;script&gt;在img之前，如果你的浏览器支持async的话，就会异步加载脚本。此时DOM里已经有img了，所以脚本里能顺利取到img的src并弹框。 （3）deferscript标签里可以设置defer，表示延迟加载脚本：脚本先不执行，延迟到文档解析和显示后执行，有顺序&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;浏览器解析到HTML里该行script标签，发现指定为defer，会暂缓下载解析执行脚本，等到页面文档解析并加载执行完毕后，才会加载该脚本（更精确地说，是在DOM树构建完成后，在DOMContentLoaded事件触发前，加载`defer`的脚本）。 页面的DOM结构里假设script在img图片之前，如果你的浏览器支持defer的话，就会延迟到页面加载完后才下载脚本。此时DOM里已经有img元素了，所以脚本里能顺利取到img的src并弹框。 总结： JS实质采用一种可以更自由地选择加载时机和任何位置，让处于顶部的js文件能够像在底部时，在页面必要元素加载完成时进行“异步”加载。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS历史</tag>
        <tag>白屏和fouc</tag>
        <tag>异步加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07你认真学了css？伪类和伪元素]]></title>
    <url>%2F2018%2F08%2F16%2F20-07%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[文档阅读：总结伪类与伪元素 | AlloyTeamwww.alloyteam.com! 前文回顾：#00你认真学了css？ 一、伪类：1、定义伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化 2、类型 3、应用场景用伪类元素进行效果展示（1）link visited hover active 顺序123456789/* 未访问的链接 */ a:link&#123; color: blue; &#125; a:visited&#123; color: green; &#125; /* 点击后鼠标脱离，获得焦点的链接 */ a:focus&#123; color: grey; &#125; /*鼠标悬停时，内容颜色获得红色 */ a:hover&#123; color: red; &#125; /*选择活动链接*/ a:active&#123; color: pink; &#125; （2）first-child VS first-of-type h1:first-child :选择是h1并且它是长子的元素 h1:first-of-type:选择是h1并且它是它父亲里h1类型中的长子的元素 关于first-childVSfirst-of-type的使用在之前的css系列博客文章中有详细解释：#00你认真学了css？ 二、伪元素1、定义伪元素用于创建一些不在文档树中的元素，并为其添加样式 2、类型如： 3、:before 和 :after（也可以写::before和 ::after）1234567891011&lt;div class=&quot;box&quot;&gt; &lt;p&gt;这是第一段&lt;/p&gt; &lt;/div&gt; &lt;style&gt; .box:before&#123; content: &apos;start&apos; &#125; .box:after&#123; content: &apos;end&apos; &#125; &lt;/style&gt; 使用伪元素before和after的好处： 可以在后台发现，p的前后分别出现::before和::after。html的dom树中原本没有::before和::after，现通过css样式添加，使其在dom树中添加这两个元素。 用添加::before和::after的目的是为了省标签。::before生成的效果，所在的位置位于父元素（如box）的第一个子元素，::after则位于父元素（如box）的最后一个子元素，即在html的dom树上多了两个子元素，这两个子元素无需在html中体现，只需在css中表示即可。 ::before和::after所展示的效果相当于一个行内元素（注意行内元素的一些特性） 其中content是必不可少 4、伪类选择器的应用场景（1）伪类选择器应用于清除浮动12345.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; 详细解释请回看之前我写得关于浮动的副作用和解决办法：#03你认真学了css？（基本样式3：浮动+定位） （2）伪类选择器可作为替代标签用代码替代图片，如使用css3实现一个带边框的三角符。思路：边框+三角符号的组合，先确认边框样式：12345678910111213.bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 再确认三角样式：1234567891011121314151617.bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; position: absolute; transform: rotateZ(45deg); top: -6px; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 这里基础的三角样式我们在之前已经有涉及过怎么使用：请戳🔽#01你认真学了css？（基本样式1） 使用伪元素怎么实现三角符号(css3)：基础代码：（关于三角形的位置参数可以使用页面后台进行调试）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125; .bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; transform: rotateZ(45deg); position: absolute; top: -6px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果：运用以上知识举一反三，实现以下效果： 代码请戳：我的代码 （3）伪类选择器应用于element：checked;（勾选住的一个状态）即input元素的自定义重要属性checkbox或者radio，实现一个自定义的样式。如：笑脸切换12345678910111213141516171819202122/*今天的心情:*/ &lt;input type=&quot;checkbox&quot;&gt;&lt;style&gt;input[type=checkbox]&#123; -webkit-appearance: none; /*去掉未勾选的方框默认样式*/ appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/b6dcd011-23cc-4d95-9e51-9f10100103bd.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; /*背景图片的大小*/ vertical-align: middle; outline: none; &#125; /*勾选之后的状态*/ input[type=checkbox]:checked&#123; -webkit-appearance: none; appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/538f26f0-6f3e-48d5-91e6-5b5bb730dd19.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; vertical-align: middle; &#125; &lt;/style&gt; 好处： 没有加js 使用该属性样式，对于input来说已经实现勾选状态，自定义加一些自己的图片，自动加载信息 （4）伪类选择器应用于字体图标A、为什么针对字体库而来的字体，我们可以调整它的字体大小和颜色？B、完整代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_nyta5x5h650cnmi.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;iconfont icon-jirengulogojichu2&quot;&gt;&lt;/span&gt; &lt;style&gt; .iconfont&#123; font-size: 100px; color: red; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 在css中添加这个:12/* \e605为字体库中的特有的一种编码形式：unicode码 */.icon-jirengulogojichu2：before&#123;content:&apos;\e605&apos;;&#125; 即：]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>伪类</tag>
        <tag>伪元素</tag>
        <tag>伪类选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-2你认真学了css？布局套路]]></title>
    <url>%2F2018%2F08%2F16%2F19-06.2%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%E5%B8%83%E5%B1%80%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、两种布局使用分析 float布局（定宽布局） flex布局（弹性布局） 二、原则 不到万不得已，不要写死width 和 height 尽量用高级语法，如 calc、flex 如果是 IE，就全部写死 三、布局套路口诀（上） 👉PC端布局1、导航条布局——float布局（适用于ie5） a.儿子全加 float: left （right）;b.老子加 .clearfix 代码如下：Float布局12345678910111213141516171819202122232425262728293031&lt;style&gt; .parent&#123; border:1px solid green;&#125; .child&#123; /* border:1px solid red; */&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125;.clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125;.content&#123; border:1px solid black; margin-right:10px;&#125;&lt;/style&gt;&lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子1&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子2&lt;/div&gt; &lt;/div&gt; 如图：该页面展示上其实是弹性布局定死宽度，水平居中则在老子这边动手，添加以下代码：123456789101112131415 .parent&#123; border:1px solid green; width:1000px margin-left:auto margin-right:auto&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125; 如图：定宽之后，页面宽度仍有剩余优化之后的导航条，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt; .parent&#123; margin-left:auto; margin-right:auto; background: #ddd; /*定死宽度则不会影响页面 */ min-width:600px; &#125; .child&#123; &#125; .child:nth-child(1)&#123; width:100px; background-color:#333; color: white; text-align:center; line-height:36px; height:36px; &#125; .child:nth-child(2)&#123; &#125; /* 清除浮动 */ .clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125; .clearfix&#123; zoom: 1; &#125;/*IE6*/ .content&#123; border:1px solid black; margin-right:10px; &#125; .nav&#123; line-height:24px; padding:6px 0; &#125; .navItem&#123; margin-left:20px; &#125; &lt;/style&gt; &lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;logo&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:right;&quot;&gt; &lt;div class=&quot;nav clearfix&quot;&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航1&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航2&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航3&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航4&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2、图片位布局——flex布局 a.给老子加 display: flexb.给老子加justify-content: space-between; 先看看第1种场景：实现方式：先不用flex布局，用浮动元素+margin+clearfix清除浮动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style&gt;/* 图片主要部分 */.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px; &#125;.pictures&#123; width:800px; margin:0 auto;/*不能删1：居中*//* background: black;最底层的颜色 */&#125;.picture&#123; width:194px; height:194px; background:#ddd; margin:4px; float:left;&#125;.pictures &gt;.xxx&#123; /*为什么不能只用两层div*//* background: rgba(255,0,0,0.8);倒数第二层颜色 */ margin-left:-4px; margin-right:-4px;/*不能删2：扩大范围*/&#125;/* .picture:nth-child(1)&#123; margin-left: 0;&#125;.picture:nth-child(4)&#123; margin-right: 0;&#125; */&lt;style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx clearfix&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图：这种方式可以兼容IE6，且即使减少一个板块也不会影响其它板块，如图： 再看第2种场景：实现方式：flex布局12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ justify-content: space-between;/* 多余空间放在空间或水平居中 */ /* align-items: center; 垂直居中 */&#125;.picture&#123; width: 194px; height: 194px; background: #ddd; margin-top: 4px; margin-bottom: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; 不过如果不是等份的图片板块，就会出现下方bug： 如何解决?代码如下：flex布局至bug修复1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt;*&#123;box-sizing: border-box;&#125;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行 */ margin: 0 -4px;&#125;.picture&#123; width: 194px; height: 194px;/* 或者 width: calc(25% - 8px); height: 194px; */ background: #ddd; /* 边框可去掉border: 1px solid red; */ margin: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 3、广告位布局——浮动+margin+clearfix清除浮动代码如下：1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; border: 1px solid black; width:33.333333%; height:300px&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.333333%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 广告位之间的间距如何处理：方法1： 采用内嵌一个div，定宽，float+margin-right进行间隙（这种方法似乎要兼容啊，做了很久弄不出，不弄了）方法2： calc计算法+margin1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; width:calc( 33.333333% - 20px);/* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; margin-right: 20px; /* 用多出的20px，弥补上那块间隙 */&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 方法3： flex布局（IE不支持） a.父元素：display:flex+justify-content:space-betweenb.父元素+子元素：display:flex+margin-right:auto 123456789101112131415161718192021&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; 如图也是： 三、布局套路口诀（下） 👉移动端布局 添加：meta:vp (tab键): 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 收起pc端导航：删除定宽+{margin:0; padding:0;} 导航 PC和手机适配的问题 123456789101112/* 导航PC和手机适配的问题 */.parent .nav2&#123; display:none;&#125;@media (max-width:420px)&#123; .parent .nav2&#123; display:block; &#125; .parent .nav&#123; display:none; &#125;&#125; banner适配移动端 123456789101112/*banner适配移动端*/.banner&#123; width:800px; /*万恶的定宽 PC端必备*/ height:300px; background: #888; margin-left: auto; margin-right: auto; margin-top: 10px; &#125;@media (max-width:420px)&#123; .banner&#123;width:auto;&#125;&#125; 图片板块适配移动端 12345678910111213141516171819202122232425262728/*图片板块适配移动端*/.pictures&#123; width: 800px; /* 万恶的定宽PC端必备;定宽布局不够弹性 */ margin: 0 auto; /*不能删1：居中*/ overflow:hidden; /* 避免溢出 */ &#125;@media (max-width:420px)&#123; .pictures&#123;width:auto;&#125; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ margin: 0 -4px;&#125;/*图片板块适配移动端2*/.picture&#123; width: calc(25% - 8px); height: 194px; background: #ddd; margin: 4px;&#125;@media (max-width:420px)&#123; .picture&#123; width: calc(50% - 8px); &#125;&#125; 广告位适配移动端 123456789101112131415161718192021222324252627282930313233343536373839/*广告位适配移动端*/.art&#123; background: #ddd; width:800px; /*万恶的定宽 PC端必备*/ margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;@media (max-width:420px)&#123; .art&#123; width: auto; flex-direction:column; &#125;&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;@media (max-width:420px)&#123; .art &gt; .sider&#123; width: auto; height: auto; &#125;&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;@media (max-width:420px)&#123; .art &gt; .main&#123; width: auto; height: auto; &#125;&#125; 关于图片添加：（注：变形问题减少使用img） 12background:transparent url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=292576901,2272109431&amp;fm=27&amp;gp=0.jpg) no-repeat center; background-size: cover; /*尽量全地显示图片*/ 注： 代码总链接：布局套路固定比例div：图片1：1显示或者2：1显示CSS渐变方法：解决背景样式渐变问题]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
        <tag>Float布局</tag>
        <tag>Flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-1你认真学了css？布局基础]]></title>
    <url>%2F2018%2F08%2F16%2F18-06.1%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、什么是布局1、现有的布局满足不了人们的需求文档流、浮动、定位 2、用户中所需要的： 导航栏+内容 导航栏+内容+广告栏 从上到下、从左到右、定宽、自适应… 二、几种布局介绍1、单列布局 一栏布局 一栏布局（通栏） 实现方式： 定宽 + 水平居中123width: 1000px; /*或 max-width: 1000px;*/margin-left: auto;margin-right: auto; 范例：单列布局——一栏布局关键代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .layout&#123; /* width: 960px; */ max-width: 960px; margin: 0 auto; &#125; //给 body 设置min-width 去掉滚动背景色 bug body&#123; min-width: 960px; &#125; #header&#123; height: 60px; background: red; &#125; #content&#123; height: 400px; background: blue; &#125; #footer&#123; height: 50px; background: yellow; &#125;&lt;/style&gt;/* 如图1：此时的定宽是width:560px */&lt;div class=&quot;layout&quot;&gt; &lt;div id=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;尾部&lt;/div&gt;&lt;/div&gt;/* 或通栏的单列布局,此时```.layout&#123;border:1px solid&#125;``` */ &lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;layout&quot;&gt;头部&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;context&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;layout&quot;&gt;尾部&lt;/div&gt; &lt;/div&gt;//或省标签，便于控制局部 如图2：&lt;div id=&quot;header&quot; class=&quot;layout&quot;&gt;头部&lt;/div&gt;&lt;div id=&quot;content&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt;&lt;div id=&quot;footer&quot; class=&quot;layout&quot;&gt;尾部&lt;/div&gt; 如图： 2、双列布局一列固定宽度，另一列自适应宽度实现方式：浮动元素 + 普通元素margin+老子清除浮动注： 布局时，考虑到渲染顺序，浮动元素代码优先写在其他元素前面，优先渲染第1种场景：两列布局范例：双列布局12345678910111213141516171819202122232425262728&lt;style&gt; #content:after&#123; //第3步：添加一个伪元素清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: left; //第1步：浮动元素 &#125; .main&#123; margin-left: 210px; //第2步：margin-left（right） height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 第2种场景：两列布局侧边栏aside在右侧：范例：双栏布局——侧边栏（aside）在右侧1234567891011121314151617181920212223242526272829&lt;style&gt; #content:after&#123; //第3步：清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 3、三列布局两侧两列固定宽度，中间列自适应宽度实现方式：浮动元素+margin+伪类元素清除浮动1234567891011121314151617181920212223242526272829303132333435#content:after&#123; ////第3步：伪类元素 content: &apos;&apos;; display: block; clear: both; &#125; .menu&#123; width: 100px; height: 500px; background: pink; float: left; //第1步：浮动 &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-left: 110px; /*为什么要加margin-left*/ //第2步：margin margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;div id=&quot;content&quot;&gt; &lt;!-- 为什么不是main在前面： 渲染顺序--&gt; &lt;div class=&quot;menu&quot;&gt;menu左&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;aside右&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content中&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 4、水平等距布局实现方式：处理老子（居中、防溢出）+浮动+ margin1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt;ul,li&#123; margin: 0; padding: 0; list-style: none; //取消列表的实心小黑点&#125;.ct&#123; overflow:hidden; //溢出隐藏 width: 640px; border:dashed 1px orange; margin: 0 auto; //相对于页面的居中&#125;.ct .item&#123; float:left; //第1步：浮动 margin-left: 20px; //第0步：提前设置 margin-top: 20px; //第0步：提前设置 width:200px; height:200px; background: red;&#125;.ct&gt;ul&#123; margin-left: -20px; //第2步：补充不够的20px&#125;&lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;ul&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;5&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;6&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;7&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如图： 三、其他布局 圣杯布局 双飞翼布局 流式布局 Grid布局 Flex布局 移动端布局（meta、媒体查询、动态rem）]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
        <tag>单列布局</tag>
        <tag>双列布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05你认真学了css？元素居中]]></title>
    <url>%2F2018%2F08%2F16%2F17-05%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一、元素水平居中1、text-align实现水平居中text-align:center; 行内元素（图片或文字）居中在父元素上设置text-align: center 使文字/图片在整个页面上水平居中123 .container&#123; text-align:center;&#125; 如一小选项按钮居中，可以使用：1234 .container&#123; display:inline-block; text-align:center;&#125; 2、margin实现水平居中margin: 0 auto; 用于块级元素的居中123456.container &#123; width: 80%; /*块级元素充满页面 定宽必备 */ margin-left: auto; margin-right: auto; /*或者 margin：0 auto;*/&#125; 如：块级元素居中代码如下：1234567891011121314 &lt;style&gt; .wrap&#123; max-width:600px; background: #ccc; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; 二、元素垂直居中1、居中 VS 不居中注： 高度由里面的内容撑开，一般不设置高度代码如下：123456789101112 &lt;style&gt;.ct&#123; padding: 40px 0; text-align: center; background: #eee;&#125; &lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;p&gt;你好世界&lt;/p&gt; &lt;p&gt;helloworld&lt;/p&gt; &lt;/div&gt; 2、vertical-align实现垂直居中vertical-align: middle; 让行内元素或表格元素相对于基线对齐并居中案例：如图片进行水平、垂直居中代码如下：图片在容器内水平、垂直居中12345678910111213141516171819202122232425&lt;style&gt;.box&#123; width: 300px; height: 200px; border: 1px solid ; text-align: center;&#125;/*注：子元素和父元素分别设置 vertical-align:middle; ，均无法实现垂直居中*//*使用一个伪元素，设置一个虚拟的基准线*/.box:before&#123; content: &apos;&apos;; display: inline-block; height: 100%; vertical-align: middle; ✔️&#125;.box img&#123; vertical-align: middle; ✔️ background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 如图： 3、table-cell 实现垂直居中display: table-cell;水平垂直居中代码如下：1234567891011121314&lt;style&gt;.box&#123; width: 300px; /*由于是行内元素，宽度必备*/ height: 200px; border: 1px solid ; display: table-cell; ✔️ vertical-align: middle; ✔️ text-align: center;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 4、绝对定位实现居中案例：如弹出框 弹出框水平垂直居中情况1： 固定宽高块在浏览器窗口水平垂直居中，代码如下：123456789101112131415161718192021222324252627282930&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; /*绝对定位*/ left: 50%; top: 50%; margin-left: -200px; margin-top: -150px; width: 400px; height: 300px; box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt; 情况2： 去掉宽高的块在浏览器窗口水平垂直居中，代码如下：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; left: 50%; top: 50%; /* margin-left: -200px; margin-top: -150px; */ /*CSS3属性 相对于自己的偏移*/ transform:translate(-50%,-50%); box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>水平居中</tag>
        <tag>垂直居中</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04你认真学了css？BFC+边距合并]]></title>
    <url>%2F2018%2F08%2F16%2F16-04%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9FBFC%2B%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[一、BFC1、定义：先给一个官方的定义：（可能会看不懂我也不懂） Formatting context(格式化上下文)是W3CCSS2.1规范中的一个概念。每个渲染区域用formattingContext表示，它是页面中的一块渲染区域，并且有一套渲染规则。它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 再看下面这个定义：（一点点懂） BFC（Block FormattingContext），块级格式化上下文。相当于制定一种如BFC这样的规则，在普通流中按照该规则进行布局。 在正常流中的盒子要么属于块级格式化上下文（BFC），要么属于内联格式化上下文，即块级元素在页面渲染的时候遵循怎么样的规则，它们之间有怎么样的作用。 再看这个：（还是一点点懂） 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 总结：BFC没有定义，只有功能或特性 2、BFC会在哪里产生（官方的）只要元素满足下面任一条件即可触发 BFC 特性（1）body根元素html里的根元素产生相应的“块级格式化上下文”这类的规则，如某些规则：块级容器可以充满父容器，父容器可以被子元素撑开，外边距产生合并，渲染顺序是从上到下（同一个块级格式化上下文中相邻块级盒之间的竖直margin会合并）（2）浮动元素：float除了none以外的值；如float:left;该元素属性本身也产生了相应的块级格式化上下文。该元素产生的BFC与所在的根元素的BFC互不影响，此元素的作用域，则为该元素服务，与根元素产生一个隐形的边界（3）绝对定位元素：position为absolute或fixed；（4）display为inline-block（非块盒的块容器）, flex, 或inline-flex；（5）overflow除了visible以外的值（hidden、auto、scroll） 3、应用这里的例子截取自该文章：10 分钟理解 BFC 原理（1）功能1让两个相邻的元素界限分明（同一个 BFC 下外边距会发生重叠或合并）代码如下：1234567891011&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是 200px。如图：首先这不是 CSS 的bug，我们可以理解为一种规范。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。123456789101112131415161718 &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;style&gt;.container &#123; overflow: hidden; ✔️&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/style&gt; 这时候，两个盒子边距就变成了 200px ，如图： （2）功能2子元素被父元素包裹起来（BFC可以包含浮动的元素）（可代替clearfix来清除浮动） display:flow-root; 让当前元素触发BFC（正交，考虑浏览器兼容） overflow:hidden; 将溢出隐藏浮动的元素会脱离普通文档流，来看下下面一个例子，代码如下：123456789101112131415&lt;style&gt; .father&#123; border: 1px solid #000; &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; 由于父元素（father）内子元素（son）进行浮动，脱离了“父亲”的文档流，所以容器只剩下 2px 的边距高度。此时可以触发容器的 BFC，那么“father”就可以包裹住“son”出去的浮动元素。12345678910111213141516&lt;style&gt; .father&#123; border: 1px solid #000; overflow:hidden; ✔️ &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; ✔️ &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; （3）功能3BFC 可以阻止元素被浮动元素覆盖。先来看一个文字环绕效果，代码如下：12345678910111213141516&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee;&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 此时，浮动元素浮在第二个元素上，第二个元素有部分区域被浮动元素所覆盖(但文本信息不会被浮动元素所覆盖) 。如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入overflow:hidden；或者display:flow-root;1234567891011121314151617181920212223&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; ✔️ background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee; overflow:hidden; ✔️ /*或 display: flow-root; */ ✔️&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 就会变成：BFC 浮动处理用来实现两列自适应布局：即左边宽度固定，如果想右边的内容自适应宽度，可以去掉上面右边内容的宽度（如果右边定宽，窄页面时，则会自动换到下一行排列） 二、边距合并1、讲例子案例1：当实际中希望#header和h1之间产生一点缝隙（或间距），即使将h1设置 margin:50px; ，作为块级元素的h1，margin左右生效，而上下则是#header+h1整体向下移动50px这便是，外边距合并 案例2：看案例似乎是&lt;h1&gt;和&lt;p&gt;标签所设置的外边距各30px，两者之间的间距理论来讲应该是60px，但事实上这是两个相邻元素的外边距产生合并，下边距&lt;margiin-bottom&gt;和上边距&lt;margin-top&gt;合并之后取较大值，这里为30px这也是，外边距合并 2、合并场景（1）相邻元素合并同案例2（2）父子合并h1和header，或者再嵌套元素或者与其的祖先元素嵌套，均能产生外边距合并，这些都能称之为“父子合并” ,如图：（3）自己合并如图，块级元素合并，无默认样式即靠在一起；含有p标签（含内容）的块级元素，则有默认上下margin，所以detail和footer则会产生缝隙（或间距） .footer元素为空内容，设置 margin:30px; ，即说明上边距和下边距合并后的外边距总值是60px，不过.footer元素为空内容，所以页面效果仍然呈现30px，说明css元素中外边距合并的另一种情况： 自己和自己合并： 如图： 三、取消合并（如何去解决外边距合并？）1、边框、padding 存在于父子合并 为何#header和h1能够产生合并？即#header没有border和padding（即一个可与外界隔离的边界线），导致h1自带的一个margin，冲出该边界，与#header合并 尝试在#header里添加边框（图1）或者加padding（内边距）（图2），让#header和h1的margin-top，内外分开，即能做到不让外边距合并，如图： 2、BFC如何让一个元素生成bfc？bfc可认为是拥有一片独立的空间，和其他的空间（或其他的文档流）区别开。注：添加bfc元素属性，可以取消合并有可能产生副作用（1）父子元素不产生合并A、添加：overflow:hidden；B、添加 ：float:left;C、添加： display:inline-block;D、添加： position:absolute; （2）相邻元素不产生合并A、添加：浮动元素B、添加：overflow:hidden；生成BFC，相当于生成了一个边界，即边框作为一个边界，有了边界之后，#header+h1父子元素便不能冲破该边界，自然与#detail元素的不产生合并. 【重点】： 而相邻元素之间的margin，可以认为不是该父子元素边界内，同样会产生合并。通常处理相邻元素之间的间距合并问题（除浮动外，浮动时不会被合并），即不考虑合并问题，直接设置为：margin-top:___px;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>BFC</tag>
        <tag>边距合并</tag>
        <tag>vim操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03你认真学了css？浮动+定位]]></title>
    <url>%2F2018%2F08%2F16%2F15-03%20%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%E6%B5%AE%E5%8A%A8%2B%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[自我总结： 浮动是实现布局的一种常见方式 浮动脱离普通文档流，即页面渲染时，盒模型按标准会将父元素所设置的属性将页面撑开；加入浮动后，父元素不会发现浮动元素，父元素则不会被浮动元素撑开页面）。 块级元素默认样式可以撑满父容器，加入浮动后，块级元素浮动则会收缩到内容本身的宽度。 加入浮动后，在父元素中看不见浮动元素，在行内元素看得见浮动，如文本或其他行内元素都会环绕浮动元素。 加入浮动后，浮动盒会向左或向右移动，直到其外边挨到包含块边沿或者另一个浮动盒的外边。 当同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面； 当反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下。 当浮动盒的宽度不一样时，紧跟后面的另一浮动盒则会出现卡住的现象。 加入浮动后，块级元素内容宽度会缩短，呈现inline-block的特性，放不下会换行；行内元素则以块级元素特性呈现，可以设置width、height、margin。 一、浮动：1、从实践尝试到理论定义（1）例子1：放不下会换行一个浮动盒会向左或向右移动，直到其外边（outerEdge）挨到包含块边沿或者另一个浮动盒的外边。如果没有足够的水平空间来浮动，它会向下移动，直到空间合适或者不会再出现其它浮动了（2）例子2：被卡住高度不一样，即出现一个卡住的问题（3）例子3：文本被缩短下移注： 未设置样式的块级元素，即有默认样式，margin-top(or bottom);因为浮动（盒）不在普通流内，在浮动盒之前或者之后创建的未定位的块盒会竖直排列，就像浮动不存在一样。接着，浮动（盒）创建的当前及后续行盒会进行必要的缩短，为了给浮动（盒）的 margin box 让出空间。 例子：如一个普通元素（如p）遇到浮动元素之后，普通元素（如p）看不见这个浮动元素，但这个普通元素里的行盒（文字生成的行盒特性）能看到该浮动元素。当浮动盒宽度变化，文字行盒也会相应地被挤下去换行。 2、从理论到实现效果（1）浮动元素脱离普通流？A、普通流是什么？页面渲染时，遵循“块级元素占据一行，行内元素一行水平排列占据它自身宽度，再来块级元素素依次向下排列”规律，并且这些元素从上到下，从左到右会将父元素所展示的页面撑开。B、脱离普通流：父元素计算宽高的时候，发现不了浮动元素。一旦有浮动元素，块级元素不会按照“从上到下，从左到右”的顺序去展示页面，块级元素会收缩内容宽度（呈现inline-block的特性），那么，父容器不会被里面的浮动元素撑开；行内元素则会能看见浮动元素，如文本或其他行内元素则会环绕浮动元素。例子：脱离普通流？！ （2）小结： 块级元素浮动，宽度会收缩（width:100%;的用武之地）； 行内元素浮动，以块级特性呈现（不用再写display: inline-block;）块级元素浮动宽度收缩，行内元素浮动以块级特性呈现 注： 块级元素默认样式可以撑满父容器，块级元素浮动则会收缩到内容的本身的宽度。如：1234.box&#123; float: left; background: red; &#125; 注： 行内元素能发现浮动元素，如设置float或者position元素属性，便有了块级元素的特性，可以设置宽高。1234567span&#123; float: left; background: blue; width: 100px; height: 50px; margin: 10px; &#125;; （3）注： 脱离普通流？！VS abosolute 3、浮动的使用场景（1）两栏布局特指一侧是固定宽度，另一侧是自适应（用margin间隔来表示自适应的作用，是因为普通的块级元素会充满整个页面）左侧固定宽度，右侧自适应 （反之，也可以） （2）三栏布局指两侧宽度固定，中间内容区块自适应简单的三栏布局注： 注意html结构顺序，即按照class为menu——aside——main的div元素顺序写法当一个浮动盒按照设置实现左浮动时，另一个浮动元素设置为右浮，此时这个右浮，即相对于同级元素的高度进行右浮（除非页面放不下被挤下移除外）。 （3）导航条list-style:none; float：left(or right); margin-left:XXpx; 左浮导航 右浮导航 4、清除浮动（1）为什么要清除浮动？虽然浮动是一种实现布局的方式，但是浮动在父元素中看不见。一旦在元素标签内加入了浮动，浮动脱离了普通流，在页面渲染时并不会按照html结构的计算规则，浮动元素会导致父元素所设置的页面无法撑开，浮动甚至会让浮动的效果叠放在页面某些元素效果上。所以必要时，需要清除浮动，这也是浮动实现布局的重要一环。从浮动具有副作用说起：问题A：对后续元素位置产生影响问题B：父容器告诉计算出现问题（2）clear:left;?例子：clear:left? clear:left;：要求该盒的topborder边位于源文档中在此之前的元素形成的所有左浮动盒的bottom外边下方 clear: right;:要求该盒的topborder边位于源文档中在此之前的元素形成的所有右浮动盒的bottom外边下方 即：box2设置clear:right有效吗?有 （3）清除浮动的两大副作用对应问题B：父容器告诉计算出现问题 【重点】由于浮动在父容器中不能被发现，但要解决父容器（或页面）撑开的问题，我们必须在浮动和父容器（或者浮动元素）共存时寻找到一种解决方法。即在带有浮动属性的父元素标签中添加class为clearfix，关于伪元素属性::after （或::before）的固定代码样式，伪元素清除浮动法（IE8以上使用）：123456789.clearfix::after &#123; content:&apos;&apos;; display: block; clear: both;&#125;/*或触发ie6的属性*/.clearfix &#123; *zoom:1;&#125; 设置一个普通元素内不具有浮动的属性参数，即float：none;和clear: left; 即可将完成clear:left;的效果【注意：应注重css元素的权重，以免报错】或【解决方法：】 方法1：父容器与浮动共存问题的解决 方法2：#1采用伪元素（一个替代标签）解决行内浮动问题#2采用伪元素（一个替代标签）解决块级浮动问题 （4）总结实现一个水平布局 方法1：设置display：inline-block;，注意缝隙和上对其的问题 方法2：加入浮动，用clearfix的固定代码包裹解决父元素撑开页面的问题 二、定位1、什么是定位？（1）先了解正常/文档流（Normal Flow）是什么Normal Flow即浏览器默认的文档布局方式。一旦添加了浮动和定位，脱离文档流之后，页面布局的规则发生变化。 （2）定位通过设置position属性来覆盖默认的布局样式。即元素添加position和对应的属性值，它则会脱离了文档流。position，让一个元素的位置在以前的基础上产生变动。（考虑：相对于谁和属性值） 2、定位的类型（1）静态定位 ：position: static;:默认值 默认的布局方式。（2）相对定位：相对于自身的位置position: relative;:相对默认的布局位置进行定位。注： left和top只对position:absolution/relative/fixed;生效所谓的相对定位，是针对移动的元素自身，相对于它本身原先位置做了对应位置的偏移。但它所占用的文档流位置大小是没有变的。 （3）绝对定位：相对于父元素位置position: absolute; 绝对定位元素脱离正常文档流，相对其定位上下文（Positioning Context）进行定位。 即页面上的正常元素看不见该绝对定位元素。但页面上绝对定位常覆盖其他元素。多个绝对定位元素存在页面，它们之间的绝对定位也相互看不见，产生重叠现象。 寻找页面中一个元素绝对位置，可以先设置该元素绝对定位：position: absolute; 然后先从它的父元素中进行相对定位：position: relative; 中确定该元素的绝对定位；如果没有此绝对定位，再从它的父元素的父元素（如body）里的位置找；如果没有，则根据html的根节点作为参考。 总结： 使用绝对定位时，设置好参考点，一般，绝对定位的参考点为元素父容器如一个元素设置了position：absolute；，那么它的父容器则设置position：relative； 注： 元素中使用了position：absolute;，就像浮动一样有了一些特性： A、加入绝对定位后，宽度收缩B、加入绝对定位后，行内元素呈现快接的特性，可以添加宽高（4）z-index由于使用绝对定位之后，产生元素覆盖的问题，z-index可以解决元素之间覆盖顺序的问题,，设置它的层叠顺序。如：（5）固定定位position: fixed; 相对浏览器窗口进行定位。如“回到顶部”、“内容变固定窗口不变”等效果。因此当滚动产生时，固定定位元素依然处于窗口的某个固定位置。12345.feedback &#123; right: 30px; bottom: 30px; position: fixed;&#125; （6）粘性定位（兼容性差）position: sticky;是相对定位和固定定位的结合。默认情况下表现为相对定位，当浏览器窗口顶端与元素的距离等于 top 属性的值时，转变为固定定位。如： 三、浮动和定位——解决的一些问题1、BFC和浮动2、浮动和负边距两个浮动元素，如果因放不下导致其中一个下移，对下移的元素设置负 margin值大于自身的宽度可将其上移如： 3、用inline-block;还是浮动（1）inline-block; 优势: 不需要清除浮动，简单，在设置居中时更方便,适合子内容不多的元素水平排列 劣势: 需要注意缝隙，注意对齐，ie8以下不能用 （2）float 优势: 兼容性好，没缝隙问题 劣势: 需要清除浮动，适合稍大的布局 4、用定位还是浮动？大布局、自适应用浮动；小元素、固定宽高用定位。具体要结合实际情况是关键。如：]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>浮动</tag>
        <tag>定位</tag>
        <tag>文档流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02你认真学了css？（基本样式2）]]></title>
    <url>%2F2018%2F08%2F16%2F14-02%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、背景 属性 描述 background 简写属性，将背景属性设置在一个生命中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 可设置元素的背景颜色 background-image 可把图像设置为背景 background-position 设置背景图像的起始位置（常用于图标在页面上的设置） background-repeat 设置背景图像是否重复，以及如何重复 background-size 设置背景的大小（兼容性）（css3） 1、background-position ：默认图片主要从左上角方向偏移 x y x% y% [top | center | bottom] [left | center | right] 2、background-repeat：背景图像是否重复或如何重复 no-repeat：背景图片在规定位置 repeat-x：图片横向重复 repeat-y：图片纵向重复 repeat：全部重复 3、background-size：背景图片大小的设置，用来拉伸、缩放 100px 100px contain cover 4、关于background相关元素的属性，代码如下：12345/*背景色和背景图片使用场景 */场景1：两元素适用于页面大、背景图片小场景2：背景图为.png格式的图片*/background-color: #f00; background-image: url(background.gif); background-repeat: no-repeat; background-attachment: fixed; background-position: 0 0;/*背景位置与页面窗口的宽、高成正相关*/ 可缩写为一句：background: #f00 url(background.gif) no-repeat fixed 0 0;如图： 注：使用background-color和background-image，需要注意：（1）将该页面撑开（2）注意background-size使用 二、CSS Sprite1、俗称“雪碧图”或“精灵图”指将不同的图片、图标合并在一张图上。2、作用：使用CSS Sprite 可以减少网络请求（如每一张小icon图片都会产生加载时间），提高网页加载性能。3、使用：利用background-position，对图标进行位置偏移三、隐藏or透明 opacity: 0; ：透明度为0，整体（透明度0-1，0.5为半透明） visibility: hidden; : 即元素看不见，但存在。 和opacity：0；类似 display：none； : 消失，不占位置（页面上渲染的其他元素都察觉不到） background-color ：rgba（0，0，0，0.2） 只是背景色透明 四、inline-block1、定义：既呈现inline特性（不占据一整行，宽度由内容宽度决定），又呈现block特性（可设置宽高，内外边距）注： display:block;的布局下，块级元素的宽度是一个可忽视的问题 2、缝隙问题：如图： 3、行内元素对齐问题：如图：在inline-block的布局下，可以看成文字对齐。默认情况下，行内元素对齐是以里面内容的底部为基线对齐（至少两个元素进行对比），其他则设置vertical-align：top(bottom、middle)等）进行基线对齐（在表格中使用尤为明显） 五、line-height1、定义：用于设置单行文本的行高。 2、几个问题：（1）了解line-height和margin、padding在使用上的一个区别 line-height: 2，所占据的行高是本身文字高度的2倍。 margin是外边距， padding则是内边距 （2）line-height的用法，数字和百分比的区别 line-height：2VS line-height： 100% line-height具有继承性。 line-height:2，所占据的行高是本身文字高度的2倍。想要页面每个元素都拥有几倍的行高，则设置为数字。 line-height: 200% ，是其父元素文字高度的2倍。（注：百分比有一定的相对性，如本身无设置和设置百分比，便可看出差别） 3、height=line-heihgt设置垂直居中单行文本，如图： 六、盒模型1、IE 盒模型IE 盒模型的width包括：content尺寸+padding+border（如IE678怪异模式，不添加doctype，使用ie盒模型，宽度=边框+padding+内容宽度），如图： 2、W3C标准下的盒模型W3C标准下的盒模型padding、border所占的空间不在width、height范围内，content宽度即是width（如chrome，ie9+,ie678，添加doctype，使用标准盒模型，宽度=内容宽度），如图： 3、box-sizing（css3新样式）为了使用方便，可以用IE盒模型计算宽度的方法，将width=border+padding+内容宽度A、W3C标准的盒模型：box-sizing： content-boxB、IE盒模型：box-sizing：border-box12&lt;div style=&quot;height:200px; width:200px; border:solid 10px #333; padding:100px&gt;&lt;/div&gt; 七、字体图标的实现1、字体图标的原理：当你写完带有字体的html文件时，在浏览器打开页面时，浏览器会读取 HTML 文件进行解析渲染。当读到「饥饿」两个字时会转换成对应的 unicode码（一种识别字体的特定编号）。再根据HTML里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face ，则加载对应字体文件）对应字体的字体文件。找到文件后根据 unicode 码去查找绘制外形，找到后绘制到页面上。 所以对于第二个范例， 「&amp;#9965」是「饥」的unicede码，所以用户最终也能看到serf字体样式的「饥」字。 2、实现步骤：第一步：进入Iconfont-阿里巴巴矢量图标库——选一个喜欢的图标——添加至购物车——添加至项目——复制Unicode码第二步：进入代码——并未展示图标（说明系统中没有能体现字体图标的该Unicode码，浏览器也未能识别Unicode码）——复制该图标自动生成的css代码（用@font-face来定义一个字体，该字体名可以随便取，这里为：XXX）——定义该字体图标，并设置它css样式如font-family：XXX；等样式1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &apos;iconfont&apos;; /* project id 645342 */ src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot&apos;); src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot?#iefix&apos;) format(&apos;embedded- opentype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.woff&apos;) format(&apos;woff&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.ttf&apos;) format(&apos;truetype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.svg#iconfont&apos;) format(&apos;svg&apos;); &#125; p&#123; font-family: iconfont; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&amp;#xe618;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 让一个元素”看不见”有几种方式？有什么区别? 1、display: none;给元素设置display:none;后，元素会从页面中彻底消失，它原本占据的空间会被其他元素占有，会造成浏览器的回流与重绘。 2、visibility: hidden;给元素设置visibility:hidden;后，元素会从页面中消失，它原本占据的空间会被保留，会造成浏览器的重绘，适用于希望元素隐藏又不影响页面布局的场景。 3、opacity: 0;给元素设置opacity:0;后，元素变成透明的我们肉眼就看不到了，所以原本占据的空间还在。 4、设置盒模型属性为0将height、width、padding、border、margin等盒模型属性的值全设为0，如果元素內还有子元素或内容，还应overflow: hidden;来隐藏子元素。123456789.box1&#123; width: 0; height: 0; padding: 0; border: 0; margin: 0; overflow: hidden;&#125; 5、设置元素绝对定位与top、right、bottom、left等将元素移出屏幕如：123456789.box1&#123; position: absolute; left: 100%;&#125;/*或*/.box1&#123; position: absolute; top: 100px;&#125; 6、设置元素的绝对定位与z-index，将z-index设置成尽量小的负数。但z-index是相对而言的，用z-index就要设置其他元素的z-index值，且如果元素本身占据空间很大就不一定会被z-index值比它大的元素完全覆盖，所以不推荐这种方法。 如：12345678.box1 &#123; position: absolute; z-index: -100;&#125;.box2&#123; position: absolute; z-index: 1;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>字体图标</tag>
        <tag>行内元素</tag>
        <tag>背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01你认真学了css？（基本样式1）]]></title>
    <url>%2F2018%2F08%2F16%2F13-01%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、块级元素、行内元素 块级（block-level）；行内（内联inline-level） 块级可以包含块级和行内；行内只能包含文本和行内 块级占据一整行空间；行内占据自身宽度空间， 宽高设置、内外边距的差异 1、block-level123div h1 h2 h3 h4 h5 h6 p hr（线）form ul dl ol pre tableli dd dt tr td th 2、inline-level123em strong span a br imgbutton input label select textareacode script 如图： 二、宽高-width、height只对块级元素设置生效，对行内元素设置无效 三、边框-border1、涉及边框的几个元素粗细、颜色、类型（实线、虚线、点线）border-width、border-color、border-style1234/*简写：*/p,span&#123;border:2px blue solid;&#125; 如图：第一个：第二个：第三个：第四个：第五个： 2、如何使用边框做三角形？第一个：第二个：第三个： 四、边距1、盒模型 2、padding-内边距代表内边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身） padding-top padding-right padding-bottom padding-left 3、margin-外边距代表外边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身），还可以是负值 外边距合并问题在行内元素中，使用margin和padding左右生效，上下不生效，如图： margin-top、margin-right、margin-bottom、margin-left 3.1 margin:0 auto 块级元素居中12345.box&#123;/* margin: 0 auto; 实际上是下面两个起了作用 */margin-left:auto;margin-right:auto;&#125; 对于块级元素设置margin:0 auto（即：margin:0 auto 0 auto;）可以达到居中目的 4、* 去除元素默认样式的margin 和padding1234*&#123;margin:0;padding:0;&#125; 由于页面元素在浏览器会有自身的默认样式：如图:用于清除浏览器的固定样式，重新设置宽高,如图可加：注： 默认样式1em=16px 五、display1、块级和行内的display： 块级：block,list-item,table 行内：inline，inline-table，inline-block注： 一个元素在默认情况下是一个display：inline display Value: inline block list-item inline-block table inline-t able table-row table-cell none inherit Initial: inline Applies to: all elements Inherited: no 注：display：inline-block的布局，有相关资料可以了解一下：CSS之使用display:inline-block来布局 2、CSS继承和不继承继承： 每一个元素都是文档树的一部分，每个元素都有其对应的父级元素，每一个父级元素的CSS属性值都可以被应用到它的子元素中。可继承属性一般为：font-size、font-family、color 。反之，CSS不继承通常为页面的细节元素，如border、padding、margin、background-color 、width、height等 六、font font-size：字体大小如：12px（较小）、14px（正常）、16px（浏览器默认）、20px（标题大小）、22、28、60px（大标题大小） font-family：字体，有宋体、微软雅黑、Arial等 font-weight：文字粗度，常用的就是默认值regular和粗体bold line-height：行高，即文字大小，可以用百分比、倍数或者固定尺寸。 font-size*line-height: 垂直高度（行+文字占据的垂直空间）注： 以上属性为可继承给子元素 1、如何使用：12345678910body&#123;font: 12px/1.5 tahoma,arial,&apos;Hiragino Sans GB&apos;,&apos;\5b8b\4f53&apos;,sans-serif;&#125;/*或者*/p &#123;line-height: 1.5;font-size: 14px;font-family: &apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif;font-weight: bold;&#125; 2、font-family（1）字体原理 使用浏览器打开页面时，浏览器会读取HTML文件进行解析渲染。当读到文字时会转换成对应的unicode码（可以认为是世界上任意一种文字的特定编号）。再根据HTML 里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face，则加载对应字体文件）对应字体的字体文件。找到文件后根据unicode码去查找绘制外形，找到后绘制到页面上。 （2）了解这里有一篇老师写的关于字体方面的实现原理，以前学过一点设计看了，以后如何配合设计师进行字体需求上还是蛮受用的，可以看看：若愚：「每日一题」聊一聊字体图标的实现原理 （3）font-family写法 在 CSS 中设置字体时，直接写字体中文或英文名称浏览器都能识别，直接写中文的情况下编码（GB2312、UTF-8等）不匹配时会产生乱码。保险的方式是将字体名称用Unicode来表示 宋体 SimSun \5B8B\4F53 （Unicode码） 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 ？可打开控制台 escape(&#39;微软雅黑&#39;)，将 %u替换成\ 3、chrome最小字体chrome 默认字体大小16px, 最小字体 12px若需要小于12px的字体，可参考以下解决方案：islittle/Web-Developer 七、文本1、类型 text-align：文本对其方式。left、center、right、justify（≈两端对齐） text-indent：文案第一行缩进距离 text-decoration：none（去掉下划线）、underline、line-through（删除线）、overline（顶部线） color：文字颜色 text-transform：改变文字大小写。none（不改写）、uppercase（小写展示大写）、lowercase（大写展示小写）、capitalize（单词的首字母变大写展示） word-spacing：可以改变字（单词）之间的标准间隔（对于中文，每字就是一单词） letter-spacing：字母间隔修改的是字符或字母之间的间隔演示如图所示： 2、几种情况：（1）行内元素居中，如：123456789&lt;style&gt;.box&#123;text-align: center;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;http://7xpvnv.com2.z0.glb.qiniucdn.com/6673909a-098c-4202-8b80-f4aad64e0262.png&quot;&gt;&lt;/div&gt; （2）display：inline-block元素居中，如：123&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;margin: 0 auto&quot; src=&quot;XXX.png&quot;&gt;&lt;/div&gt; （3）单行文本溢出，关键代码如：12345.card &gt; h3&#123;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;&#125; 如图： 八、颜色1、单词：red、blue、pink、yellow、white、black 2、十六进制： #ff0000 红色 #0000ff蓝色 #008000 绿色 #000000（黑色）= #000 #ffffff（白色）= #fff #eeeeee（淡灰色）=#eee #cccccc（灰色）=#ccc #666666（深灰色）=#666 #333333（深黑色）=#333 #f00（红色） #0f0（绿色） #00f（蓝色） rgb: rgb(255,255,255)，rgb(0,255,0) rgba: rgba(0,0,0,0.5)（css3中涉及） 九、单位1、px：固定单位2、em：相对长度单位，相对于当前元素的字体大小。如图： 3、rem：相对单位，相对于根元素（html）字体大小，即1rem = html设置的font-size，移动端较常用。关于rem的好处我查了资料这个我比较理解，分享出来：css3的字体大小单位[rem]到底好在哪？ 4、vw vh：相对单位，1vw为屏幕宽度的1% 兼容性较差 5、百分比：（涉及宽高？文字大小？line-height、position）十、其他1、a链接设置颜色注： 当鼠标放置a链接，本身就会出现“手”指针的形状效果 a有默认颜色和样式，会覆盖继承的样式1234a&#123;color：red；text-decoration: none;&#125; 2、列表去掉点123456789/* 设定列表样式为：无 ,即没有顺序数字、圆点出现*/ul&#123;list-style: none;&#125;/*也可这样*/li&#123;list-style: none;&#125; 如图：]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>行内元素</tag>
        <tag>块级元素</tag>
        <tag>宽高</tag>
        <tag>边距</tag>
        <tag>文本、颜色、单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00你认真学了CSS？]]></title>
    <url>%2F2018%2F08%2F16%2F12-00%E4%BD%A0%E8%AE%A4%E7%9C%9F%E5%AD%A6%E4%BA%86css%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言以前刚接触css的时候，总觉得一个元素对应着它相应的属性，并且与对应的html文件结合，大概就能出现你想要的漂亮页面把。但在CSS身上，“事与愿违”简直就是新手对它的代名词。 在css的世界里，不管是前端老手，还是资质尚浅的前端新手，都一定会犯“只知其一不知其二”这样的错误。以此，CSS也常被戏称为“不是科学，是艺术”。 要知道，“只知其一不知其二”这种错误真的是致命的，因为你永远不知道你明明检查了几万遍的正确的元素属性，到底是哪里出错了。所以在学习CSS之前，请先看一下方应杭老师回答的这篇，你就会对接下来学习CSS语法有更多的心理准备。 CSS那么难学竟然是因为它“不正交”：为什么 CSS 这么难学？ 这里先搞清楚几个基本概念：标签、元素、属性，有很多人会搞不清出哪个是指着哪个，一图释所有： 一、CSS介绍1、什么是css？CSS（Cascading Style sheets），是用来为网页添加样式的代码 2、盒模型：（1）内边距（padding）：围绕着内容的空间，比如围绕段落的空间（2）边框（border）：紧接着内边距的实体线段（3）外边距（margin）：围绕元素外部的空间（4）宽度（width）：这个涉及了IE盒模型和标准盒模型（5）高度（height） 二、应用1、简单示例：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;css 很6666&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456/*style.css*/h1&#123;padding:10px;background-color: orange;border:1px solid black;&#125; 2、CSS的工作原理三阶段： 浏览器输入url ——浏览器向服务器发送请求 —— 服务器将相关数据处理返返至浏览器 —— 浏览器拿到并加载页面 —— 解析html的字符串，词法分析解析成树状结构 —— create Dom tree解析html时，加载css，文件被下载——解析css文件对其分析—— attach style to Dom nodes，加入 create Dom tree两树状结构对应起 来—— 新的dom树（节点相关的元素、参数）—— 渲染、绘制页面 ？：白屏、加载顺序、加载时机 3、css应用方式（1）外部样式表（推荐）A、链接方式：通过&lt;link&gt;引入css，如：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;css 很6666&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; B、导入方式：通过@import引入样式，放入css中，不要忘记分号可选择以下几种方式：如12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 12/*加入条件限制，如媒体查询属性 */@import url(&apos;landscape.css&apos;) screen and (orientation:landscape); （2）内部样式（内嵌方式）即将CSS放在页面的&lt;style&gt;元素中，如：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;style&gt;@import &quot;style2.css&quot;;p&#123;font-size: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;你好&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 题外话： 注意文件路径 右键——检查——查看源代码——点击显示错误链接：1failed to load resource：net：ERR_FILE_NOT_FOUND 即提示有可能是以下错误可能： 文件不存在 文件路径写错了 （3）内联样式（行内方式）（不推荐）即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中，如：1&lt;p style=&quot;background:orange; font-size:24pax;&quot;&gt;css很棒&lt;/p&gt; （4）属性样式（废弃）如：&lt;img src=&quot;a.png&quot; width=100 height=200&gt; 三、css选择器1、选择器类型A、基础选择器（1）*：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 B、组合选择器（1）E,F多元选择器，相当于并列选择器。用, 分隔，同时匹配元素E或者元素F（2）E F后代选择器。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。用 &gt; 分隔，匹配E元素的所有直接子元素（再嵌套的子元素就没有用）（4）E+F直接相邻选择器。匹配E元素之后的相邻的同级元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 （既、又）id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素C、属性选择器D、伪类选择器E、伪元素选择器 关于这两类详情请看： miya Wang：#07你认真学了css？（基本样式7：伪类和伪元素 2、基础选择器（1）* ：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 演示图： 3、组合选择器（1）E,F多元选择器，相当于并列选择器。用,分隔，同时匹配元素E或者元素F（2）E F后代选择器。选择它所有的后代子元素。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。（普遍）选择它第一子元素，对再嵌套的子元素没用。用&gt;分隔，匹配E元素的所有直接子元素（4）E+F直接相邻选择器。匹配E元素之后的相邻同级所有元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 既、又，直接靠在一起，同时拥有这两个类选择器特性的一个元素。id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和 #本身充当分隔符的元素 4、属性选择器（1）E[attr]匹配所有具有属性attr的元素，如div[id] 就能取到所有有id属性的div（2）E[attr=value] 匹配属性attr值为value的元素，如div[id=test]，匹配id=test的div 5、伪类选择器（1）定义：代表一个元素的另一种状态（2）类型：A、第一类： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：active匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c)匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E：checke 匹配表单中被选中的radio或checkbox元素 E：selection 匹配用户当前选中的元素 例子1：如设置E：hover时，鼠标悬停元素时字体颜色就会变成蓝色。选择器权重会使得a:hover{color:blue;}大于a{color：red;}的权重，所以样式产生了覆盖，如图： 例子2:a链接上常用的css属性选择器： E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：hover 匹配鼠标悬停器上的E元素 E：active 匹配鼠标已经其上按下，还没被释放的E元素由于css元素按顺序填写，依次展现元素属性，这里涉及到：a这个元素下的伪类选择器权重，从而造成样式覆盖，如图演示： 例子3：(1) E：enabled 匹配表单中可用的元素(2) E：disabled 匹配表单中禁用的元素如输入框被禁用，如何设置css里的元素属性，如图： B、第二类：(1) E：root匹配文档的根元素，对于html文档，实际上就是html元素(2) E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1注： E:nth-of-type(n)与:nth-child()作用类似，但仅匹配使用同种标签的元素如图当n=1时如图当n=？（1除外的任意数）n的取值1231，2，3，4，52n+1，2n，4n-1odd，even： 如何运用： 做一个表格上，分别可以做两色相间的表格效果，那么就可以运用odd，even12345/* nth-child(odd) 与 :nth-child(even) 分别匹配序号为奇数与偶数的元素 */.h-table tr:nth-child(even)&#123;background-color: #f1f1f1;&#125; 例子： 6、伪元素选择器（1）E::first-line 匹配E元素内容的第一行（2）E::first-letter 匹配E元素内容的第一个字母（3）E::before 在E元素之前插入生成的内容（4）E::after 在E元素之后插入生成的内容 举例如图： 7、选择器的优先级（1）定义如果多条规则作用于同一个元素上，且定义的相同属性的不同值。 （2）代码如下：12345&lt;style&gt;#test&#123;color:#666;&#125;p &#123;color:#333;&#125;&lt;/style&gt;&lt;p id=&quot;text&quot;&gt;Text&lt;/p&gt; （3）CSS优先级从高到低分别是：A、在属性后面使用 ：！important 即会覆盖页面内任何位置定义的元素样式B、作为style属性写在元素标签上的内联样式C、id选择器D、类选择器E、伪类选择器F、属性选择器G、标签选择器H、通配符选择器I、浏览器自定义 （4）复杂场景(按顺序） a、行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b、ID选择器c、类、属性选择器、伪类选择器d、标签选择器、伪元素 注： 选择器的优先级是如何计算的？ A、按顺序来计算的：假设： a等级：行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b等级：ID选择器c等级：类、属性选择器、伪类选择器d等级：标签选择器、伪元素 即a-d等级权值依次为5、4、3、2，按照a-d等级的属性顺序依次得分，若取到相应等级的权值，最高的则为最优先级别。 B、参考：当不同类别的多个选择器混合使用个怎么计算优先级？有一个简单的算法，设 a.内联样式表的权值为1000b.ID选择器的权值为100c.class类选择器的权值为10d.HTML标签选择器的权值为1 （5）样式覆盖后面的样式会覆盖到前面的样式 （6）选择器使用经验 遵守css书写规范 使用合适的命名空间 合理地复用class- 习题练习：1、CSS 加载方式有几种？答：（1）外部样式表（链接+导入）（推荐） 通过&lt;link&gt;引入css 通过@import导入样式，放入css中，不要忘记分号。在html或者css文件中都可以导入@import（2）内部样式（内嵌方式），即将CSS放在页面的&lt;style&gt;元素中（3）内联样式（行内方式）（不推荐），即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中（4）属性样式（废弃） 2、@charset有什么作用？在外部样式表文件内使用，指定该样式表使用的字符编码。该规则后面的分号是必需的，如果省略了此分号，会生成错误信息。如在外部css文件中写：123@charset &quot;utf-8&quot;;* &#123;sRules&#125;.class&#123;sRules&#125; 3、@import有什么作用？如何使用？答：作用：通过@import引入样式或者css文件，可以减少文件的容量，加快文件加载速度。用法：12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 4、id 选择器和 class 选择器的使用场景分别是什么？答：（1）id选择器，用于匹配特定id的元素，具有独一无二不可代替性（2）class选择器，用于匹配class包含（不是等于）特定类的元素，描述一组元素的样式，你可以多次使用class赋值，来命名元素名 5、CSS选择器常见的有几种？答：基础选择器、组合选择器、属性选择器、伪类选择器、伪元素选择器 6、伪类选择器有哪些？伪元素有哪些？答：（1）伪类选择器： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited 匹配所有已被点击的链接 E：active 匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c) 匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E： checked 匹配表单中被选中的radio或checkbox元素 E： selection 匹配用户当前选中的元素 ：root 匹配文档的根元素，对于html文档，实际上就是html元素 E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1 E:nth-of-type(n)与：nth-child()作用类似，但仅匹配使用同种标签的元素 （2）伪元素： E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 7、以下选择器分别是什么意思?（1）12#header&#123;&#125; 答：id选择器，匹配id为header的元素 （2）12.header&#123;&#125; 答：类选择器，匹配class为header元素 （3）12.header .logo&#123;&#125; 答：后代选择器，匹配class为header的元素logo （4）12.header.mobile&#123;&#125; 答：即又关系的并列元素，同时匹配这两个类选择器特性的一个元素 （5）12.header p, .header h3&#123;&#125; 答：多元选择器，同时匹配.header p 和 .header h3两个元素 （6）12#header a:hover&#123;&#125; 答：在id为header元素下匹配a元素鼠标悬停属性 （7）12#header .logo~p&#123;&#125; 答：在id为header元素下匹配logo元素之后的同级所有元素p （无论直接相邻与否） （8）12#header .logo+p&#123;&#125; 答：在class为header元素下匹配logo元素之后的相邻同级元素p （9）12#header .logo p&#123;&#125; 答：在id为header元素下匹配class为logo的后代元素p （10）12#header .logo&gt;p&#123;&#125; 答：在id为header元素下匹配class为logo元素的所有直接子元素，即第一子元素p （11）12#header p.logo&#123;&#125; 答：在id为header元素下同时匹配p元素和class为logo元素这类既又关系（并列）的元素的特性 （12）12#header .logo.p&#123;&#125; 答：在id为header元素下同时匹配class为logo和p的元素 （13）12#header input[checked]&#123;&#125; 答：在id为header元素下匹配checked值的input的元素 8、运行如下代码，并对结果做出解释123456789101112131415161718192021222324&lt;style&gt;.box:first-child &#123;color: red;&#125;.box:first-of-type &#123;background: blue;&#125;.box :first-child &#123;font-size: 30px;&#125;.box :first-of-type &#123;font-weight: bold;&#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;p.box&lt;/p&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;item&quot;&gt;div.item&lt;/div&gt;&lt;p class=&quot;item&quot;&gt;p.item&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;&lt;/p&gt;&lt;/div&gt; （1）效果图展示：（2）对其结果作出解释：运行1：123.box:first-child &#123;color: red;&#125; 选择同级第一个元素,并且这个元素class是 box,显示该标签元素的内容颜色为红色 运行2：123.box:first-of-type &#123;background: blue;&#125; 选择同级第一个标签元素,并且这个元素是这个同级中的第一个标签，显示背景色为蓝色 运行3：（.box : :.box和:之间要有空格）123.box :first-child &#123;font-size: 30px;&#125; 表示.box 里面（父元素）的第一个元素，显示字体大小为30px的结果 运行4：123.box :first-of-type &#123;font-weight: bold;&#125; 选择 .box里（父元素）第一个同类型的元素，字体粗细为粗体]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS选择器</tag>
        <tag>CSS应用方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML表单（二）：表单元素]]></title>
    <url>%2F2018%2F08%2F16%2F11-%E6%B5%85%E8%B0%88HTML%E8%A1%A8%E5%8D%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、实践1、贴上完整的代码图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;login&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;!--&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女--&gt;&lt;/div&gt;&lt;div class=&quot;sexchoose&quot;&gt;&lt;label for=&quot;sexchoose&quot;&gt;取向&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex2&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex2&quot; value=&quot;女&quot;&gt;女&lt;/div&gt;&lt;div class=&quot;hobby&quot;&gt;&lt;label&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dota&quot;&gt;dota&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;travl&quot;&gt;旅游&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;pet&quot;&gt;宠物&lt;/div&gt;&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;123&lt;/textarea&gt;&lt;input type=&quot;hidden&quot; name=&quot;abcd&quot; value=&quot;12345&quot;&gt;&lt;/div&gt;&lt;div class=&quot;file&quot;&gt;&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;choose&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;select name=&quot;city&quot;&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot; selected&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;button&gt;提交&lt;/button&gt;&lt;!--&lt;/div&gt;&lt;div class=&quot;submit&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/div&gt;--&gt;&lt;!--&lt;div class=&quot;submit&quot;&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt;--&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、效果图： 二、具体标签：1、form代码结构如： 1&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; form标签是表单的外壳，有4个主要属性： （1）action：表单提交的地址 （2）method：提交表单的方法 （3）target：在何处打开action （4）enctype： application／x-www-form-urlencoded：在发送前编码所有字符（默认） text／plain：空格转换为“+”加号，但不对特殊字符编码 multipart／form-data：使用包含文件上传控件的表单是，必须使用该值 2、type代码结构如：1&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; （1）type=&quot;text&quot;普通的文本输入框，单行输入（不行回车换行）。可输入文字展示 （2）type=&quot;password&quot;输入密码是以圆点展示，不被人知道 （3）type=&quot;checkbox&quot; 呈现带有阴影的勾选方框代码如下：123456&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;hobby&quot;&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&gt;读书&lt;input type=&quot;checkbox&quot; name=&gt;听歌&lt;input type=&quot;checkbox&quot; name=&gt;游泳&lt;/div&gt; 如图： 注： A、如果是分组，name写成不同，表示多选，如针对hobby这个关键字的搜索，value值需要设置，否则后台提交的用户信息将显示为on（无信息展示）。图： B、value的作用：让后台来识别该字段的信息 （4）type=&quot;radio&quot; 呈现带有阴影的点选圆框代码结构如下：12345&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/div&gt; 图： 注：radio 如何分组？举例说明，只需要在&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;中的name值设置另一个意义值，就可以分组显示，如： 第1组：12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女 第2组：12&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女 即：1234567&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女&lt;/div&gt; 如图： （5）type=&quot;file&quot; 用于文件上传，呈现“选择文件”按钮，点击即可上传文件1&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png，image/jp&gt; 注： accept该参数使用，即用于接收所限制的文件格式 （6）type=&quot;hidden&quot;作用： 暂存信息。 如在type=&quot;hidden&quot;埋下一个值，后台定位获取相应的值，可安全存值，用户什么都看不见，只能在后台看到； 保障安全。 当打开一个页面，实际上该页面是后端写的模板并在里面填充数据，填充好数据后，安全策略时使用type=&quot;hidden&quot;，即：1&lt;input type=&quot;hidden&quot; name=&quot;abc&quot; value=&quot;123456&quot;&gt; 当用户提交用户信息至后台，同时该安全点type=&quot;hidden&quot;的值也会提交后台，后台进行校验——确认过安全，相当于埋在后台与用户信息相匹配的一个安全校验值，即该用户为一个合法用户。 （7）type=&quot;button&quot;，不能点击提交 （8）type=&quot;submit&quot;，可以点击提交 （9）type=&quot;reset&quot;，用于清空所有用户信息 注： A、以下input有何作用？1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;提交按钮&quot;&gt; B、type=&quot;submit&quot; ， 提示input作用为“提交”按钮 C、value=&quot;提交&quot;， 显示提交作用，意义在于“点击提交”的交互作用 D、input里name 作用？ 即用于传递数据给后台都形成有意义的识别值，如用value和name赋值，如果不写的话，该输入标签将不会有任何意义，就等于无实际操作表单的意义。 3、type=hidden隐藏域作用type=hidden隐藏域，作为校验该用户信息的一个隐藏值（判断标准）。当用户打开页面后是看不见type=hidden相应的值，填写用户信息之后点击提交时，用户信息的数据（包括type=hidden值）随即提交后台，打开后台则会展示代码type=hidden所写的相应元素属性值。后台校验type=hidden相应值如果是正确，即用户提交为安全。 埋点（保护的参数）——浏览器提交后台有该参数作为校验标准参考——若显示错值或无值，服务器也将不承认所提交的数据；若为正确值，则说明该用户获取权限，即为合法用户，可防止CSRF攻击 4、label输入框前的文字标注代码如下：1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt; 注：for，用于点击文字或输入框时，是文字显示一种focus状态，可直接输入对应信息 5、select下拉菜单代码结构如下：12345678&lt;div class=&quot;choose&quot;&gt;&lt;select name=&quot;city&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot;&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;/div&gt; option中，设置默认选择的初始值，即 &lt;option value=&quot;cat&quot; selected&gt;猫&lt;/option&gt; 6、extarea实现多行文本，展示较大的输入框。即常见的评论框。代码结构如下：123456&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;123&lt;/textarea&gt;&lt;/div&gt; 注：若在&lt;textarea&gt;...&lt;/textarea&gt;中输入任意值，即相当于value赋值的意义，也就是说在&lt;textarea&gt;...&lt;/textarea&gt;输入的值都能显示其输出的意义。 7、placeholder用于输入什么用户信息的提示代码结构如下： 1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt; 图：]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>表单</tag>
        <tag>提交原理</tag>
        <tag>元素标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML表单（一）：表单提交原理]]></title>
    <url>%2F2018%2F08%2F08%2F10-%E6%B5%85%E8%B0%88HTML%E8%A1%A8%E5%8D%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、html表单1、什么是表单能够去输入用户信息的一个单子。和我们平时填写的纸质表单一样，在HTML页面上，也有表单是用于搜集不同类型的用户信息输入 2、作用用于收集已收集的信息，提交你网站的后台（或者服务器）。HTML表单是一个包含表单元素的区域，表单元素是允许用户在表单中（表单元素包含如：文本域、下拉列表、单选框、复选框等）输入信息的元素 二、写表单1、表单提交原理一般表单有登录名、密码，form、input，表单所有信息用form元素包裹。用包裹所有input元素输入框，当点击提交后，将会把form所包裹得所有input输入框的信息提交给后台的一个地址上。 2、写表单（1）表单内的主要标签属性：A、&lt;form&gt;...&lt;/form&gt;B、&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; action : 把数据提交到后台的地址，如action=&quot;/a123&quot;，即提交到当前域名下的/a123 method：提交数据的方式 （2）demo：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;login&quot;&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;username&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;submit&quot;&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （3）html文件用浏览器打开页面当写出登录名、密码、提交代码后（之后加上性别），以get形式点击提交，页面url显示input输入的相应的内容： 注：点击提交代表向服务器发送了一个请求，这个文件是通过get方式进行表单收集 假如，将以下代码放置在&lt;form&gt;&lt;/form&gt;标签之外，12345678&lt;div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;form&gt;.....&lt;/form&gt;&lt;/div&gt; 以get形式提交的页面url也不会显示相应的内容： 3、终端上操作即本地终端开启服务器，以服务端的方式打开页面（1）命令行开启静态服务器，并打开页面：因为之前我已经安装nodejs，用npm安装了http-server这个服务器，所以可以执行以下代码直接打开这个静态服务器：1$ http-server 代码执行之后，输入相应的url出现的页面，两步骤之后的示意图：注：以下情况给没有安装nodejs 的人看的（安装了就可以不看） 假如有人之前没安装nodejs，就不能用npm命令去开启一个静态服务器，所以可以先看看我这篇：​浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）​​看完之后可以下载nodejs，在终端执行以下代码：​​​​​$ sudo npm install -g http-server$ http-server​这样之后就开启了一个静态服务器，就可以用里面的url打开相应的html文件​​（2）输入相应信息之后，出现：​​​（3）页面右键——检查，重新输入表单信息，点击提交​出现页面相对应的html文件——form.html的请求，先贴上我操作后出现的页面：​​​- 请求的地址：​​Request URL: http://127.0.0.1:8080/a123?username1=wxq393&amp;password1=12345​​- 请求的类型：​​Request Method: GET​- 请求的参数：​username1: wxq393​​​password1: 12345​​​（4）两种请求类型：get和post​A、get请求​即当form.html中method=&quot;get&quot;时，页面上点击“提交”时，就会将form.html展现的信息进行组装，以view的形式去组合成这个url地址：http://127.0.0.1:8080/a123?username1=wxq393&amp;password1=12345，向这个地址发送请求。​​get请求，本质上就是url的拼接，把你的参数拼接在一起组成一个新的url:​​注：username所得的参数是属于input标签中的name属性​​B、post请求​关于post类型发送请求：由于我的服务器http-server，是个静态文件服务器，不支持post请求。​可以看老司机的演示：​ ​post的请求类型得到的url地址更干净，更安全。​​ 三、post和get的区别1、method提供两种提交方式：​一种是get方式向后台发送请求，提交数据；另一种是post方式向后台发送请求，提交数据 2、区别​（1）从安全性上，二者表象不同，get把提交的数据url可以看到，会展现在浏览器历史记录中，安全性不好；但是post看不到，安全性好。​​（2）从提交数据量上，get最多提交1k数据，浏览器上的url地址框有字符长度限制；post理论上无限制，受服务器限制。​​（3）从原理上，get 是拼接 url，post是放入http 请求体中。 3、应用场景（怎么合理两种方式传递数据？）​注： 在实际应用上，get 重在 “得到”, post 重在”传递”​​即假如向后台查询一篇论文，请求数据，请求为“得到”，用get方式请求数据；向后台“传递”数据，写了文章之后传递至后台，通常是“传递完成”的状态进行提示，用post方式请求数据。​​ 四、表单元素​呐，早说了，w3c是个好东西😂，轻戳：​HTML 表单元素]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>表单提交</tag>
        <tag>URL</tag>
        <tag>POST</tag>
        <tag>GET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门（三）：git高级命令讲解（远程库↔本地库，以及分支操作及冲突解决）]]></title>
    <url>%2F2018%2F08%2F08%2F9-git%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Agit%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%EF%BC%88%E8%BF%9C%E7%A8%8B%E5%BA%93%E2%86%94%E6%9C%AC%E5%9C%B0%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[看git入门，请想象自己就是开发人员，正在操作一个项目的本地与远程的文件版本更新控制。前言 之前Git操作——简单使用 远程创建一个git项目，clone到本地，即为本地仓库（即一个含有.git隐藏文件夹的项目文件夹），经过本地终端命令的操作，再push到远程库。所有的修改、删除、提交、推送等都是由这个.git的文件进行记录的，如果去掉，这个项目就是一个普通的文件夹。 一、本地新建git项目push到远程空仓库 现在Git操作——复杂使用 本地新建一个git项目，push到远程空仓库。 1、先在github上操作创建有一个空仓库blogtest_01（不包含初始化文件，即一个未建好的仓库），进入项目页面出现： 通过在本地将这个仓库建好，push到远程仓库 2、再在终端上操作（1）在本地任意创建一个文件夹（此时，这个还是空文件夹，不是仓库）1$ mkdir blogtest_01 （2）看github项目主页上的提示1$ touch README.md 执行status查看1$ git status 出现报错：fatal: Not a git repository (or any of the parent directories): .git ，即没有仓库 （3）空文件夹初始化一个仓库1$ git init 出现提示：1Initialized empty Git repository in /Users/wxq393/blogtest_01/.git/ 即说明已经初始化一个空的仓库 验证仓库查看1$ ls -a 即会出现.git相关的文件夹，代表仓库已在本地建成 执行status再查看1$ git status （4）开始添加、暂存、提交一系列本地操作12$ git add .$ git commit -am &quot;init&quot; 本地新建仓库进行推送（注意这是一个重要点）1$git push 注：会出现异常，因为本地新建的blogtest_01起初并不知道是指向远程库blogtest_01，所以需要执行一个指向地址的命令（在github项目主页上有提示），即：1$ git remote add origin git@github.com:wxq393/blogtest_01.git 注： origin其实就是远程的git地址的一个别名1$ git push origin master 3、贴上我在本地终端执行命令的全过程： 注：本地仓库，只要知道仓库管理的地址，就可以推送到任意一个远程库（如coding、新浪云等管理工具）管理 4、其他命令（这里以gitlab作为可改标签）（1）慎用，强制推送会覆盖别人的代码1$ git push -f origin master （2）再添加一个远程库的标签12$ git remote add gitlab git@gitlab.com:abc/blog.git$ git remote -v 推送到gitlab标签1$ git push gitlab master 注：这里善用搜索引擎，查找不会的命令意义： $ git remote -v ，-v (即 –verbose 简写,取首字母)，显示对应的克隆地址。即列出详细信息，在每一个名字后面列出其远程库的url。 （3）删除gitlab标签1$ git remote remove gitlab （4）修改origin标签对应的地址（可以一个命令修改git的https或者ssh地址）1$ git remote set-url origin git@github.com:jirengu/blog3.git （5）把gitlab 标签改名为coding1$ git remote rename gitlab coding 二、分支操作（git的重要操作部分） 分支：push origin master中，master就是分支。自己画了一个git项目的分支示意图😅，应该能理解？： 1、查看所有分支1$ git branch -a 获取如图： （绿色分支——本地分支）*master ：当前本地仓库主干master （红色分支——远程分支）remotes/origin/master :远程库的主干 2、创建本地库dev分支12$ git branch dev$ git branch -a 3、切换主干和分支操作（1）切换到dev分支1$ git checkout dev 具体操作：123456$ git checkout dev$ ls$ open .$ touch index.html$ git add .$ git commit -am &quot;add file&quot; 注： index.html在dev这个分支上 （2）切换到master主干1$ git checkout master 注： index.html没有在master的主干上结论： 同一个项目文件夹，只要切换不同分支，就会展示不同分支的文件状态 4、推送到origin地址的dev分支上1$ git push origin dev 5、那么，在github的展示：可以想象成两个开发人员在blogtest_01这个Git的项目上分别操作了两个分支，各自工作 6、将dev分支内容合并到主干上12$ git checkout master$ git merge dev 可以查看一下1$ ls 然后，合并（merge）后的项目便是共同协作的结果 7、推送到远程库中1$ git push origin master 那么，线上代码便是master，共同维护一份代码。这样一来是不是对分布式的版本控制有更深的理解了🤔 【我的一些思考和解决】 那么，我产生一个疑问：刚才的分支操作主要是针对本地库分支向远程库推送的主要操作。但是如果在远程库修改了分支文件，到本地库怎么修改操作呢？ 这里我主要修改主干master上的readme.md文件，如何在本地终端上如何操作？我的猜想：git pull——git checkout master——git add . /git commit ——git push？ 搞了半天，我所想的“关于含有分支的远程库，在远程库修改后，如何在本地库终端命令中进行更新、修改、提交、推送等一系列命令行的问题”，就是一个冲突问题啊！！！！ 三、冲突1、什么是冲突自己和你的小伙伴该同一个文件的同一个地方，在执行git pull时，更新本地合并时会出现冲突 2、操作：（1）之前我（开发人员A）已经在远程库的master上进行README.md文件的修改，如图： （2）现在我（开发人员B）在本地想要在master主干上的README.md文件也进行修改，但前提我需要把远程主干分支pull下来 注：具体在我之前的《浅谈git入门（二）：git基本命令讲解》中“三.5多人协作”就有讲过。 不过，这次是远程项目的指定分支被pull下来，终端命令行细节上有所不同，即主要执行以下代码:1234$ git branch -a /*（可省略）*/$ git pull origin master$ ls /*（可省略）*/$ vim README.md 继续执行：123$ git add . /*（可省略）*/$ git commit -am &quot;fix master&quot;$ git push origin master （3）现在回到远程库（github），发现更新了： （4）贴上我终端操作的全过程：]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>git高级命令</tag>
        <tag>分支操作</tag>
        <tag>冲突解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门（二）：git基本命令讲解（本地库↔远程库）]]></title>
    <url>%2F2018%2F08%2F08%2F8-git%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%EF%BC%88%E6%9C%AC%E5%9C%B0%E5%BA%93%E2%86%94%E8%BF%9C%E7%A8%8B%E5%BA%93%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言看git入门，请想象自己就是开发人员，正在操作一个项目的本地与远程的文件版本更新控制。 一、Git原理（why use git）1、版本控制（1）定义：是一种记录一个或者若干个文件内容变化，以便将来查阅特定版本修订情况的系统（理论不好理解） （2）用处：情况一： 项目文件中有很多文件，经过许多天后修改若干个文件，想找到之前某一天所修改的错误记录，却无从查起，这个时候便需要一个有提交文件记录（包括提交时间、提交修改内容等）的文件修改的版本控制工具来帮助你 情况二： 多人协作共同管理一个拥有多个代码文件的项目，你需要有一个提交修改记录的版本控制工具去告知你的伙伴，该文件在何时何地修改了什么内容，以便伙伴了解，便于团队之间协作 2、种类（1）本地版本控系统 （2）集中式版本控制系统（SVN）即拥有共有的服务器，作为中心节点，pull、commit、push都集中在这台服务器上进行操作，受限于服务器不灵活性和网络问题 （3）分布式版本控制系统（Git）哎这个不说了，累，具体操作和体验可以看之前写的《git的初尝试》：浅谈git入门（一）：git初尝试 3、Git优势 诞生于2005年，来源自linux开源社区 速度很快 分布式（不怕断网哈哈~） 简单的设计 允许上千个并行分支同时开发 二、Git的几个重要概念1、记得之前在《git初尝试》中尝试对项目进行本地和远程库之间文件版本的操作控制。如下图标注，终端操作，push到远程库的全过程： 2、仓库中的三种必备状态（重要概念）：（1）已暂存（staged），将已修改的文件放在下次提交（提交至本地仓库）时要保存的清单中，即暂存区里）。（2）（添加了文件之后，）已修改（modified）某个文件，但还没有提交保存（3）已提交（committed）该文件，已经被安全地保存在本地数据库中了 三、简单演示1、起步初次使用，需要设置姓名和邮箱12$ git config --global user.name &quot;你的名字&quot;$ git config --global user.email johndoe@example.com 2、clone一个项目用于把一个已有的github项目clone（下载）到本地变为本地仓库 12$ git clone git@github.com:jirengu/blog.git$ cd blog 3、添加文件并提交【本地库↔远程库】（1）创建文件1$ touch a.md （或者直接打开本地仓库目录新建文件） 由于刚才的文件是空文件，通过一个命令在文件中写入一个字符串：1$ echo &quot;hello&quot; &gt; a.md （2）查看仓库状态1$ git status 此时，学会看命令行提示（英语单词了解一下吧orz(￣▽￣)”）如提示：untracked files（未跟踪）、nothing added to commit（还没添加文件在暂存区去等待本地提交），并提示怎么做：（use “git add” to track）。如图： （3）把当前文件夹下的新增和删除全部放在暂存区1$ git add . 再次查看：1$ git status 如查看提示：use “git reset HEAD …” to unstage，即可以将文件从暂存区拿出来。 （4）把暂存区的更新提交到本地库1$ git commit -am &quot;add file&quot; 关于-am “add file”中的-am可以看一下份资料：git commit -m 与 git commit -am 的区别: git commit -m 与 git commit -am 的区别而-am “add file”即说明文件以什么修改状态（如修改？添加资料？）即被跟踪暂存等待本地提交。 再次查看1$ git status 提示push 推送本地仓库1$ git push origin master 4、修改、删除文件【远程库↔本地库】（1）把远程库拉下合并（merge）到本地仓库1$ git pull （2）操作文件 修改文件1$ vim a.md 或 删除文件12$ rm -rf a.md$ git add . （3）添加文件至暂存区1$ git add . （4）提交至本地库1$ git commit -am &quot;字符串&quot; 注： 这里需要注意的是如果提交消息包含大量字符串，提交参数不用加m （5）推送远程库1$ git push origin master 5、多人协作（1）有一人在远程修改文件，你不知道仍继续在终端修改提交文件1234$ touch b.md$ git add .$ git commit -am &quot;add b&quot;$ git push 终端修改，出现拒绝的报错，如： （3）这个报错说明终端push远程文件失败。即在远程库的一些已修改的文件没有更新到本地，本地文件夹里没有相应的更新，你需要在本地终端同步更新远程库所更新过的文件。 （4）被多人协作过的远程库拉下本地更新一下，即执行：1$ git pull 自动将更新后的远程库拉回来，并merge（合并）你所更新的文件，进入一个vim编辑器，编辑需要更新的文件1$ vim b.md 你要怎么样都可以，不想干嘛就保存退出，不再说vim的使用方法了。赶紧看下一步：123$ git add .$ git commit -am &quot;merge&quot;$ git push 结论：每一次在本地库完成自己的文件更新，都需要git pull一下，让远程库在本地与你的文件合并（merge），在推送（push）]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>git基本命令</tag>
        <tag>本地仓库、远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门（一）git初尝试]]></title>
    <url>%2F2018%2F08%2F08%2F7-git%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89git%E5%88%9D%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[😂先憋说话。。。。。。。你以为我要说什么？！！！先实践，后理论 新建项目操作——克隆（下载）远程仓库已有项目到本地来操作 1、新建一个新的repo 2、确定创建该项目一般点选红框的选项，一般需要点选readme.md，拥有一个初始化文件 3、进入项目页面 （1）resame.md用于项目介绍说明，github自动读取readme.md，把markdown格式自动转成html，展示在页面上 （2）clone or downloaduse https VS use ss use https：每一次操作都需要用户名和密码，较为麻烦 use ssh：一般选它作为项目（仓库）的地址，它是一个git协议 这里，用我的ssh地址作为项目（仓库）的地址：git@github.com:wxq393/blogtest.git 作为例子进行演示。 4、克隆已有项目（1）此时打开终端，将use ssh协议下的拷贝下来的项目地址使用命令行进行操作1$ git clone git@github.com:wxq393/blogtest.git （2）提示错误1fetal：could not read remote repository （3）设置公钥 插播：设置公钥的终端命令行要写什么？从哪里找？ 通常可以从github主页的头像——setting——（左侧选项中）SSH and GPG keys中[generating SSH keys]蓝色链接中（图1）去寻找： 点击之后，选择Generating a new SSH key，即有命令行操作的提示（图3）： 这里继续以我的实例讲解： 1$ ssh-keygen -t rsa -b 4096 -C &quot;wangxiaoqin.0009@163.com&quot; （4）出现公钥1$ cat ~/.ssh/id_rsa.pub （5）返回线上github主页点击：头像——setting——（左侧选项中）SSH and GPG keys——SSH keys——（右上角绿键）new ssh key 在key中复制粘贴在命令行中的一大串公钥： 确认后需要再填写github的登录密码确认（不要慌）： （6）返回终端再次用git clone克隆（下载）远程仓库的项目，便会提示克隆成功。（由于我之前已经设置过公钥了，如果终端出现的提示信息有类似“done”的字眼，即可说明克隆成功。不一定和我一模一样，灵活应对命令行的提示） 5、本地VS远程的文件提交终端操作切换目录、创建文件、提交本地、推送远程库的一系列过程： 6、返回github项目主页 目的：利用项目setting中的githubpages的功能，将代码文件生成线上可预览的页面 （1）点击项目上的setting，找到githubpages的选项，进行master branch （2）此时，save（红框标注）变灰色，并生成一个预览页面的链接（红线标注） 7、想要本地编辑（如写作），push远程github操作： 重复第5步骤，就可以愉快地进行这样的操作了注： 这里面还涉及前面命令行的操作，比如线上vim编辑等，灵活应对。实在写得太细了，我都不好意思再贴图操作了。(￣▽￣)”🤣]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>git操作</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（四）：好玩的命令行操作（有好玩再补充）]]></title>
    <url>%2F2018%2F08%2F08%2F6-%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9C%89%E5%A5%BD%E7%8E%A9%E5%86%8D%E8%A1%A5%E5%85%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[置顶资料：用来练习命令行，一天一个命令行：一天一个命令行 一、可以开启一个翻译工具第一步：打开终端或者 gitbash，输入：1$ npm install -g fanyi 或有些人的电脑有管理员权限的，需要前面加上sudo1$ sudo npm install -g fanyi 这里还需要输入你的开机密码 第二步：然后在终端下输入1$ fanyi 你好 即可进行及时翻译附上我电脑的终端命令行操作图：]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>图形界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（三）：如何登录开发机]]></title>
    <url>%2F2018%2F08%2F08%2F5-%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E7%99%BB%E5%BD%95%E5%BC%80%E5%8F%91%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给小白的登录开发机指南，老司机慎入 一、疑问1、为什么要用开发机学会一定的部署技能，就需要用到开发机。在本地搭建好的网站部署到开发机或线上机器，这类工具本质上指的就是Linux机器（即linux系统） 2、如何访问它通过本地连接它，连接上后打开终端 3、在哪操作通过命令行操作 二、如何操作1、先贴上我自己操作的全过程： 2、具体步骤如下： 第一步：通过ssh打开某开发机对应的用户名1$ ssh vip14@47.91.156.35 注： 这里我就以：vip14@47.91.156.35 作为某开发机的用户，@ 后为远程IP地址（可以简单理解“定位”功能吧） 第二步：此时，出现钥匙一个小图标，提示输入机器的密码。注意，输入密码时没有提示，但输入是有效的。 第三步：（不用操作，看结果）如果密码正确输入，此时，命令行会显示这样的字眼：welcome to XXXXXX，说明你已经进入这个远程机器上 第四步： 1$ ls 第五步： 1$ cd miya 第六步： 1$ touch a.md 第七步： 1$ ls 此时，出现一个a.md的文件，你所搭建好的网站的html文件，此时就可以将它传到这里，上传方式可使用：A、代码生成github，然后在pull下来，或者B、通过命令行直接拷贝过来，直接在命令行里的开发机上直接启动，别人访问线上就能看到你所写的网站效果 第八步：举例：创建一个html文件 1$ touch index.html 第九步：使用vim编辑器在线编辑 1$ vim index.html 即进入在线编写代码的界面，具体操作我之前就写过关于vim在命令行里的操作了哈，可点击查看：《浅谈命令行（一）：命令行基本操作（包括vim在终端的基本操作）》 第十步：开启一个静态服务器1$ npm install http-server 划重点： 不能用-g 全局安装的原因：注意到这个时候我们并没有用-g（即全局模式），因为我们进入了一个线上的开发机，不是本机的管理员。命令行上显示的使用的是阿里云的服务器，在云服务器中我们不能用全局模式，比较受限。 开启一个静态服务器：1$ http-server 第十一步：展示一下miya文件夹下的文件 1$ ls 第十二步： 1$ node_modules/.bin/http-server . - p 这里填上四位数的端口号 第十三步：用开发机 ：1vip14@47.91.156.35 里的1@ 后面的IP地址：47.91.156.35 与刚才的端口号、html文件名去组成一个新的url地址：147.91.156.35：8081/index.html 我自己操作之后，所出现的结果： 总结： 老司机告诉我，购买域名，做个映射，打开这个域名后就是你的网站。]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>vim操作</tag>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>登录开发机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）]]></title>
    <url>%2F2018%2F08%2F08%2F4-%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E6%B6%89%E5%8F%8Anodejs%E5%92%8Cnpm%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[掌握了终端的一些基本命令，可以做点什么呢？用命令行，可以安装一个静态服务器哦~关键词： Nodejs、npm、全局安装、http-server 一、安装Nodejs1、什么是NodejsNode.js 是一个让 JavaScript 运行在服务端的开发平台。（不懂就算了，不用太在意，反正应该是帮助js更友好地去开发的一个开发平台。。。啊吧） 2、下载链接： nodejs注： nodejs下载完后，你将不会看到它像其他软件那样出现在桌面，需要用命令行去调用它。 3、验证是否安装成功此时，可以开启终端，用命令行验证：1$ node --version 如图： 二、使用npm安装一个静态服务器1$ npm install -g http-server 1、npm是什么npm是一个node包管理和分发工具，已经成为了非官方的发布node模块（包）的标准。有了npm，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包。新版的nodejs已经集成了npm，所以之前npm也一并安装好了。（网上摘抄?(￣▽￣)~*，不懂就算了，我暂时也不太明白(￣３￣)a） 2、npm的作用npm是随同Nodejs一起安装的包管理工具，能解决Nodejs代码部署上的很多问题。（不懂就算了，以后到时间自然会懂的 ~(￣▽￣)~） 3、再次打开终端操作以下步骤：（1）开启npm1$ npm （2）用npm安装http-sever1$ npm install -g http-server 结论： http-server被安装成功，可以开启一个静态服务器注：1-g 为全局安装模式，去掉-g之后就是本地模式，如果出错就可以试一下本地模式 题外话： 关于本地模式和全局模式的问题，这里就不展开讲了，我怕我暂时的不专业耽误别人。需要的可以看一下这两篇文章： nodejs本地模式和全局模式 node.js 本地模式与全局模式的区别​（反正我自己是看懂70%?，没事慢慢来） 划重点： 有些人的电脑如果提示错误（我的就是这样?），不要抓狂，试一下是否需要管理员权限：1$ sudo npm install -g http-server （3）开启http-server（这个是一个服务器哦）1$ http-server （4）尝试启动http-server在浏览器打开你的本地文件（有点绕ㄟ(▔,▔)ㄏ）在命令行假设在桌面（desktop）操作一个名为code文件夹中的from.html文件123$ ls$ cd code$ http-server 此时，将会出现服务器的url，复制下来在浏览器中打开，在code目录下启动这个静态服务器，用新的url来展示code文件夹下所相对应的html文件夹。结论：这种方式，就不是我们用本地的方式打开html文件 （5）贴上我自己安装的全过程： 以及，用1（http://）127.0.0.1：8080 这个url自浏览器打开code里文件的结果： （6）退出http-server在终端上Ctrl+c，便会退出http-server]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（一）：命令行基本操作（包括vim在终端的基本操作）]]></title>
    <url>%2F2018%2F08%2F08%2F3-%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8C%85%E6%8B%ACvim%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、命令行1、了解一些关键名词： 图形界面 命令行：在终端窗口下输入一些命令就可以满足一些操作需求 终端：mac下打开终端（terminal），win下打开gitbash shell：执行当前脚本的一个载体，统称shell。如输入命令ls，即展示当前文件下的所有文件（ls本质上是字符串），通过shell底层地接受字符串的操作输入，在底层做一些文件检索，最终展示出ls发出的请求的文件 bash：本质上是一个软件。 2、安装使用 win安装git，打开gitbash linux：打开终端 mac：打开终端、iterm 二、基本命令1、查看当前完整的路径：pwd1~ $ pwd 结论： 就是看看此时我在哪个文件夹下 2、查看当前目录下文件：ls 不包括隐藏文件 1$ ls 查看当前目录下所有文件（包括隐藏文件） 1$ ls -a 查看当前目录下所有文件（包括隐藏文件）的详细信息 1$ ls -al 注：书籍推荐《鸟叔的linux教程》 3、切换目录：cd1$ cd 文件夹名 如：1234$ cd /c/project$ cd code$ cd ../css$ cd ~/desktop 再比如cd 打开桌面的集中方式： 以我的电脑desktop上的code文件夹为例子解释： 两点和一点的区别： 返回上一级文件夹: ..（即返回 ~ 家目录） 1$ cd .. 当前文件夹: . （即desktop这个文件夹） 1$ cd ./code 结论： 即切换到当前目录下的code文件夹 1$ cd code 4、文件路径（1）根路径：/ （即整个系统最根本的路径）1$ cd code 根目录&gt;家目录如错误示范：1$ cd /code 即根目录下不会有code这个文件夹注： 如果要操作根路径里的其他文件夹，需要管理员权限 根路径不是C盘，根路径就是根路径 （2）家目录：~1~ 家目录，即当前的用户下的路径 ：如1/Users /wxq393 如果是:1~ /desktop $ 即是1/Users/wxq393/desktop $ （3）当前目录：.12$ cd code$ cd ./code （4）上级目录：..12$ cd ..$ cd ../code 5、创建文件 : touch1$ touch readme.md 6、删除文件 : rm1$ rm readme.md 强制删除文件夹，不提示1$ rm -rf helloworld 或许1$ rm -r helloworld 演示： 7、重命名文件 : mv1$ mv readme.md README.md 8、创建文件夹 : mkdir1$ mkdir projects 三、终端中的编辑器vim的使用终端命令行中先创建1$ touch a.html 第一步： 1$ vim a.html 初始进入编辑器命令模式 第二步： 键盘上：i进入编辑模式INSERT 第三步： 键盘左上角：escINSERT消失，进入命令模式 第四步： 1：wq 保存退出 或者1：q！ 不保存强制退出 第五步：1$ cat a.html 查看文件结果]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>vim操作</tag>
        <tag>命令行</tag>
        <tag>终端</tag>
        <tag>图形界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2018%2F08%2F07%2F2-%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[划重点输入一个url地址——对url中的域名进行解析——服务器处理——网站处理——浏览器处理 一、URL1、现象：随意在浏览器里输入一个网址，比如baidu.com你会看到什么？看到百度的搜索页面： 2、url是什么它是统一资源定位符（Uniform Resource Locator），用于定位互联网上的资源。即寻找互联网上的资源，如图片、文件或者css文件等，需要通过互联网的一个东西，则叫url。 3、url由什么组成协议、端口号、域名，其他相关信息 4、常见的协议http、https、ftp、file协议如：* http:// wangxiaoqin.com/blog 帮你找到网络上的某个资源。明文传输，即传输过程中使用路由器拦截，如用户名密码都能被看到 https:// 10.245.23.456:3000/users 经过一个加密后的协议， 相当于加了一层隧道，无法破解，用户名和密码都不会被看到，是一个安全的协议 file:///users/hunger/workspace/a.html 从本地打开至浏览器，用于定位你本地电脑上的文件 // wangxiaoqin.com/static/imgs/a.png 当前文件的url与当前页面的协议保持一致 二、对URL中的域名进行解析 对于http://wnagxiaoqin.com的URL，浏览器实际上不知道wangxiaoqin.com到底是什么东西，需要查找wangxiaoqin.com网站所在的服务器的IP地址，才能知道找到目标。 即通过一种方式，将wangxiaoqin.com解析成wangxiaoqin.com所对应的IP。 1、域名的作用最后也是要找到IP，为何不直接使用IP？平时用的网站，IP对应的均为数字，或者一个网站对应众多IP地址，而域名则具有语义化的作用，好识别 2、域名是什么对于http://wangxiaoqin.com.com:**8080**/blog，wangxiaoqin.com就是域名（注：**：8080**可以省略）如，www.baidu.com(加粗的为域名） 3、IP地址是什么每个处于互联网的设备都有IP地址，刑如：192.168.0.1 ，没有IP地址别人就找不到你。局域网IP和公网IP是有差别的，如公司使用同一个路由器，连接同一WiFi，处于同一局域网，IP地址相应的就是局域网的IP地址。直接通过这个IP地址，访问到这个局域网其他机器，外界的其他人则找不到。 实践点： 调试手机：如做一个手机页面的开发项目，在PC端搭了一个服务器测试是没问题，手机上的测试：手机和电脑连接同一个WiFi，手机浏览器通过电脑的ip地址去访问电脑上的服务器 公网IP需要申请 127.0.0.1代表本机的IP 4、如何把一个域名解析成一个IP地址？流程： 浏览器缓存： 通过输入wangxiaoqin.com，之前找到过这个域名相对应的IP地址，将会缓存DNS记录一段时间，即过往记录，下次访问直接访问IP地址； 系统缓存： 若是第一次访问网站，将会查找系统缓存，即从Hosts文件查找是否有该域名和对应的IP地址（通过soptlight搜索houstbuddy——/etc/hosts或develop找到hosts文件，即IP+缓存名 作用：开发一个网站，开发过程中，关于开发网站的html、css等文件资料均在本地，而我想要写一个线上的域名，如wangxiaoqin.com。想要修改，则可以开启一个服务器去测试，不想找到远程服务器的东西，而是找到电脑中的文件。此时，我们可以在系统缓存中找到wangxiaoqin.com对应的IP地址，打开html文件，所有的请求资源如果是wangxiaoqin.com则将会自动转向相对应的IP地址 路由器缓存， 一般的路由器登录之后也会缓存域名信息 ISP DNS缓存， 比如到电信（你的服务商）的DNS 上查找缓存 如果以上都没有，开启查找IP的过程： 如访问某个小国的新的域名，则向根域名服务器查找域名对应的IP，比如我请求的是abc.com，那它就会向根域名服务器.com这个域名服务器去查找，把请求转发到下一级，找到之后便会告诉你IP是多少 5、dns连接上网问题（1）dns是什么DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。 （2）电脑突然上不了网 修改dns为8.8.8.8或者114.114.114.114即能上网 8.8.8.8 ， 即谷歌提供的一个dns服务器。如打不开baidu.com是因为你中间的某个环节出问题，然后baidu.com对应的IP找不到，此时可将电脑中的dns服务器直接改成谷歌的服务器，那么就会直接从谷歌的服务器去找该域名下对应IP 114.114.114.114 ，权威提供dns的国内服务商结论： 从某个有记录的服务器去查找 （3）dns劫持是什么比如，黑客攻击某个节点或某根域名服务器（即攻击这里所管理的众多IP地址），如baidu.com相对应的百度IP被侵入任意网站的IP，再打开baidu.com通过域名解析之后，可能通过ISP dns上查找到任意IP，会得到“真域名 假IP”的假网站，危害巨大 通过域名，在浏览器输入url地址，得到IP地址 （经过一段复杂的IP寻址的过程） 知道IP之后，浏览器可以向IP地址发送请求 三、服务器处理（浏览器可以向IP地址发送请求）1、服务器是什么服务器是一台安装系统的机器，就是一台电脑。 2、常见的系统如linux（无图形界面）、windows sever2012（可以安装一些服务端的软件，有图形界面）。 3、机器处理请求如何知道wangxiaoqin.com是什么？系统里安装的处理请求（如wangxiaoqin.com）的软件应用叫web server，用于接收网站发来的请求，并处理 4、web服务器（1）常见的web服务器Apache、Nginx、IIS、Lighttpd （2）作用web服务器，用于接收用户的Request交给网站相关代码，或者接收请求反向代理到其他web服务器。即管理的入口 机器上安装了Nginx的web服务器，如访问http://jscode.me或http://jirengu.com或http://hungerworks.com（三个网站请求，网站地址和域名都不一样，但都是在同一个服务器里），通过域名解析得到了机器里的同一个IP地址：202.112.230.14，即打开这三个网站均能找到这台机器，请求被机器中的web服务器——Nginx接管，通过配置文件将请求的网站匹配相应的文件夹代码，运行返回效果。 凡是通过http方式获取的网站，都是通过web服务器做一个管控。即使在本地搭建网站也是需要搭建web服务器。 web服务器处理完请求之后交至网站（如wagxiaoqin.com），运行代码文件，后台云烟执行。 四、网站处理流程1、后台语言ruby、nodejs、python 2、MVC模式（模型（model）视图（view）控制器（controller））比如，浏览器访问jirengu.com/users，交至/users这个网站后代码运行，匹配路由，发现有/users之后，交给控制器（一个代码文件），它会向模型（可看成文件）发送调用查找所有用户请求，模型从数据库中进行查找，数据库返回之后，控制器获取模型所提供user.all的接口数据，控制器获取所有用户数据，将数据添置到视图（可看成模板）中生成一个html，发回浏览器，即能看到有所有用户的html页面。前端对应则是视图（htmlcss框架等） 五、浏览器处理网站处理之后，该网站生成html页面发回浏览器，html字符串被浏览器接收后被一句句读取解析，当解析到link标签后，如某个标签对应的css地址，重新发送请求获取css地址；当解析到script标签后，向如src的地址向服务器发送请求，获取js并执行代码；当解析到img标签后发送请求获取图片资源 即第一次获取html时，浏览器会重新把html里的链接和相关资源再请求一次，审查元素里有众多requests 六、绘制网页浏览器根据html和css计算得到渲染树，绘制到屏幕。即浏览器根据html、css，它知道每个元素该怎样去放置，假设页面作为一幅画，css控制画的样子，html控制画的内容，浏览器画（渲染），之后js将会被执行。]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>URL</tag>
        <tag>域名解析</tag>
        <tag>浏览器处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown，一款不用排版写文工具]]></title>
    <url>%2F2018%2F05%2F27%2F1-Markdown%EF%BC%8C%E4%B8%80%E6%AC%BE%E4%B8%8D%E7%94%A8%E6%8E%92%E7%89%88%E5%86%99%E6%96%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一、Markdown1、定义：一个简单的标记语言，通过一些转换库可以将markdown和html进行互相转换 2、作用：用来在网页上展示文章，省去排版布局的很多烦恼 二、Markdown语法1、作用：如在简书写博客，Markdown语法的字符串提交到简书服务器保存起来，当打开页面时，Markdown的字符串就被后端语言转换成html，然后放到博客页面。博客页面里引入一些 CSS，会把丑陋的 HTML 变的好看适合阅读 2、基本语法=写文章（1）展示标题：# 一级标题 h1## 二级标题 h2### 三级标题 h3#### 四级标题 h4##### 五级标题 h5 （2）展示段落（直接写）：这是段落 p （3）展示无序列表：1234```- ```无序列表```-``` 无序列表```-``` 无序列表 （4）展示有序列表：1231. 有序列表2. 有序列表3. 有序列表 （5）展示代码123javascriptvar a = 1var b = 2 （6）展示单行代码var a = 1 （7）展示链接Markdown中文教程 （8）展示图片 （9）展示引用&gt; 引用 （10）展示表格1234| 表头 | 表头 | | --- | --- | | 内容 | 内容 | | 内容 | 内容 | 左对齐：1234| 表头 | 表头 | |..--- | --- || 内容 | 内容 | | 内容 | 内容 | 右对齐：1234| 表头 | 表头 | | --- ..| --- || 内容 | 内容 | | 内容 | 内容 | 居中：1234| 表头 | 表头 | |.. --- ..| ---|| 内容 | 内容 | | 内容 | 内容 | （11）展示加粗** 加粗 *** 加粗 * (12)展示斜体*** 斜体 *** 三、用Markdown来写文章 注意：尽量空格明显，避免不同平台Markdown的展示效果不同在github上的.md文件上的展示 1、创建文件2、后缀.md生成+markdown语法3、写好保存，网站渲染生成内容4、生成内容四、总结：掌握Markdown语法，轻量级去写更多你喜欢的纯文字文章最后，附上Markdown中文教程链接：​Markdown中文教程好好学习，天天向上！！！]]></content>
      <categories>
        <category>程序员技能</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>程序员写作神器</tag>
        <tag>标记语言</tag>
      </tags>
  </entry>
</search>
